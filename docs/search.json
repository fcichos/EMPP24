[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Computer-based Physical Modeling",
    "section": "",
    "text": "1 Python Example\nThis example demonstrates running Python code in the browser using Pyodide.\n\nThis is then not working anymore.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Example with Pyodide</span>"
    ]
  },
  {
    "objectID": "courseinfo/course_info.html",
    "href": "courseinfo/course_info.html",
    "title": "2  Course Information",
    "section": "",
    "text": "3 Vorlesender\nEmail: lastname@physik.uni-leipzig.de\n\nProf. Dr. Frank Cichos\n\nLinnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +0341 97 32571",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course Information</span>"
    ]
  },
  {
    "objectID": "courseinfo/website.html",
    "href": "courseinfo/website.html",
    "title": "3  Diese Webseiten",
    "section": "",
    "text": "Diese Website enthält alle Informationen, die für unseren Kurs Einführung in die Modellierung Physikalischer Prozesse erforderlich sind. Sie werden hier jede Woche eine neue Vorlesung und eine neue Aufgabe finden. Die Vorlesungshefte werden von Videos begleitet, die den Inhalt der Vorlesung auf Englisch erklären, aber Sie können auch mit dem Lesen auskommen. Die Vorlesungen in Person, werden auf Deutsch stattfinden. Von diesen Webseiten aus werden Sie zu verschiedenen Ressourcen geführt, die Sie nutzen können, um das Programmieren in Python zu lernen. Dabei werden wir einige großartige Tools aus dem Internet nutzen, wie\n\nGoogle Colab Dienst, um auch Jupyter Notebooks (https://colab.research.google.com) zu hosten. Das Google Colab-Projekt bietet eine nützliche Umgebung zur gemeinsamen Nutzung von Notebooks.\n\n\n\ngoogle colab screen\n\n\nWenn Sie die folgende Website besuchen, werden Sie an mehreren Stellen das folgende Symbol sehen.\n![Substitution Name1]\nDieses Symbol zeigt an, dass diese Webseite auf einem Jupyter Notebook basiert. Anstatt nur die Website zu betrachten, können Sie auf das Symbol klicken und der Google Colab-Dienst wird geöffnet, damit Sie das Notizbuch interaktiv nutzen können. Google Colab öffnet sich viel schneller als myBinder, aber die Notizbücher sind für die Arbeit mit myBinder gemacht und nicht alle Funktionen funktionieren mit Colab. Ich arbeite jedoch an der Kompatibilität.\nGitHub and GitHub Pages Dienst zum Hosting von Websites (https://github.com). GitHub ist ein großartiger Ort, um Ihre kollaborativen Coding-Projekte einschließlich Versionskontrolle zu hosten. In der oberen rechten Ecke finden Sie auch einen Link zum GitHub-Repository, in dem die Notebooks gehostet werden.\n\n\n\ngithub screen\n\n\nAnaconda Jupyter package für Notebooks auf dem eigenen Computer (https://www.anaconda.com/distribution/). Das Paket anaconda stellt Ihnen die Jupyter Notebook-Umgebung einschließlich Python zur Verfügung. Wenn Sie Jupyter zu Hause ohne Online-Zugang verwenden möchten, ist dies ein gutes Paket zur Installation.\n\n\n\nanaconda screen",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diese Webseiten</span>"
    ]
  },
  {
    "objectID": "courseinfo/schedule.html",
    "href": "courseinfo/schedule.html",
    "title": "4  Zeitplan für den Kurs",
    "section": "",
    "text": "Der Kurs wird wöchentlich mit dem Zeitplan der Vorlesungen aktualisiert. Erwarten Sie also jede\nDienstag ab XX. Oktober 2024, jeweils um 11:15\neine neue Vorlesung und eine neue Aufgabe. Bitte nutzen Sie den ersten Dienstag, um sich die Website und die Einführungsvideos durchzulesen. Bitte benutzen Sie auch das myBinder/Collab-Symbol am oben auf der Seite und versuchen Sie, sich mit den Notizbüchern vertraut zu machen. Die Vorlesung 1 und die Aufgabenstellung 1 folgen am XX. Oktober 2024.\nErfahrungsgemäß werden die besten Ergebnisse erzielt, wenn Sie bei den Vorlesungen im Hörsaal anwesend sind. Das gesamte Material wird jedoch auch online zur Verfügung stehen, so dass Sie jederzeit wiederkommen können, um zu lernen, wann immer es Ihnen passt. Wir werden auch jede Woche Videos (Englisch) hinzufügen, die die Details der Notebooks erklären.",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Zeitplan für den Kurs</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html",
    "href": "courseinfo/resources.html",
    "title": "5  Ressourcen",
    "section": "",
    "text": "5.1 Molecular Nanophotonics Group",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html#molecular-nanophotonics-group",
    "href": "courseinfo/resources.html#molecular-nanophotonics-group",
    "title": "5  Ressourcen",
    "section": "",
    "text": "Molecular Nanophotonics Group Website\nComputer-based Physical Modeling Website @ MONA\nDiscord Channel Invitation Link for Discussions",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html#additional-advanced-courses",
    "href": "courseinfo/resources.html#additional-advanced-courses",
    "title": "5  Ressourcen",
    "section": "5.2 Additional Advanced Courses",
    "text": "5.2 Additional Advanced Courses\n\nRosenow Group (Theory), Master Course on Statistical Mechanics of Deep Learning",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html#python-documentation",
    "href": "courseinfo/resources.html#python-documentation",
    "title": "5  Ressourcen",
    "section": "5.3 Python Documentation",
    "text": "5.3 Python Documentation\n\nPython\nMatplotlib\nPandas",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html#python-tutorials",
    "href": "courseinfo/resources.html#python-tutorials",
    "title": "5  Ressourcen",
    "section": "5.4 Python Tutorials",
    "text": "5.4 Python Tutorials\n\nIntroduction to Python for Science\nNice MatPlotLib tutorial",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html#julia-tutorial",
    "href": "courseinfo/resources.html#julia-tutorial",
    "title": "5  Ressourcen",
    "section": "5.5 Julia Tutorial",
    "text": "5.5 Julia Tutorial\n\nJulia Programming Language",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "courseinfo/resources.html#pluto-notebook",
    "href": "courseinfo/resources.html#pluto-notebook",
    "title": "5  Ressourcen",
    "section": "5.6 Pluto NoteBook",
    "text": "5.6 Pluto NoteBook\n\nPluto GitHub Webpage ```\n\nIn this conversion:\n\nI’ve changed the RST headers to Markdown headers, using # for the main title and ## for subheadings.\nThe links have been converted from RST format to Markdown format.\nThe overall structure remains the same, but it’s now in Quarto-compatible Markdown syntax.",
    "crumbs": [
      "Course Info",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ressourcen</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "",
    "text": "7.1 What is Jupyter Notebook?\nA Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-jupyter-notebook",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "",
    "text": "7.1.1 Key Components of a Notebook\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n\nnew chapter\n\n7.1.1.1 Notebook Editor\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It allows users to write and run code interactively, as well as add rich text and multimedia content. When running Jupyter on a server, you’ll typically use either the classic Jupyter Notebook interface or JupyterLab, which is a more advanced and feature-rich version of the notebook editor.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n7.1.2 Kernels\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n7.1.3 Notebook Documents\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.2 Using the Notebook Editor",
    "text": "7.2 Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\n7.2.1 Edit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\n7.2.2 Command mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\n7.2.3 Keyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\n7.2.4 Running code in your notebook\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\nv = 23752636\nprint(v)\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.3 Managing the kernel",
    "text": "7.3 Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.\nEntering code is pretty easy. You just have to click into a cell and type the commands you want to type. If you have multiple lines of code, just press enter at the end of the line and start a new one.\n\ncode blocks Python identifies blocks of codes belonging together by its identation. This will become important if you write longer code in a cell later. To indent the block, you may use either whitespaces or tabs.\ncomments Comments can be added to annotate the code, such that you or someone else can understand the code.\n\nComments in a single line are started with the # character at in front of the comment.\nComments over multiple lines can be started with '''and end with the same '''. They are used as docstrings to provide a help text.\n\n\n\n# typical function\n\ndef function(x):\n    ''' function to calculate a function\n    arguments:\n        x ... float or integer value\n    returns:\n        y ... two times the integer value\n    '''\n    y=2*x # don't forget the identation of the block\n    return(y)\n\nhelp(function)\n\nHelp on function function in module __main__:\n\nfunction(x)\n    function to calculate a function\n    arguments:\n        x ... float or integer value\n    returns:\n        y ... two times the integer value",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.4 Markdown in Notebooks",
    "text": "7.4 Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://daringfireball.net/projects/markdown/\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\n7.4.1 Markdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\nHere is a blockquote:\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\nAnd Web links:\nJupyter’s website\n\n\n7.4.2 Headings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\n7.4.3 Embedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\n7.4.4 LaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\n7.4.5 Images\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\n7.4.6 Videos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.\n\nfrom IPython.display import YouTubeVideo\nYouTubeVideo('QlLx32juGzI',width=600)",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/01-lecture01.html#variables-in-python",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.5 Variables in Python",
    "text": "7.5 Variables in Python\n\n7.5.1 Symbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nThere are a number of Python keywords that cannot be used as variable names because Python uses them for other things. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\n7.5.2 Variable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#number-types",
    "href": "lectures/lecture01/01-lecture01.html#number-types",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.6 Number Types",
    "text": "7.6 Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\n7.6.1 Comparison of Number Types\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n\n\n\nExamples for Number Types\n\n\n\n\n\n\n7.6.2 Integers\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\n7.6.3 Floating Point Numbers\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\n7.6.4 Complex Numbers\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#type-conversion",
    "href": "lectures/lecture01/01-lecture01.html#type-conversion",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.7 Type Conversion",
    "text": "7.7 Type Conversion\n\n7.7.1 Implicit Type Conversion\nPython automatically converts types during operations involving mixed types. The result is a type that can accommodate all the values involved in the operation. This is known as implicit type conversion. For example, adding an integer and a float results in a float.\n\n\n\n\n\n\n\n\n7.7.2 Explicit Type Conversion\nUse functions like int(), float(), and str() to explicitly convert types from one to another. Explicit type conversion is also known as type casting. For example, converting a string to an integer.\n\n\n\n\n\n\nConverting a float to an integer truncates the decimal part.\n\n\n\n\n\n\n\n\n\n\n\n\nHandling Complex Numbers\n\n\n\nComplex numbers cannot be directly converted to floats or integers; extract the real or imaginary part first.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#application",
    "href": "lectures/lecture01/01-lecture01.html#application",
    "title": "7  Introduction to Python and Basic Calculations",
    "section": "7.8 Application",
    "text": "7.8 Application\nThe following code snippets demonstrate the use of variables and basic arithmetic operations in Python. The code snippets include examples of variable assignments, type conversion, and arithmetic operations.\n\n\n\n\n\n\n\nSimple calculations relevant to physics, such as converting units or calculating simple quantities (e.g., distance = speed × time).\n\nHomework: Basic practice problems to reinforce Python syntax and operations.",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to Python and Basic Calculations</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "8  Lecture 2",
    "section": "",
    "text": "9 Kinematics and Python",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lecture 2</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#introduction-to-functions",
    "href": "lectures/lecture02/01-lecture02.html#introduction-to-functions",
    "title": "8  Lecture 2",
    "section": "9.1 Introduction to Functions",
    "text": "9.1 Introduction to Functions\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\n9.1.1 Defining a Function\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\n9.1.2 Calling a Function\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lecture 2</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#loops",
    "href": "lectures/lecture02/01-lecture02.html#loops",
    "title": "8  Lecture 2",
    "section": "9.2 Loops",
    "text": "9.2 Loops\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\n9.2.1 For Loop\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\n9.2.2 While Loop\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lecture 2</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#conditional-statements",
    "href": "lectures/lecture02/01-lecture02.html#conditional-statements",
    "title": "8  Lecture 2",
    "section": "9.3 Conditional Statements",
    "text": "9.3 Conditional Statements\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\n9.3.1 If Statement\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\n9.3.2 Else Statement\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lecture 2</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#modules",
    "href": "lectures/lecture02/01-lecture02.html#modules",
    "title": "8  Lecture 2",
    "section": "9.4 Modules",
    "text": "9.4 Modules\nMost of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python module it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\n\n\n\n\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\n\n\n\n\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems.\n\n\n\n\n\n\nCreate Your Own Modules\n\n\n\n\n\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here’s how you can create and use your own module:\n\n9.4.0.1 Creating a Module\nTo create a module, you just need to save your Python code in a file with a .py extension. For example, let’s create a module named mymodule.py with the following content:\n# mymodule.py\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\n9.4.0.2 Using Your Module\nOnce you have created your module, you can import it into other Python scripts using the import statement. Here’s an example of how to use the mymodule we just created:\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n\n\n9.4.1 Importing Specific Functions\nYou can also import specific functions from a module using the from ... import ... syntax:\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n\n\n9.4.2 Module Search Path\nWhen you import a module, Python searches for the module in the following locations: 1. The directory containing the input script (or the current directory if no script is specified). 2. The directories listed in the PYTHONPATH environment variable. 3. The default directory where Python is installed.\nYou can view the module search path by printing the sys.path variable:\nimport sys\nprint(sys.path)\n\n\n9.4.3 Creating Packages\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named __init__.py, which can be empty. Here’s an example of how to create a package:\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\nYou can then import modules from the package using the dot notation:\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n\n\n\n\n9.4.4 Namespaces\n\n\n\n\n\n\nNamespaces\n\n\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the import math as mymath pattern.\n\n\n\n\n\n\n\n\nYou may also only import specific functions of a module.\n\n\n\n\n\n\n\n\n9.4.5 Contents of a module\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\n\n\n\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n\n\n\n\n\nNamespaces in Your Modules\n\n\n\n\n\n9.4.6 Namespaces in Packages\nYou can also create sub-packages by adding more directories with __init__.py files. This allows you to create a hierarchical structure for your modules:\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\nYou can then import submodules using the full package name:\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())\n\n\n\nPython Application",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lecture 2</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#function-plotting",
    "href": "lectures/lecture02/01-lecture02.html#function-plotting",
    "title": "8  Lecture 2",
    "section": "9.5 Function Plotting",
    "text": "9.5 Function Plotting\n\nWriting a Python function to calculate and plot the position vs. time for an object moving with constant velocity or constant acceleration.\nVisualization: Use matplotlib to plot simple kinematic graphs (position vs. time, velocity vs. time).\nHomework: Extend the kinematic function to handle different initial conditions and plot the results.\n\n\n\n\n    \n    \n    Ball Throw Simulation",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lecture 2</span>"
    ]
  },
  {
    "objectID": "lectures/lecture12/01-lecture12.html",
    "href": "lectures/lecture12/01-lecture12.html",
    "title": "9  Lecture 12",
    "section": "",
    "text": "9.1 Advanced Waves and Final Project Introduction",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Lecture 12</span>"
    ]
  },
  {
    "objectID": "lectures/lecture12/01-lecture12.html#advanced-waves-and-final-project-introduction",
    "href": "lectures/lecture12/01-lecture12.html#advanced-waves-and-final-project-introduction",
    "title": "9  Lecture 12",
    "section": "",
    "text": "9.1.1 Python Concepts\n\nIntroduction to more advanced simulation techniques (e.g., finite difference methods).\nStructuring a Python project (modules, documentation, testing).\n\n\n\n9.1.2 Application\n\nSimulating wave propagation, reflection, and transmission in different media.\nVisualization: Animating wave motion and energy transfer.\n\n\n9.1.2.1 Final Project Overview\n- Introduction to the final project, where students choose a physics problem to model and solve using Python.\n- Discussion of project expectations, timelines, and resources.\n- Homework: Start working on the final project by selecting a topic and outlining the approach.\n\n\n\n## Ideal Gas Simulation with Pressure, Gravity, and Collisions\n\nUse the sliders below to adjust the speed of the gas particles and the gravitational force acting on them. The pressure exerted by the particles on the container walls will be displayed.\n\n  Adjust Particle Speed:\n  \n\n\n  Adjust Gravity:\n  \n\nPressure: 0 Pa",
    "crumbs": [
      "Lecture Contents",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Lecture 12</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "lectures/lecture06/01-lecture06.html#collisions-and-conservation-laws",
    "href": "lectures/lecture06/01-lecture06.html#collisions-and-conservation-laws",
    "title": "1 Lecture 6",
    "section": "1.1 Collisions and Conservation Laws",
    "text": "1.1 Collisions and Conservation Laws\n\n1.1.1 Python Concepts\n\nAdvanced conditionals and loops for simulating complex scenarios.\nIntroduction to basic data structures (dictionaries) for handling multiple objects.\n\n\n\n1.1.2 Application\n\nSimulating elastic and inelastic collisions in one and two dimensions.\nApplying conservation laws (momentum and energy) to check the validity of the simulation.\nVisualization: Plotting the trajectories and velocities of colliding objects.\nHomework: Simulate a multi-object collision scenario."
  },
  {
    "objectID": "lectures/lecture09/01-lecture09.html#deformation-of-solids",
    "href": "lectures/lecture09/01-lecture09.html#deformation-of-solids",
    "title": "1 Lecture 9",
    "section": "1.1 Deformation of Solids",
    "text": "1.1 Deformation of Solids\n\n1.1.1 Python Concepts\n\nBasic file handling for reading and writing data (e.g., stress-strain data).\nCurve fitting using numpy or scipy to analyze experimental data.\n\n\n\n1.1.2 Application\n\nSimulating the deformation of a solid under load (e.g., Hooke’s law for springs).\nPlotting stress-strain curves and fitting them to experimental data.\nHomework: Extend the simulation to include plastic deformation or fracture."
  },
  {
    "objectID": "lectures/lecture10/01-lecture10.html#fluid-dynamics-and-surface-tension",
    "href": "lectures/lecture10/01-lecture10.html#fluid-dynamics-and-surface-tension",
    "title": "1 Lecture 10",
    "section": "1.1 Fluid Dynamics and Surface Tension",
    "text": "1.1 Fluid Dynamics and Surface Tension\n\n1.1.1 Python Concepts\n\nIntroduction to flow simulation and basic fluid mechanics principles (continuity equation, Bernoulli’s equation).\nUsing matplotlib for more advanced visualizations (e.g., vector fields).\n\n\n\n1.1.2 Application\n\nSimulating fluid flow in simple scenarios (e.g., flow through a pipe, around an object).\nVisualizing pressure and velocity fields.\nHomework: Simulate and visualize a more complex fluid system, such as flow over a wing."
  },
  {
    "objectID": "lectures/lecture05/01-lecture05.html#angular-momentum-and-rotational-motion",
    "href": "lectures/lecture05/01-lecture05.html#angular-momentum-and-rotational-motion",
    "title": "1 Lecture 5",
    "section": "1.1 Angular Momentum and Rotational Motion",
    "text": "1.1 Angular Momentum and Rotational Motion\n\n1.1.1 Python Concepts\n\nIntroduction to classes in Python (optional, for organizing code).\nRotational kinematics and dynamics (moment of inertia, angular momentum).\n\n\n\n1.1.2 Application\n\nSimulating the motion of a rotating object (e.g., a spinning disk) and calculating its angular momentum.\nVisualizing the effect of torque on the object’s rotation.\nHomework: Extend the simulation to include the effect of external forces, such as friction."
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#creating-numpy-arrays",
    "href": "lectures/lecture03/01-lecture03.html#creating-numpy-arrays",
    "title": "Lecture 3",
    "section": "1.1 Creating Numpy Arrays",
    "text": "1.1 Creating Numpy Arrays\nThere are a number of ways to initialize new numpy arrays, for example from\n\na Python list or tuples using np.array\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section of this course.\n\n\n1.1.1 From lists\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function. This is demonstrated in the following cells:\n\n  #this is a list\n  a = [0, 0, 1, 4, 7, 16, 31, 64, 127]\n\n  type(a)\n\nlist\n\n\n\n  b=np.array(a,dtype=float)\n  type(b)\n\nnumpy.ndarray\n\n\n\n\n1.1.2 Using array-generating functions\nFor larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms and shapes. Some of the more common are:\n\n  #| slideshow: {slide_type: fragment}\n  # create a range\n\n  x = np.arange(0, 10, 1) # arguments: start, stop, step\n  x\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  x = np.arange(-5, -2, 0.1)\n  x\n\narray([-5. , -4.9, -4.8, -4.7, -4.6, -4.5, -4.4, -4.3, -4.2, -4.1, -4. ,\n       -3.9, -3.8, -3.7, -3.6, -3.5, -3.4, -3.3, -3.2, -3.1, -3. , -2.9,\n       -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1])\n\n\n\n\n\n\n\n\nlinspace\n\n\n\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50. The function linspace always includes the end points.\n\n\n\n  #| slideshow: {slide_type: fragment}\n  # using linspace, both end points ARE included\n  np.linspace(0,10,25)\n\narray([ 0.        ,  0.41666667,  0.83333333,  1.25      ,  1.66666667,\n        2.08333333,  2.5       ,  2.91666667,  3.33333333,  3.75      ,\n        4.16666667,  4.58333333,  5.        ,  5.41666667,  5.83333333,\n        6.25      ,  6.66666667,  7.08333333,  7.5       ,  7.91666667,\n        8.33333333,  8.75      ,  9.16666667,  9.58333333, 10.        ])\n\n\n\n\n\n\n\n\nlogspace\n\n\n\nlogspace is doing equivelent things with logaritmic spacing. The function logspace generates an array of N points between decades 10^start and 10^stop. The form of the function is logspace(start, stop, N). If the third argument N is omitted, then N=50. The function logspace always includes the end points.\n\n\n\n  #| slideshow: {slide_type: fragment}\n  np.logspace(0, 10, 10, base=np.e)\n\narray([1.00000000e+00, 3.03773178e+00, 9.22781435e+00, 2.80316249e+01,\n       8.51525577e+01, 2.58670631e+02, 7.85771994e+02, 2.38696456e+03,\n       7.25095809e+03, 2.20264658e+04])\n\n\nOther types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\nmgrid\n\n\n\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows. The arguments are similar to arange and linspace.\n\n\n\nx, y = np.mgrid[0:1:0.1, 0:5] # similar to meshgrid in MATLAB\n\n\nx\n\narray([[0. , 0. , 0. , 0. , 0. ],\n       [0.1, 0.1, 0.1, 0.1, 0.1],\n       [0.2, 0.2, 0.2, 0.2, 0.2],\n       [0.3, 0.3, 0.3, 0.3, 0.3],\n       [0.4, 0.4, 0.4, 0.4, 0.4],\n       [0.5, 0.5, 0.5, 0.5, 0.5],\n       [0.6, 0.6, 0.6, 0.6, 0.6],\n       [0.7, 0.7, 0.7, 0.7, 0.7],\n       [0.8, 0.8, 0.8, 0.8, 0.8],\n       [0.9, 0.9, 0.9, 0.9, 0.9]])\n\n\n\ny\n\narray([[0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.]])\n\n\n\nnp.array([[1,2,3],[4,5,6],[7,8,9]])\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\n\n\n\n\n\n\ndiag\n\n\n\ndiag generates a diagonal matrix with the list supplied to it as the diagonal values. The values can be also offset from the main diagonal by using the optional argument k. If k is positive, the diagonal is above the main diagonal, if negative, below the main diagonal.\n\n\n\n# a diagonal matrix\nnp.diag([1,2,3])\n\narray([[1, 0, 0],\n       [0, 2, 0],\n       [0, 0, 3]])\n\n\n\n## diagonal with offset from the main diagonal\nnp.diag([1,2,3], k=-1)\n\narray([[0, 0, 0, 0],\n       [1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0]])\n\n\n\n\n\n\n\n\nzeros and ones\n\n\n\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1. The argument is a tuple with the dimensions of the matrix. For example, np.zeros((3,3)) creates a 3x3 matrix filled with zeros.\n\n\n\nnp.zeros((3,3))\n\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones((3,3))\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#manipulating-numpy-arrays",
    "href": "lectures/lecture03/01-lecture03.html#manipulating-numpy-arrays",
    "title": "Lecture 3",
    "section": "1.2 Manipulating NumPy arrays",
    "text": "1.2 Manipulating NumPy arrays\n\n1.2.1 Slicing\nSlicing is the name for extracting part of an array by the syntax M[lower:upper:step]. When any of these are unspecified, they default to the values lower=0, upper=size of dimension, step=1. We can also use negative indices to count from the end of the array. Here are some examples:\n\nA = np.array([1,2,3,4,5])\nA\n\narray([1, 2, 3, 4, 5])\n\n\n\nA[1:4]\n\narray([2, 3, 4])\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\nA[::] # lower, upper, step all take the default values\n\narray([1, 2, 3, 4, 5])\n\n\n\nA[::2] # step is 2, lower and upper defaults to the beginning and end of the array\n\narray([1, 3, 5])\n\n\nNegative indices counts from the end of the array (positive index from the begining) and can be used in any of the three slicing parameters. Here are some examples:\n\nA = np.array([1,2,3,4,5])\n\n\nA[-1] # the last element in the array\n\nnp.int64(5)\n\n\n\nA[2:] # the last three elements\n\narray([3, 4, 5])\n\n\nIndex slicing works exactly the same way for multidimensional arrays. We can slice along each axis independently. Here are some examples:\n\nA = np.array([[n+m*10 for n in range(5)] for m in range(5)])\nA\n\narray([[ 0,  1,  2,  3,  4],\n       [10, 11, 12, 13, 14],\n       [20, 21, 22, 23, 24],\n       [30, 31, 32, 33, 34],\n       [40, 41, 42, 43, 44]])\n\n\n\n# a block from the original array\nA[1:3, 1:4]\n\narray([[11, 12, 13],\n       [21, 22, 23]])\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by the formula\n\\[\\begin{equation}\n  v_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n  \\end{equation}\\]\n\n\n\ny = np.array([ 0. , 1.3, 5. , 10.9, 18.9, 28.7, 40. ])\nt = np.array([ 0. , 0.49, 1. , 1.5 , 2.08, 2.55, 3.2 ])\n\n\nv = (y[1:]-y[:-1])/(t[1:]-t[:-1])\nv\n\narray([ 2.65306122,  7.25490196, 11.8       , 13.79310345, 20.85106383,\n       17.38461538])\n\n\n\n\n1.2.2 Reshaping\nArrays can be reshaped into any form, which contains the same number of elements. For example, a 4-element array can be reshaped into a 2x2 array, or a 2x2 array can be reshaped into a 4-element array. Here are some examples:\n\na=np.zeros(4)\na\n\narray([0., 0., 0., 0.])\n\n\n\nnp.reshape(a,(2,2))\n\narray([[0., 0.],\n       [0., 0.]])\n\n\n\n\n1.2.3 Adding a new dimension: newaxis\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix. Here are some examples:\n\n  #| slideshow: {slide_type: fragment}\n  v = np.array([1,2,3])\n  v\n\narray([1, 2, 3])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  v.shape\n\n(3,)\n\n\n\n  #| slideshow: {slide_type: fragment}\n  # make a column matrix of the vector v\n  v[:, np.newaxis]\n\narray([[1],\n       [2],\n       [3]])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  # column matrix\n  v[:,np.newaxis].shape\n\n(3, 1)\n\n\n\n  #| slideshow: {slide_type: fragment}\n  # row matrix\n  v[np.newaxis,:].shape\n\n(1, 3)\n\n\n\n\n1.2.4 Stacking and repeating arrays\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones by repeating or stacking. Please try the individual functions yourself in your notebook. We wont discuss them in detail here.\n\n1.2.4.1 Tile and repeat\n\n  #| slideshow: {slide_type: skip}\n  a = np.array([[1, 2], [3, 4]])\n  a\n\narray([[1, 2],\n       [3, 4]])\n\n\n\n  #| slideshow: {slide_type: skip}\n  # repeat each element 3 times\n  np.repeat(a, 3)\n\narray([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4])\n\n\n\n  #| slideshow: {slide_type: skip}\n  # tile the matrix 3 times\n  np.tile(a, 3)\n\narray([[1, 2, 1, 2, 1, 2],\n       [3, 4, 3, 4, 3, 4]])\n\n\n\n\n1.2.4.2 Concatenate\nConcatenate joins arrays along an existing axis. Here are some examples:\n\n  #| slideshow: {slide_type: skip}\n  a = np.array([[1, 2], [3, 4]])\n  a\n\narray([[1, 2],\n       [3, 4]])\n\n\n\n  #| slideshow: {slide_type: skip}\n  b = np.array([[5, 6]])\n\n\n  #| slideshow: {slide_type: skip}\n  np.concatenate((a, b), axis=0)\n\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\n\n  #| slideshow: {slide_type: skip}\n  np.concatenate((a, b.T), axis=1)\n\narray([[1, 2, 5],\n       [3, 4, 6]])\n\n\n\n\n1.2.4.3 Hstack and vstack\nhstack and vstack stack arrays horizontally and vertically. Here are some examples:\n\n  #| slideshow: {slide_type: skip}\n  a = np.array([1, 2, 3])\n  b = np.array([2, 3, 4])\n\n\n  #| slideshow: {slide_type: skip}\n  np.vstack((a,b))\n\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n\n  #| slideshow: {slide_type: skip}\n  np.hstack((a,b.T))\n\narray([1, 2, 3, 2, 3, 4])"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#applying-mathematical-functions",
    "href": "lectures/lecture03/01-lecture03.html#applying-mathematical-functions",
    "title": "Lecture 3",
    "section": "1.3 Applying mathematical functions",
    "text": "1.3 Applying mathematical functions\nAll kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below where a is an array of numbers from 0 to 9.\n\n1.3.1 Operation involving one array\n\n  #| slideshow: {slide_type: fragment}\n  a=np.arange(0, 10, 1.5)\n  a\n\narray([0. , 1.5, 3. , 4.5, 6. , 7.5, 9. ])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  a/2\n\narray([0.  , 0.75, 1.5 , 2.25, 3.  , 3.75, 4.5 ])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  a**2\n\narray([ 0.  ,  2.25,  9.  , 20.25, 36.  , 56.25, 81.  ])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  np.sin(a)\n\narray([ 0.        ,  0.99749499,  0.14112001, -0.97753012, -0.2794155 ,\n        0.93799998,  0.41211849])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  np.exp(-a)\n\narray([1.00000000e+00, 2.23130160e-01, 4.97870684e-02, 1.11089965e-02,\n       2.47875218e-03, 5.53084370e-04, 1.23409804e-04])\n\n\n\n  #| slideshow: {slide_type: fragment}\n  (a+2)/3\n\narray([0.66666667, 1.16666667, 1.66666667, 2.16666667, 2.66666667,\n       3.16666667, 3.66666667])\n\n\n\n\n1.3.2 Operations involving multiple arrays\nOperation between multiple vectors allow in particular very quick operations. The operations address then elements of the same index. These operations are called vector operations since the concern the whole array at the same time. The product between two vectors results therefore not in a dot product, which gives one number but in an array of multiplied elements.\n\n  #| ExecuteTime: {end_time: '2017-04-20T21:16:34.978152+02:00', start_time: '2017-04-20T21:16:34.973278'}\n  #| slideshow: {slide_type: fragment}\n  a = np.array([34., -12, 5.,1.2])\n  b = np.array([68., 5.0, 20.,40.])\n\n\n  #| ExecuteTime: {end_time: '2017-04-20T21:16:41.810170+02:00', start_time: '2017-04-20T21:16:41.804038'}\n  #| slideshow: {slide_type: fragment}\n  a + b\n\narray([102. ,  -7. ,  25. ,  41.2])\n\n\n\n  #| ExecuteTime: {end_time: '2017-04-20T21:16:48.002366+02:00', start_time: '2017-04-20T21:16:47.996136'}\n  #| slideshow: {slide_type: fragment}\n  #| tags: []\n  2*b\n\narray([136.,  10.,  40.,  80.])\n\n\nxxw\n\n  #| ExecuteTime: {end_time: '2017-04-20T21:20:19.373091+02:00', start_time: '2017-04-20T21:20:19.367493'}\n  #| slideshow: {slide_type: fragment}\n  a*np.exp(-b)\n\narray([ 9.98743918e-29, -8.08553640e-02,  1.03057681e-08,  5.09802511e-18])\n\n\n\n  #| tags: []\n  v1=np.array([1,2,3])\n  v2=np.array([4,2,3])"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#application",
    "href": "lectures/lecture03/01-lecture03.html#application",
    "title": "Lecture 3",
    "section": "1.4 Application",
    "text": "1.4 Application\n\nSimulating and plotting the trajectory of a projectile under the influence of gravity (2D motion).\nIntroduction to vector addition and resolving vectors into components.\nVisualization: Plotting the path of the projectile and velocity vectors.\nHomework: Simulate projectile motion with air resistance (optional for advanced students)."
  },
  {
    "objectID": "tt.html#what-is-jupyter-notebook",
    "href": "tt.html#what-is-jupyter-notebook",
    "title": "Introduction to Python and Basic Calculations",
    "section": "1 What is Jupyter Notebook?",
    "text": "1 What is Jupyter Notebook?\nA Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and imas,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org."
  },
  {
    "objectID": "tt.html#key-components-of-a-notebook",
    "href": "tt.html#key-components-of-a-notebook",
    "title": "Introduction to Python and Basic Calculations",
    "section": "2 Key Components of a Notebook",
    "text": "2 Key Components of a Notebook\nThe Jupyter Notebook combines three components:\n\n\n\n\n\n\nNotebook editor\n\n\n\nThe Notebook editor is an interactive application for writing and running code interactively and editing notebook documents. If you run Jupyter on a server, you will be using Jupyter’s web application or JupyterLab, which is a more advanced version of the notebook editor.\n\n\nThe Notebook editor enables you to\n\nEdit code in individual cell\nRun code in individuall cells in arbitrary oder and display results of the computation in various formats (HTML, LaTeX, PNG, SVG, PDF)\nCreate and use interactive JavaScript widgets, which bind interactive user interface controls and visualizations to reactive kernel side computations.\nAdd documentation text using Markdown markup language, including LaTeX equations\n\n\n\n\n\n\n\nKernels\n\n\n\nKernels are separate processes started by Jupyter on your server, that runs users’ code in a given language and returns output back to the notebook web application. The kernel also handles things like computations for interactive widgets, tab completion and introspection.\n\n\nThe Jupyter notebook is not bound to any specific programming language, but can be used for almost any type of language. Each Jupyter notebook starts a server application that is connected to a kernel that runs the code in the notebook. This kernel is dedicated to a specific programming language. Thus installing different kernels 100+ languages allows you to execute code in Python, Julia, R, Ruby, Haskell, Scala, and many others.\nYet, the default kernel runs Python code. The notebook provides a simple way for users to pick which of these kernels is used for a given notebook. Each of these kernels communicate with the notebook editor using JSON over ZeroMQ/WebSockets message protocol that is described here. Most users don’t need to know about these details, but it helps to understand that “kernels run code”.\n\n\n\n\n\n\nNotebook documents\n\n\n\nSelf-contained documents that contain a representation of all content visible in the notebook editor, including inputs and outputs of the computations, markdown text, equations, images, and rich media representations of objects. Each notebook document has its own kernel.\n\n\nNotebook documents, or notebooks, contain the inputs and outputs of an interactive session as well as documentation text that accompanies the code but is not meant for execution.\nA notebook is just a file on your server’s filesystem with a .ipynb extension. This allows you to share your notebook easily.\nNotebooks consist of a linear sequence of cells. There are three basic cell types:\n\nCode cells: Input and output of live code that is run in the kernel.\nMarkdown cells: Narrative text with embedded LaTeX equations.\nRaw cells: Unformatted text that is included, without modification, when notebooks are converted to different formats using nbconvert.\n\nInternally, notebook documents are JSON text files with binary data encoded in base64. This allows them to be read and manipulated programmatically by any programming language.\nNotebooks can be exported to different static formats including HTML, reStructeredText, LaTeX, PDF, and slide shows (reveal.js) using Jupyter’s nbconvert utility.\nFurthermore, any notebook document available from a public URL on or GitHub can be shared via nbviewer. This service loads the notebook document from the URL and renders it as a static web page. The resulting web page may thus be shared with others without their needing to install the Jupyter Notebook."
  },
  {
    "objectID": "tt.html#using-the-notebook-editor",
    "href": "tt.html#using-the-notebook-editor",
    "title": "Introduction to Python and Basic Calculations",
    "section": "3 Using the Notebook Editor",
    "text": "3 Using the Notebook Editor\nA Jupyter Notebook provides an interface with essentially two modes\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab, which we are using on myBinder, this will look like that\n\n3.1 Edit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area:\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor.\n\n\n3.2 Command mode\nCommand mode is indicated by a grey cell border:\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\n3.3 Keyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor. Thus, in edit mode there are relatively few shortcuts. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\n3.4 Running code in your notebook\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\nv = 23752636\nprint(v)\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below."
  },
  {
    "objectID": "tt.html#managing-the-kernel",
    "href": "tt.html#managing-the-kernel",
    "title": "Introduction to Python and Basic Calculations",
    "section": "4 Managing the kernel",
    "text": "4 Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.\nEntering code is pretty easy. You just have to click into a cell and type the commands you want to type. If you have multiple lines of code, just press enter at the end of the line and start a new one.\n\ncode blocks Python identifies blocks of codes belonging together by its identation. This will become important if you write longer code in a cell later. To indent the block, you may use either whitespaces or tabs.\ncomments Comments can be added to annotate the code, such that you or someone else can understand the code.\n\nComments in a single line are started with the # character at in front of the comment.\nComments over multiple lines can be started with '''and end with the same '''. They are used as docstrings to provide a help text.\n\n\n\n# typical function\n\ndef function(x):\n    ''' function to calculate a function\n    arguments:\n        x ... float or integer value\n    returns:\n        y ... two times the integer value\n    '''\n    y=2*x # don't forget the identation of the block\n    return(y)\n\nhelp(function)"
  },
  {
    "objectID": "tt.html#entering-markdown",
    "href": "tt.html#entering-markdown",
    "title": "Introduction to Python and Basic Calculations",
    "section": "5 Entering Markdown",
    "text": "5 Entering Markdown\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://daringfireball.net/projects/markdown/\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\n5.1 Markdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold.\nYou can build nested itemized or enumerated lists:\n\nfirst item\n\nfirst subitem\n\nfirst subsubitem\n\nsecond subitem - first subitem of second subitem - second subitem of second subitem\n\nsecond item\n\nfirst subitem\n\nthird item\n\nfirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\nHere is a blockquote:\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one– and preferably only one –obvious way to do it. Although that way may not be obvious at first unless you’re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea – let’s do more of those!\n\nAnd shorthand for links:\nJupyter’s website\n\n\n5.2 Headings\nYou can add headings by starting a line with one (or multiple) # followed by a space, as in the following example:\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\n5.3 Embedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\nor other languages:\nif (i=0; i&lt;n; i++) {\n  printf(\"hello %d\\n\", i);\n  x += 4;\n}\n\n\n5.4 LaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\n5.5 Images\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\nfrom IPython.display import Image, display;\nimport ssl\nfrom urllib.request import urlopen\n\n# URL of the image\nurl = \"https://github.com/fcichos/CompSoft23/raw/master/source/notebooks/Intro/img/particle.png\"\n\n# Create an SSL context that does not verify certificates\nssl._create_default_https_context = ssl._create_unverified_context\n\n# Open the URL and display the image\nwith urlopen(url) as response:\n    display(Image(response.read()))\n\n\ndisplay(Image(filename='img/particle.png'))\n\n\n\n5.6 Videos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.\n\nfrom IPython.display import YouTubeVideo\nYouTubeVideo('QlLx32juGzI',width=600)\n\n\n\n5.7 Python Basics\n\nVariables and data types (integers, floats, strings).\nBasic arithmetic operations (+, -, *, /, **)."
  },
  {
    "objectID": "tt.html#introduction-to-variables",
    "href": "tt.html#introduction-to-variables",
    "title": "Introduction to Python and Basic Calculations",
    "section": "6 Introduction to Variables",
    "text": "6 Introduction to Variables\n\n6.1 Symbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter.\nBy convention, variable names typically start with a lower-case letter, while Class names start with a capital letter.\n\n\n\n\n\n\nWarning\n\n\n\nNote: Reserved Keywords\nThere are a number of Python keywords that cannot be used as variable names. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\n6.2 Variable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n# variable assignments\nx = 1.0\nmy_favorite_variable = 12.2\nx\n\n1.0\n\n\nAlthough not explicitly specified, a variable does have a type associated with it. The type is derived from the value that was assigned to it.\n\ntype(x)\n\nfloat\n\n\nIf we assign a new value to a variable, its type can change.\n\nx = 1\n\n\ntype(x)\n\nint\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError:\n\n#print(g)"
  },
  {
    "objectID": "tt.html#number-types",
    "href": "tt.html#number-types",
    "title": "Introduction to Python and Basic Calculations",
    "section": "7 Number Types",
    "text": "7 Number Types\n\n7.1 Overview of Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers.\n\n\n7.2 Integers\n\nInteger Representation: Numbers without a decimal point are treated as integers.\n\n\nx = 1\ntype(x)\n\nint\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n0b1010111110  # Binary\n0x0F          # Hexadecimal\n\n15\n\n\n\n\n7.3 Floating Point Numbers\n\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\nx = 3.141\ntype(x)\n\nfloat\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n1.7976931348623157e+308 * 2  # Output: inf\n\ninf\n\n\n\n\n7.4 Complex Numbers\n\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\nc = 2 + 4j\ntype(c)\n\ncomplex\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\nprint(c.real)\nprint(c.imag)\n\n2.0\n4.0\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.\n\n\nc = c.conjugate()\nprint(c)\n\n(2-4j)"
  },
  {
    "objectID": "tt.html#type-conversion",
    "href": "tt.html#type-conversion",
    "title": "Introduction to Python and Basic Calculations",
    "section": "8 Type Conversion",
    "text": "8 Type Conversion\n\n8.1 Implicit Type Conversion\n\nAutomatic Conversion: Python automatically converts types during operations.\n\n\ninteger_number = 123\nfloat_number = 1.23\nnew_number = integer_number + float_number\ntype(new_number)\n\n\n\n8.2 Explicit Type Conversion\n\nManual Conversion: Use functions like int(), float(), and str() to explicitly convert types.\n\n\nnum_string = \"12\"\nnum_string = int(num_string)\ntype(num_string)\n\n\nConverting Between Types:\n\n\nx = 5 / 2\nx = int(x)\nz = complex(x)\n\n\nHandling Complex Numbers:\n\nComplex numbers cannot be directly converted to floats or integers; extract the real or imaginary part first.\n\n\n\ny = bool(z.real)\nprint(z.real, \" -&gt; \", y, type(y))\n\n\n\n8.3 Application\n\n# 1. Converting Units of Distance\n# Distance in kilometers\ndistance_km = 5.0\n\n# Conversion factor from kilometers to meters\nconversion_factor = 1000\n\n# Convert distance to meters\ndistance_meters = distance_km * conversion_factor\n\n# 2. Calculating Time from Distance and Speed\n# Given distance in meters\ndistance = 1000.0  # meters\n\n# Given speed in meters per second\nspeed = 5.0  # meters per second\n\n# Calculate time in seconds\ntime = distance / speed\n\n# 3. Energy Calculation Using Kinetic Energy Formula\n# Mass in kilograms\nmass = 70.0  # kg\n\n# Velocity in meters per second\nvelocity = 10.0  # m/s\n\n# Calculate kinetic energy\nkinetic_energy = 0.5 * mass * velocity ** 2\n\n# 4. Temperature Conversion (Celsius to Fahrenheit)\n# Temperature in Celsius\ntemp_celsius = 25.0  # degrees Celsius\n\n# Convert to Fahrenheit\ntemp_fahrenheit = (temp_celsius * 9/5) + 32\n\n# 5. Power Calculation Using Work and Time\n# Work done in joules\nwork_done = 500.0  # joules\n\n# Time taken in seconds\ntime_taken = 20.0  # seconds\n\n# Calculate power\npower_output = work_done / time_taken\n\n# 6. Calculating Force Using Newton's Second Law\n# Mass in kilograms\nmass = 10.0  # kg\n\n# Acceleration in meters per second squared\nacceleration = 9.8  # m/s^2\n\n# Calculate force\nforce = mass * acceleration\n\n# Output Results\nprint(f\"Distance in meters: {distance_meters} m\")\nprint(f\"Time to travel {distance} meters at {speed} m/s: {time} seconds\")\nprint(f\"Kinetic energy: {kinetic_energy} joules\")\nprint(f\"Temperature in Fahrenheit: {temp_fahrenheit} °F\")\nprint(f\"Power output: {power_output} watts\")\nprint(f\"Force: {force} newtons\")\n\n\nSimple calculations relevant to physics, such as converting units or calculating simple quantities (e.g., distance = speed × time).\n\nHomework: Basic practice problems to reinforce Python syntax and operations."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "1 Summary",
    "section": "",
    "text": "1 Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#work-power-energy",
    "href": "lectures/lecture04/01-lecture04.html#work-power-energy",
    "title": "1 Lecture 4",
    "section": "1.1 Work, Power, Energy",
    "text": "1.1 Work, Power, Energy\n\n1.1.1 Python Concepts\n\nIntroduction to loops for numerical integration (e.g., trapezoidal rule).\nFunctions for calculating work, power, and energy.\n\n\n\n1.1.2 Application\n\nWriting Python code to calculate the work done by a variable force (e.g., spring force) using numerical integration.\nSimulating energy conservation in a closed system (e.g., pendulum).\nVisualization: Plotting energy vs. time for the system.\nHomework: Modify the code to simulate a different system, such as a mass-spring system.\n\n\n\n\n    \n    \n    D3.js Shaded Spheres"
  },
  {
    "objectID": "lectures/lecture02/4_modules.html",
    "href": "lectures/lecture02/4_modules.html",
    "title": "Modules",
    "section": "",
    "text": "Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python program it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\nimport math\nimport numpy\n\nx = math.sqrt(2 * math.pi)\nx = numpy.sqrt(2 * numpy.pi)\n\nprint(x)\n\n2.5066282746310002\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\nfrom math import *\n\nx = cos(2 * pi)\n\nprint(x)\n\n1.0\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems."
  },
  {
    "objectID": "lectures/lecture02/4_modules.html#namespaces",
    "href": "lectures/lecture02/4_modules.html#namespaces",
    "title": "Modules",
    "section": "1 Namespaces",
    "text": "1 Namespaces\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module.\n\nimport math as m\n\nx = m.sqrt(2)\n\nprint(x)\n\n1.4142135623730951\n\n\nYou may also only import specific functions of a module.\n\nfrom math import sinh as mysinh"
  },
  {
    "objectID": "lectures/lecture02/4_modules.html#contents-of-a-module",
    "href": "lectures/lecture02/4_modules.html#contents-of-a-module",
    "title": "Modules",
    "section": "2 Contents of a module",
    "text": "2 Contents of a module\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\nimport math\n\nprint(dir(math))\n\n['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'sumprod', 'tan', 'tanh', 'tau', 'trunc', 'ulp']\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\nhelp(math.log)\n\nHelp on built-in function log in module math:\n\nlog(...)\n    log(x, [base=math.e])\n    Return the logarithm of x to the given base.\n\n    If the base is not specified, returns the natural logarithm (base e) of x.\n\n\n\n\nmath.log(10)\n\n2.302585092994046\n\n\n\nmath.log(8, 2)\n\n3.0\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ ."
  },
  {
    "objectID": "lectures/lecture11/01-lecture11.html#oscillations-and-waves",
    "href": "lectures/lecture11/01-lecture11.html#oscillations-and-waves",
    "title": "1 Lecture 11",
    "section": "1.1 Oscillations and Waves",
    "text": "1.1 Oscillations and Waves\n\n1.1.1 Python Concepts\n\nSolving coupled differential equations for oscillatory systems (e.g., damped harmonic oscillators).\nUsing Fourier analysis to study waveforms.\n\n\n\n1.1.2 Application\n\nSimulating simple harmonic motion and damped oscillations.\nVisualizing the motion and analyzing the frequency components of the oscillation.\nHomework: Extend the simulation to include coupled oscillators or waves on a string."
  },
  {
    "objectID": "lectures/lecture07/01-lecture07.html#gravitation-and-orbital-mechanics",
    "href": "lectures/lecture07/01-lecture07.html#gravitation-and-orbital-mechanics",
    "title": "1 Lecture 7",
    "section": "1.1 Gravitation and Orbital Mechanics",
    "text": "1.1 Gravitation and Orbital Mechanics\n\n1.1.1 Python Concepts\n\nSolving differential equations using Python (Euler’s method for numerical integration).\nUsing scipy for more advanced numerical methods.\n\n\n\n1.1.2 Application\n\nSimulating gravitational forces and orbital motion (e.g., a planet orbiting a star).\nVisualizing the orbit and calculating parameters like orbital period and eccentricity.\nHomework: Modify the simulation to include multiple bodies (e.g., a three-body problem)."
  },
  {
    "objectID": "lectures/lecture08/01-lecture08.html#rigid-bodies-and-torque",
    "href": "lectures/lecture08/01-lecture08.html#rigid-bodies-and-torque",
    "title": "1 Lecture 8",
    "section": "1.1 Rigid Bodies and Torque",
    "text": "1.1 Rigid Bodies and Torque\n\n1.1.1 Python Concepts\n\nIntroduction to 2D arrays and matrix operations in numpy.\nUsing matrix methods to solve systems of equations related to rigid body dynamics.\n\n\n\n1.1.2 Application\n\nSimulating the motion of a rigid body under the influence of forces and torques.\nVisualizing the rotation and translation of the body.\nHomework: Simulate a rigid body with varying moments of inertia (e.g., a non-uniform object)."
  }
]