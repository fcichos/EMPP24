{
  "hash": "0b8f97ecd7962aa4428cfe46c8d631cb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Modules\n---\n\n\n\n::: {.callout-note  title=\"Modules\"}\nModules are Python files that consist of Python code. This code can either be functions, classes or variables. A Python module is a `.py` file containing Python code. A package is a collection of Python modules: while a module is a single Python file, a package is a directory of Python modules containing an additional `__init__.py` file, to distinguish a package from a directory that just happens to contain a bunch of Python scripts.\n:::\n\n\n\nMost of the functionality in Python is provided by *modules*. The Python Standard Library is a large collection of modules that provides *cross-platform* implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\n\nTo use a module in a Python program it first has to be imported. A module can be imported using the `import` statement. For example, to import the module `math`, which contains many standard mathematical functions, we can do:\n\n\n::: {#ae0722e9 .cell tags='[]' execution_count=1}\n``` {.python .cell-code}\nimport math\nimport numpy\n\nx = math.sqrt(2 * math.pi)\nx = numpy.sqrt(2 * numpy.pi)\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5066282746310002\n```\n:::\n:::\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don't need to use the prefix \"`math.`\" every time we use something from the `math` module:\n\n::: {#d3d7b0ca .cell tags='[]' execution_count=2}\n``` {.python .cell-code}\nfrom math import *\n\nx = cos(2 * pi)\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.0\n```\n:::\n:::\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the `import math` pattern. This would eliminate potentially confusing problems.\n\n## Namespaces\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix `math.` we have used in the previous section is such a namespace. You may also create your own namespace for a module.\n\n::: {#76277564 .cell tags='[]' execution_count=3}\n``` {.python .cell-code}\nimport math as m\n\nx = m.sqrt(2)\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.4142135623730951\n```\n:::\n:::\n\n\nYou may also only import specific functions of a module.\n\n::: {#1823d453 .cell tags='[]' execution_count=4}\n``` {.python .cell-code}\nfrom math import sinh as mysinh\n```\n:::\n\n\n## Contents of a module\n\nOnce a module is imported, we can list the symbols it provides using the `dir` function:\n\n::: {#8d162f92 .cell slideshow='{\"slide_type\":\"fragment\"}' tags='[]' execution_count=5}\n``` {.python .cell-code}\nimport math\n\nprint(dir(math))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'sumprod', 'tan', 'tanh', 'tau', 'trunc', 'ulp']\n```\n:::\n:::\n\n\nAnd using the function `help` we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n::: {#11e8f502 .cell slideshow='{\"slide_type\":\"fragment\"}' tags='[]' execution_count=6}\n``` {.python .cell-code}\nhelp(math.log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on built-in function log in module math:\n\nlog(...)\n    log(x, [base=math.e])\n    Return the logarithm of x to the given base.\n\n    If the base is not specified, returns the natural logarithm (base e) of x.\n\n```\n:::\n:::\n\n\n::: {#87807e7f .cell slideshow='{\"slide_type\":\"fragment\"}' tags='[]' execution_count=7}\n``` {.python .cell-code}\nmath.log(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n2.302585092994046\n```\n:::\n:::\n\n\n::: {#f628e5f7 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=8}\n``` {.python .cell-code}\nmath.log(8, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n3.0\n```\n:::\n:::\n\n\nWe can also use the `help` function directly on modules: Try\n\n    help(math)\n\nSome very useful modules form the Python standard library are `os`, `sys`, `math`, `shutil`, `re`, `subprocess`, `multiprocessing`, `threading`.\n\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n",
    "supporting": [
      "4_modules_files"
    ],
    "filters": [],
    "includes": {}
  }
}