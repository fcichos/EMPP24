{
  "hash": "a4dac0ee6e764a6f1a15ebdc44f800bd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lecture 2\"\nnotebook-url: \"https://github.com/fcichos/EMPP24/blob/main/lectures/lecture01/01-lecture01.ipynb\"\n---\n\n# Kinematics and Python\n## Introduction to Functions\n\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\n### Defining a Function\n\nA function in Python is defined using the `def` keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The `->` symbol is used to specify the return type of the function.\n\nHere's an example:\n\n::: {#a074128b .cell execution_count=1}\n``` {.python .cell-code}\n# Define a function that takes two numbers as input and returns their sum\ndef add_numbers(a: int, b: int) -> int:\n  return a + b\n```\n:::\n\n\n### Calling a Function\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function.\nHere's an example:\n\n::: {#b44a07ec .cell execution_count=2}\n``` {.python .cell-code}\n# Call the function with two numbers as input\nresult = add_numbers(2, 3)\nprint(result)  # prints 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\n## Loops\n\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: `for` loops and `while` loops.\n\n### For Loop\n\nA `for` loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here's an example:\n\n::: {#4b442617 .cell execution_count=3}\n``` {.python .cell-code}\n# Define a function that prints numbers from 1 to 10\ndef print_numbers():\n  for i in range(1, 11):\n    print(i)\n\nprint_numbers()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```\n:::\n:::\n\n\n### While Loop\n\nA `while` loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here's an example:\n\n::: {#eaf3c9b4 .cell execution_count=4}\n``` {.python .cell-code}\n# Define a function that prints numbers from 1 to 10 using a while loop\ndef print_numbers_while():\n  i = 1\n  while i <= 10:\n    print(i)\n    i += 1\n\nprint_numbers_while()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```\n:::\n:::\n\n\n## Conditional Statements\n\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are `if`, `else`, and `elif`.\n\n### If Statement\n\nAn `if` statement in Python is used to execute a block of code if a certain condition is met. Here's an example:\n\n::: {#53c8864e .cell execution_count=5}\n``` {.python .cell-code}\n# Define a function that prints \"hello\" or \"goodbye\" depending on the hour of day\ndef print_hello_or_goodbye():\n  current_hour = 12\n  if current_hour < 18:\n    print(\"hello\")\n  else:\n    print(\"goodbye\")\n\nprint_hello_or_goodbye()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\n```\n:::\n:::\n\n\n### Else Statement\n\nAn `else` statement in Python is used to execute a block of code if the condition in an `if` statement is not met.  Here's an example:\n\n::: {#4df4aa7d .cell execution_count=6}\n``` {.python .cell-code}\n# Define a function that prints \"hello\" or \"goodbye\" depending on the hour of day\ndef print_hello_or_goodbye():\n  current_hour = 12\n  if current_hour < 18:\n    print(\"hello\")\n  else:\n    print(\"goodbye\")\n\nprint_hello_or_goodbye()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\n```\n:::\n:::\n\n\n## Modules\n\nMost of the functionality in Python is provided by *modules*. The Python Standard Library is a large collection of modules that provides *cross-platform* implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\n\nTo use a module in a Python module it first has to be imported. A module can be imported using the `import` statement. For example, to import the module `math`, which contains many standard mathematical functions, we can do:\n\n::: {#dbac51be .cell tags='[]' execution_count=7}\n``` {.python .cell-code}\nimport math\nimport numpy\n\nx = math.sqrt(2 * math.pi)\nx = numpy.sqrt(2 * numpy.pi)\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.5066282746310002\n```\n:::\n:::\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don't need to use the prefix \"`math.`\" every time we use something from the `math` module:\n\n::: {#ce0f9162 .cell tags='[]' execution_count=8}\n``` {.python .cell-code}\nfrom math import *\n\nx = cos(2 * pi)\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.0\n```\n:::\n:::\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the `import math` pattern. This would eliminate potentially confusing problems.\n\n::: {.callout-note  title=\"Create Your Own Modules\" collapse=true}\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here's how you can create and use your own module:\n\n#### Creating a Module\n\nTo create a module, you just need to save your Python code in a file with a `.py` extension. For example, let's create a module named `mymodule.py` with the following content:\n\n```python\n# mymodule.py\n\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n\n#### Using Your Module\n\nOnce you have created your module, you can import it into other Python scripts using the `import` statement. Here's an example of how to use the `mymodule` we just created:\n\n```python\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n```\n\n### Importing Specific Functions\n\nYou can also import specific functions from a module using the `from ... import ...` syntax:\n\n```python\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n```\n\n### Module Search Path\n\nWhen you import a module, Python searches for the module in the following locations:\n1. The directory containing the input script (or the current directory if no script is specified).\n2. The directories listed in the `PYTHONPATH` environment variable.\n3. The default directory where Python is installed.\n\nYou can view the module search path by printing the `sys.path` variable:\n\n```python\nimport sys\nprint(sys.path)\n```\n\n### Creating Packages\n\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named `__init__.py`, which can be empty. Here's an example of how to create a package:\n\n```\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\n```\n\nYou can then import modules from the package using the dot notation:\n\n```python\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\n```\n\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n:::\n\n\n### Namespaces\n\n::: {.callout-note  title=\"Namespaces\"}\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix `math.` we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the `import math as mymath` pattern.\n:::\n\n::: {#2837ee6c .cell tags='[]' execution_count=9}\n``` {.python .cell-code}\nimport math as m\n\nx = m.sqrt(2)\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.4142135623730951\n```\n:::\n:::\n\n\nYou may also only import specific functions of a module.\n\n::: {#483cd5db .cell tags='[]' execution_count=10}\n``` {.python .cell-code}\nfrom math import sinh as mysinh\n```\n:::\n\n\n### Contents of a module\n\nOnce a module is imported, we can list the symbols it provides using the `dir` function:\n\n::: {#56783d98 .cell slideshow='{\"slide_type\":\"fragment\"}' tags='[]' execution_count=11}\n``` {.python .cell-code}\nimport math\n\nprint(dir(math))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'sumprod', 'tan', 'tanh', 'tau', 'trunc', 'ulp']\n```\n:::\n:::\n\n\nAnd using the function `help` we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n::: {#ccb0e252 .cell slideshow='{\"slide_type\":\"fragment\"}' tags='[]' execution_count=12}\n``` {.python .cell-code}\nhelp(math.log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on built-in function log in module math:\n\nlog(...)\n    log(x, [base=math.e])\n    Return the logarithm of x to the given base.\n\n    If the base is not specified, returns the natural logarithm (base e) of x.\n\n```\n:::\n:::\n\n\n::: {#65813a86 .cell slideshow='{\"slide_type\":\"fragment\"}' tags='[]' execution_count=13}\n``` {.python .cell-code}\nmath.log(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n2.302585092994046\n```\n:::\n:::\n\n\n::: {#dd834671 .cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=14}\n``` {.python .cell-code}\nmath.log(8, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\n3.0\n```\n:::\n:::\n\n\nWe can also use the `help` function directly on modules: Try\n\n    help(math)\n\nSome very useful modules form the Python standard library are `os`, `sys`, `math`, `shutil`, `re`, `subprocess`, `multiprocessing`, `threading`.\n\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n\n::: {.callout-note  title=\"Namespaces in Your Modules\" collapse=true}\n### Namespaces in Packages\n\nYou can also create sub-packages by adding more directories with `__init__.py` files. This allows you to create a hierarchical structure for your modules:\n\n```\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\n```\n\nYou can then import submodules using the full package name:\n\n```python\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())\n```\n:::\n\n\n\n**Python Application**\n\n## Function Plotting\n  - Writing a Python function to calculate and plot the position vs. time for an object moving with constant velocity or constant acceleration.\n  - Visualization: Use `matplotlib` to plot simple kinematic graphs (position vs. time, velocity vs. time).\n  - Homework: Extend the kinematic function to handle different initial conditions and plot the results.\n\n\n\n\n```{=html}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Ball Throw Simulation</title>\n    <script src=\"https://d3js.org/d3.v7.min.js\"></script>\n</head>\n<body>\n    <div id=\"simulation\"></div>\n\n    <script>\n        // Set up the SVG\n        const width = 600;\n        const height = 400;\n        const svg = d3.select(\"#simulation\")\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        // Physics parameters\n        const g = 9.81;  // Gravity (m/s^2)\n        const v0 = 20;   // Initial velocity (m/s)\n        const angle = 60 * Math.PI / 180;  // Launch angle (radians)\n\n        // Calculate trajectory\n        function calculateTrajectory() {\n            const points = [];\n            for (let t = 0; t <= 4; t += 0.1) {\n                const x = v0 * Math.cos(angle) * t;\n                const y = v0 * Math.sin(angle) * t - 0.5 * g * t * t;\n                if (y >= 0) {\n                    points.push({x: x * 10, y: height - y * 10});\n                }\n            }\n            return points;\n        }\n\n        // Draw the trajectory\n        const lineGenerator = d3.line()\n            .x(d => d.x)\n            .y(d => d.y);\n\n        svg.append(\"path\")\n            .datum(calculateTrajectory())\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", \"steelblue\")\n            .attr(\"stroke-width\", 2)\n            .attr(\"d\", lineGenerator);\n\n        // Add a ball\n        const ball = svg.append(\"circle\")\n            .attr(\"r\", 5)\n            .attr(\"fill\", \"red\");\n\n        // Animate the ball\n        function animateBall() {\n            const trajectory = calculateTrajectory();\n            ball.datum({index: 0})\n                .transition()\n                .duration(4000)\n                .ease(d3.easeLinear)\n                .attrTween(\"cx\", function(d) {\n                    return function(t) {\n                        d.index = Math.floor(t * trajectory.length);\n                        return trajectory[d.index].x;\n                    };\n                })\n                .attrTween(\"cy\", function(d) {\n                    return function(t) {\n                        return trajectory[d.index].y;\n                    };\n                })\n                .on(\"end\", animateBall);\n        }\n\n        animateBall();\n    </script>\n</body>\n</html>\n```\n\n",
    "supporting": [
      "01-lecture02_files"
    ],
    "filters": [],
    "includes": {}
  }
}