{
  "hash": "5b7ddc6840e80cac9db4e1d4d433cf06",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Lecture 3\n---\n\n# Dynamics and Simple Motion\n\n  - Lists and arrays (introduction to `numpy` for numerical operations).\n  - Basic vector operations using `numpy`.\n\n\n::: {.callout-note title=\"Numpy Array\"}\nThe NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a **NumPy array** are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type. For example, they might be all integers or all floating point numbers. NumPy arrays are more efficient than Python lists for storing and manipulating data.\n:::\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n    #| slideshow: {slide_type: fragment}\n    import numpy as np\n```\n:::\n\n\n## Creating Numpy Arrays\n\n  There are a number of ways to initialize new numpy arrays, for example from\n\n  * a Python list or tuples using `np.array`\n  * using functions that are dedicated to generating numpy arrays, such as `arange`, `linspace`, etc.\n  * reading data from files which will be covered in the files section of this course.\n\n### From lists\n\n  For example, to create new vector and matrix arrays from Python lists we can use the `numpy.array` function. This is demonstrated in the following cells:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n  #this is a list\n  a = [0, 0, 1, 4, 7, 16, 31, 64, 127]\n\n  type(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nlist\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n  b=np.array(a,dtype=float)\n  type(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nnumpy.ndarray\n```\n:::\n:::\n\n\n### Using array-generating functions\n\n  For larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in `numpy` that generate arrays of different forms and shapes.\n  Some of the more common are:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  # create a range\n\n  x = np.arange(0, 10, 1) # arguments: start, stop, step\n  x\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  x = np.arange(-5, -2, 0.1)\n  x\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([-5. , -4.9, -4.8, -4.7, -4.6, -4.5, -4.4, -4.3, -4.2, -4.1, -4. ,\n       -3.9, -3.8, -3.7, -3.6, -3.5, -3.4, -3.3, -3.2, -3.1, -3. , -2.9,\n       -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1])\n```\n:::\n:::\n\n\n::: {.callout-note title=\"linspace\"}\n\n  The `linspace` function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50. The function `linspace` always includes the end points.\n\n:::\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  # using linspace, both end points ARE included\n  np.linspace(0,10,25)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([ 0.        ,  0.41666667,  0.83333333,  1.25      ,  1.66666667,\n        2.08333333,  2.5       ,  2.91666667,  3.33333333,  3.75      ,\n        4.16666667,  4.58333333,  5.        ,  5.41666667,  5.83333333,\n        6.25      ,  6.66666667,  7.08333333,  7.5       ,  7.91666667,\n        8.33333333,  8.75      ,  9.16666667,  9.58333333, 10.        ])\n```\n:::\n:::\n\n\n::: {.callout-note title=\"logspace\"}\n  `logspace` is doing equivelent things with logaritmic spacing. The function `logspace` generates an array of N points between decades 10^start and 10^stop. The form of the function is logspace(start, stop, N). If the third argument N is omitted, then N=50. The function `logspace` always includes the end points.\n:::\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  np.logspace(0, 10, 10, base=np.e)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([1.00000000e+00, 3.03773178e+00, 9.22781435e+00, 2.80316249e+01,\n       8.51525577e+01, 2.58670631e+02, 7.85771994e+02, 2.38696456e+03,\n       7.25095809e+03, 2.20264658e+04])\n```\n:::\n:::\n\n\nOther types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n::: {.callout-note title=\"mgrid\"}\n\n  `mgrid` generates a multi-dimensional matrix with increasing value entries, for example in columns and rows. The arguments are similar to `arange` and `linspace`.\n:::\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=8}\n``` {.python .cell-code}\nx, y = np.mgrid[0:1:0.1, 0:5] # similar to meshgrid in MATLAB\n```\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=9}\n``` {.python .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([[0. , 0. , 0. , 0. , 0. ],\n       [0.1, 0.1, 0.1, 0.1, 0.1],\n       [0.2, 0.2, 0.2, 0.2, 0.2],\n       [0.3, 0.3, 0.3, 0.3, 0.3],\n       [0.4, 0.4, 0.4, 0.4, 0.4],\n       [0.5, 0.5, 0.5, 0.5, 0.5],\n       [0.6, 0.6, 0.6, 0.6, 0.6],\n       [0.7, 0.7, 0.7, 0.7, 0.7],\n       [0.8, 0.8, 0.8, 0.8, 0.8],\n       [0.9, 0.9, 0.9, 0.9, 0.9]])\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=10}\n``` {.python .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.],\n       [0., 1., 2., 3., 4.]])\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=11}\n``` {.python .cell-code}\nnp.array([[1,2,3],[4,5,6],[7,8,9]])\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n```\n:::\n:::\n\n\n::: {.callout-note title=\"diag\"}\n\n  `diag` generates a diagonal matrix with the list supplied to it as the diagonal values. The values can be also offset from the main diagonal by using the optional argument `k`. If `k` is positive, the diagonal is above the main diagonal, if negative, below the main diagonal.\n:::\n\n::: {.cell tags='[]' execution_count=12}\n``` {.python .cell-code}\n# a diagonal matrix\nnp.diag([1,2,3])\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([[1, 0, 0],\n       [0, 2, 0],\n       [0, 0, 3]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n## diagonal with offset from the main diagonal\nnp.diag([1,2,3], k=-1)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([[0, 0, 0, 0],\n       [1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0]])\n```\n:::\n:::\n\n\n::: {.callout-note title=\"zeros and ones\"}\n\n  `zeros` and `ones` creates a matrix with the dimensions given in the argument and filled with 0 or 1. The argument is a tuple with the dimensions of the matrix. For example, `np.zeros((3,3))` creates a 3x3 matrix filled with zeros.\n:::\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=14}\n``` {.python .cell-code}\nnp.zeros((3,3))\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n```\n:::\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=15}\n``` {.python .cell-code}\nnp.ones((3,3))\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n```\n:::\n:::\n\n\n## Manipulating NumPy arrays\n\n### Slicing\n\n  Slicing is the name for extracting part of an array by the syntax `M[lower:upper:step]`. When any of these are unspecified, they default to the values `lower=0`, `upper=size of dimension`, `step=1`. We can also use negative indices to count from the end of the array. Here are some examples:\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=16}\n``` {.python .cell-code}\nA = np.array([1,2,3,4,5])\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([1, 2, 3, 4, 5])\n```\n:::\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=17}\n``` {.python .cell-code}\nA[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\n  Any of the three parameters in `M[lower:upper:step]` can be ommited.\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=18}\n``` {.python .cell-code}\nA[::] # lower, upper, step all take the default values\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([1, 2, 3, 4, 5])\n```\n:::\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=19}\n``` {.python .cell-code}\nA[::2] # step is 2, lower and upper defaults to the beginning and end of the array\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([1, 3, 5])\n```\n:::\n:::\n\n\n  Negative indices counts from the end of the array (positive index from the begining) and can be used in any of the three slicing parameters. Here are some examples:\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=20}\n``` {.python .cell-code}\nA = np.array([1,2,3,4,5])\n```\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=21}\n``` {.python .cell-code}\nA[-1] # the last element in the array\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nnp.int64(5)\n```\n:::\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=22}\n``` {.python .cell-code}\nA[2:] # the last three elements\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\narray([3, 4, 5])\n```\n:::\n:::\n\n\n  Index slicing works exactly the same way for multidimensional arrays. We can slice along each axis independently. Here are some examples:\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=23}\n``` {.python .cell-code}\nA = np.array([[n+m*10 for n in range(5)] for m in range(5)])\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\narray([[ 0,  1,  2,  3,  4],\n       [10, 11, 12, 13, 14],\n       [20, 21, 22, 23, 24],\n       [30, 31, 32, 33, 34],\n       [40, 41, 42, 43, 44]])\n```\n:::\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=24}\n``` {.python .cell-code}\n# a block from the original array\nA[1:3, 1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([[11, 12, 13],\n       [21, 22, 23]])\n```\n:::\n:::\n\n\n::: {.callout-note title=\"Differences\"}\n\n  **Slicing** can be effectively used to calculate differences for example for the calculation of derivatives. Here the position $y_i$ of an object has been measured at times $t_i$ and stored in an array each. We wish to calculate the average velocity at the times $t_{i}$ from the arrays by the formula\n\n  \\begin{equation}\n  v_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n  \\end{equation}\n:::\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=25}\n``` {.python .cell-code}\ny = np.array([ 0. , 1.3, 5. , 10.9, 18.9, 28.7, 40. ])\nt = np.array([ 0. , 0.49, 1. , 1.5 , 2.08, 2.55, 3.2 ])\n```\n:::\n\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=26}\n``` {.python .cell-code}\nv = (y[1:]-y[:-1])/(t[1:]-t[:-1])\nv\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\narray([ 2.65306122,  7.25490196, 11.8       , 13.79310345, 20.85106383,\n       17.38461538])\n```\n:::\n:::\n\n\n### Reshaping\n\n  Arrays can be reshaped into any form, which contains the same number of elements. For example, a 4-element array can be reshaped into a 2x2 array, or a 2x2 array can be reshaped into a 4-element array. Here are some examples:\n\n::: {.cell slideshow='{\"slide_type\":\"fragment\"}' execution_count=27}\n``` {.python .cell-code}\na=np.zeros(4)\na\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\narray([0., 0., 0., 0.])\n```\n:::\n:::\n\n\n::: {.cell ExecuteTime='{\"end_time\":\"2019-04-09T12:09:59.284858Z\",\"start_time\":\"2019-04-09T12:09:59.280261Z\"}' slideshow='{\"slide_type\":\"fragment\"}' execution_count=28}\n``` {.python .cell-code}\nnp.reshape(a,(2,2))\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\narray([[0., 0.],\n       [0., 0.]])\n```\n:::\n:::\n\n\n### Adding a new dimension: newaxis\n\n  With `newaxis`, we can insert new dimensions in an array, for example converting a vector to a column or row matrix. Here are some examples:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  v = np.array([1,2,3])\n  v\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\narray([1, 2, 3])\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  v.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n(3,)\n```\n:::\n:::\n\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  # make a column matrix of the vector v\n  v[:, np.newaxis]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\narray([[1],\n       [2],\n       [3]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  # column matrix\n  v[:,np.newaxis].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n(3, 1)\n```\n:::\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  # row matrix\n  v[np.newaxis,:].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n(1, 3)\n```\n:::\n:::\n\n\n### Stacking and repeating arrays\n\n  Using function `repeat`, `tile`, `vstack`, `hstack`, and `concatenate` we can create larger vectors and matrices from smaller ones by repeating or stacking. Please try the individual functions yourself in your notebook. We wont discuss them in detail here.\n\n#### Tile and repeat\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  a = np.array([[1, 2], [3, 4]])\n  a\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\narray([[1, 2],\n       [3, 4]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  # repeat each element 3 times\n  np.repeat(a, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\narray([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4])\n```\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  # tile the matrix 3 times\n  np.tile(a, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\narray([[1, 2, 1, 2, 1, 2],\n       [3, 4, 3, 4, 3, 4]])\n```\n:::\n:::\n\n\n#### Concatenate\n\nConcatenate joins arrays along an existing axis. Here are some examples:\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  a = np.array([[1, 2], [3, 4]])\n  a\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\narray([[1, 2],\n       [3, 4]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  b = np.array([[5, 6]])\n```\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  np.concatenate((a, b), axis=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  np.concatenate((a, b.T), axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\narray([[1, 2, 5],\n       [3, 4, 6]])\n```\n:::\n:::\n\n\n#### Hstack and vstack\n\nhstack and vstack stack arrays horizontally and vertically. Here are some examples:\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  a = np.array([1, 2, 3])\n  b = np.array([2, 3, 4])\n```\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  np.vstack((a,b))\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\narray([[1, 2, 3],\n       [2, 3, 4]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: skip}\n  np.hstack((a,b.T))\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\narray([1, 2, 3, 2, 3, 4])\n```\n:::\n:::\n\n\n## Applying mathematical functions\n\n  All kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below where `a` is an array of numbers from 0 to 9.\n\n### Operation involving one array\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  a=np.arange(0, 10, 1.5)\n  a\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\narray([0. , 1.5, 3. , 4.5, 6. , 7.5, 9. ])\n```\n:::\n:::\n\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  a/2\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\narray([0.  , 0.75, 1.5 , 2.25, 3.  , 3.75, 4.5 ])\n```\n:::\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  a**2\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\narray([ 0.  ,  2.25,  9.  , 20.25, 36.  , 56.25, 81.  ])\n```\n:::\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  np.sin(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\narray([ 0.        ,  0.99749499,  0.14112001, -0.97753012, -0.2794155 ,\n        0.93799998,  0.41211849])\n```\n:::\n:::\n\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  np.exp(-a)\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\narray([1.00000000e+00, 2.23130160e-01, 4.97870684e-02, 1.11089965e-02,\n       2.47875218e-03, 5.53084370e-04, 1.23409804e-04])\n```\n:::\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n  #| slideshow: {slide_type: fragment}\n  (a+2)/3\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\narray([0.66666667, 1.16666667, 1.66666667, 2.16666667, 2.66666667,\n       3.16666667, 3.66666667])\n```\n:::\n:::\n\n\n### Operations involving multiple arrays\n\n  Operation between multiple vectors allow in particular very quick operations. The operations address then elements of the same index. These operations are called vector operations since the concern the whole array at the same time. The product between two vectors results therefore not in a dot product, which gives one number but in an array of multiplied elements.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n  #| ExecuteTime: {end_time: '2017-04-20T21:16:34.978152+02:00', start_time: '2017-04-20T21:16:34.973278'}\n  #| slideshow: {slide_type: fragment}\n  a = np.array([34., -12, 5.,1.2])\n  b = np.array([68., 5.0, 20.,40.])\n```\n:::\n\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n  #| ExecuteTime: {end_time: '2017-04-20T21:16:41.810170+02:00', start_time: '2017-04-20T21:16:41.804038'}\n  #| slideshow: {slide_type: fragment}\n  a + b\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\narray([102. ,  -7. ,  25. ,  41.2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n  #| ExecuteTime: {end_time: '2017-04-20T21:16:48.002366+02:00', start_time: '2017-04-20T21:16:47.996136'}\n  #| slideshow: {slide_type: fragment}\n  #| tags: []\n  2*b\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\narray([136.,  10.,  40.,  80.])\n```\n:::\n:::\n\n\nxxw\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n  #| ExecuteTime: {end_time: '2017-04-20T21:20:19.373091+02:00', start_time: '2017-04-20T21:20:19.367493'}\n  #| slideshow: {slide_type: fragment}\n  a*np.exp(-b)\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\narray([ 9.98743918e-29, -8.08553640e-02,  1.03057681e-08,  5.09802511e-18])\n```\n:::\n:::\n\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n  #| tags: []\n  v1=np.array([1,2,3])\n  v2=np.array([4,2,3])\n```\n:::\n\n\n<div class=\"section-application\">\n## Application\n  - Simulating and plotting the trajectory of a projectile under the influence of gravity (2D motion).\n  - Introduction to vector addition and resolving vectors into components.\n  - Visualization: Plotting the path of the projectile and velocity vectors.\n  - Homework: Simulate projectile motion with air resistance (optional for advanced students).\n</div>\n\n",
    "supporting": [
      "01-lecture03_files/figure-pdf"
    ],
    "filters": []
  }
}