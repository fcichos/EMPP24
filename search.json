[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "Variables & Numbers",
    "section": "",
    "text": "Variable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nThere are a number of Python keywords that cannot be used as variable names because Python uses them for other things. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\n\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "title": "Variables & Numbers",
    "section": "",
    "text": "Variable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nThere are a number of Python keywords that cannot be used as variable names because Python uses them for other things. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\n\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#number-types",
    "href": "lectures/lecture01/02-lecture01.html#number-types",
    "title": "Variables & Numbers",
    "section": "Number Types",
    "text": "Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\nComparison of Number Types\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n\n\n\nExamples for Number Types\n\n\n\n\n\n\nIntegers\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\nFloating Point Numbers\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\nComplex Numbers\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#type-conversion",
    "href": "lectures/lecture01/02-lecture01.html#type-conversion",
    "title": "Variables & Numbers",
    "section": "Type Conversion",
    "text": "Type Conversion\n\nImplicit Type Conversion\nPython automatically converts types during operations involving mixed types. The result is a type that can accommodate all the values involved in the operation. This is known as implicit type conversion. For example, adding an integer and a float results in a float.\n\n\n\n\n\n\n\n\nExplicit Type Conversion\nUse functions like int(), float(), and str() to explicitly convert types from one to another. Explicit type conversion is also known as type casting. For example, converting a string to an integer.\n\n\n\n\n\n\nConverting a float to an integer truncates the decimal part.\n\n\n\n\n\n\n\n\n\n\n\n\nHandling Complex Numbers\n\n\n\nComplex numbers cannot be directly converted to floats or integers; extract the real or imaginary part first.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-summary01.html",
    "href": "lectures/lecture01/02-summary01.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\nx = 1.0  # Assigns 1.0 to variable x\nmy_variable = \"Hello\"  # Assigns string \"Hello\"\n\n\n\nUse a-z, A-Z, 0-9, and _\nStart with letter or underscore\nCase-sensitive\nAvoid reserved keywords\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n5\nWhole numbers\n\n\nfloat\n3.14\nDecimal numbers\n\n\ncomplex\n2 + 3j\nReal + imaginary\n\n\nbool\nTrue\nLogical values\n\n\n\n\n\n\nint_num = int(3.14)    # 3\nfloat_num = float(5)   # 5.0\nstr_num = str(42)      # \"42\"\n\n\n\n\na, b = 10, 3\nsum_result = a + b   # Addition\ndiff_result = a - b  # Subtraction\nprod_result = a * b  # Multiplication\ndiv_result = a / b   # Division (float)\nint_div_result = a // b  # Integer division\nmod_result = a % b   # Modulus\npower_result = a ** b  # Exponentiation\n\n\n\nc = 2 + 4j\nreal_part = c.real     # 2.0\nimag_part = c.imag     # 4.0\nconjugate = c.conjugate()  # 2 - 4j\n\n\n\ntype(variable)  # Returns type\nisinstance(variable, type)  # Checks type\n\n\n\nimport math\n\nsqrt_result = math.sqrt(16)\nlog_result = math.log(100, 10)\nsin_result = math.sin(math.pi/2)"
  },
  {
    "objectID": "lectures/lecture01/02-summary01.html#python-basics-cheat-sheet",
    "href": "lectures/lecture01/02-summary01.html#python-basics-cheat-sheet",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\nx = 1.0  # Assigns 1.0 to variable x\nmy_variable = \"Hello\"  # Assigns string \"Hello\"\n\n\n\nUse a-z, A-Z, 0-9, and _\nStart with letter or underscore\nCase-sensitive\nAvoid reserved keywords\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n5\nWhole numbers\n\n\nfloat\n3.14\nDecimal numbers\n\n\ncomplex\n2 + 3j\nReal + imaginary\n\n\nbool\nTrue\nLogical values\n\n\n\n\n\n\nint_num = int(3.14)    # 3\nfloat_num = float(5)   # 5.0\nstr_num = str(42)      # \"42\"\n\n\n\n\na, b = 10, 3\nsum_result = a + b   # Addition\ndiff_result = a - b  # Subtraction\nprod_result = a * b  # Multiplication\ndiv_result = a / b   # Division (float)\nint_div_result = a // b  # Integer division\nmod_result = a % b   # Modulus\npower_result = a ** b  # Exponentiation\n\n\n\nc = 2 + 4j\nreal_part = c.real     # 2.0\nimag_part = c.imag     # 4.0\nconjugate = c.conjugate()  # 2 - 4j\n\n\n\ntype(variable)  # Returns type\nisinstance(variable, type)  # Checks type\n\n\n\nimport math\n\nsqrt_result = math.sqrt(16)\nlog_result = math.log(100, 10)\nsin_result = math.sin(math.pi/2)"
  },
  {
    "objectID": "lectures/lecture08/01-lecture08.html",
    "href": "lectures/lecture08/01-lecture08.html",
    "title": "Lecture 8",
    "section": "",
    "text": "Introduction to 2D arrays and matrix operations in numpy.\nUsing matrix methods to solve systems of equations related to rigid body dynamics.\n\n\n\n\n\nSimulating the motion of a rigid body under the influence of forces and torques.\nVisualizing the rotation and translation of the body.\nHomework: Simulate a rigid body with varying moments of inertia (e.g., a non-uniform object)."
  },
  {
    "objectID": "lectures/lecture08/01-lecture08.html#rigid-bodies-and-torque",
    "href": "lectures/lecture08/01-lecture08.html#rigid-bodies-and-torque",
    "title": "Lecture 8",
    "section": "",
    "text": "Introduction to 2D arrays and matrix operations in numpy.\nUsing matrix methods to solve systems of equations related to rigid body dynamics.\n\n\n\n\n\nSimulating the motion of a rigid body under the influence of forces and torques.\nVisualizing the rotation and translation of the body.\nHomework: Simulate a rigid body with varying moments of inertia (e.g., a non-uniform object)."
  },
  {
    "objectID": "lectures/lecture07/01-lecture07.html",
    "href": "lectures/lecture07/01-lecture07.html",
    "title": "Lecture 7",
    "section": "",
    "text": "Solving differential equations using Python (Euler’s method for numerical integration).\nUsing scipy for more advanced numerical methods.\n\n\n\n\n\nSimulating gravitational forces and orbital motion (e.g., a planet orbiting a star).\nVisualizing the orbit and calculating parameters like orbital period and eccentricity.\nHomework: Modify the simulation to include multiple bodies (e.g., a three-body problem)."
  },
  {
    "objectID": "lectures/lecture07/01-lecture07.html#gravitation-and-orbital-mechanics",
    "href": "lectures/lecture07/01-lecture07.html#gravitation-and-orbital-mechanics",
    "title": "Lecture 7",
    "section": "",
    "text": "Solving differential equations using Python (Euler’s method for numerical integration).\nUsing scipy for more advanced numerical methods.\n\n\n\n\n\nSimulating gravitational forces and orbital motion (e.g., a planet orbiting a star).\nVisualizing the orbit and calculating parameters like orbital period and eccentricity.\nHomework: Modify the simulation to include multiple bodies (e.g., a three-body problem)."
  },
  {
    "objectID": "lectures/lecture11/01-lecture11.html",
    "href": "lectures/lecture11/01-lecture11.html",
    "title": "Lecture 11",
    "section": "",
    "text": "Solving coupled differential equations for oscillatory systems (e.g., damped harmonic oscillators).\nUsing Fourier analysis to study waveforms.\n\n\n\n\n\nSimulating simple harmonic motion and damped oscillations.\nVisualizing the motion and analyzing the frequency components of the oscillation.\nHomework: Extend the simulation to include coupled oscillators or waves on a string.\n\n\n//| echo: false\n  d3 = require(\"d3@7\")\n\n\n\n\n\n\n\n//| echo: false\n\n  // Define the Vicsek model simulation\n  {\n\n\n  function vicsekModel(width, height, particleCount, noise) {\n    const particles = d3.range(particleCount).map(() =&gt; ({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      angle: Math.random() * 2 * Math.PI\n    }));\n\n    function step(currentRadius) {\n      particles.forEach(particle =&gt; {\n        // Find neighbors within radius\n        const neighbors = particles.filter(p =&gt;\n          (p !== particle) &&\n          (Math.hypot(p.x - particle.x, p.y - particle.y) &lt;= radius)\n        );\n\n        // Calculate average direction of neighbors\n        let avgAngle = particle.angle;\n        if (neighbors.length &gt; 0) {\n          avgAngle = d3.mean(neighbors, d =&gt; d.angle);\n        }\n\n        // Update particle angle with noise\n        particle.angle = avgAngle + (Math.random() - 0.5) * noise;\n\n        // Move particle\n        particle.x += speed*Math.cos(particle.angle);\n        particle.y += speed*Math.sin(particle.angle);\n\n        // Wrap around boundaries\n        particle.x = (particle.x + width) % width;\n        particle.y = (particle.y + height) % height;\n      });\n    }\n\n    return {\n      particles,\n      step\n    };\n  }\n\n  // Set up the visualization\n  const width = 600;\n  const height = 600;\n  const particleCount = 400;\n  const noise = 2;\n  let speed = 5;\n  let radius = 20;\n\n  // Create container div\n  const container = d3.create(\"div\");\n\n  // Create slider\n  const slider = container.append(\"input\")\n    .attr(\"type\", \"range\")\n    .attr(\"min\", 1)\n    .attr(\"max\", 50)\n    .attr(\"value\", radius)\n    .style(\"width\", \"50%\")\n    .on(\"input\", function() {\n      radius = +this.value;\n      d3.select(\"#radius-value\").text(radius);\n    });\n\n    const slider1 = container.append(\"input\")\n      .attr(\"type\", \"range\")\n      .attr(\"min\", 1)\n      .attr(\"max\", 10)\n      .attr(\"value\", speed)\n      .style(\"width\", \"50%\")\n      .on(\"input\", function() {\n        speed = +this.value;\n        d3.select(\"#speed-value\").text(speed);\n      });\n\n  // Display current radius value\n  container.append(\"div\")\n    .text(\"Radius: \")\n    .append(\"span\")\n    .attr(\"id\", \"radius-value\")\n    .text(radius);\n\n  // Create SVG\n  const svg = container.append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .style(\"background\", \"#f0f0f0\");\n\n  const model = vicsekModel(width, height, particleCount, noise);\n\n  const particles = svg.selectAll(\"circle\")\n    .data(model.particles)\n    .join(\"circle\")\n    .attr(\"r\", 2)\n    .attr(\"fill\", \"blue\");\n\n  // Animation function\n  function animate() {\n    model.step(radius);\n    particles\n      .attr(\"cx\", d =&gt; d.x)\n      .attr(\"cy\", d =&gt; d.y);\n    requestAnimationFrame(animate);\n  }\n\n  // Start the animation\n  animate();\n\n  // Return the container div\n  return container.node();}"
  },
  {
    "objectID": "lectures/lecture11/01-lecture11.html#oscillations-and-waves",
    "href": "lectures/lecture11/01-lecture11.html#oscillations-and-waves",
    "title": "Lecture 11",
    "section": "",
    "text": "Solving coupled differential equations for oscillatory systems (e.g., damped harmonic oscillators).\nUsing Fourier analysis to study waveforms.\n\n\n\n\n\nSimulating simple harmonic motion and damped oscillations.\nVisualizing the motion and analyzing the frequency components of the oscillation.\nHomework: Extend the simulation to include coupled oscillators or waves on a string.\n\n\n//| echo: false\n  d3 = require(\"d3@7\")\n\n\n\n\n\n\n\n//| echo: false\n\n  // Define the Vicsek model simulation\n  {\n\n\n  function vicsekModel(width, height, particleCount, noise) {\n    const particles = d3.range(particleCount).map(() =&gt; ({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      angle: Math.random() * 2 * Math.PI\n    }));\n\n    function step(currentRadius) {\n      particles.forEach(particle =&gt; {\n        // Find neighbors within radius\n        const neighbors = particles.filter(p =&gt;\n          (p !== particle) &&\n          (Math.hypot(p.x - particle.x, p.y - particle.y) &lt;= radius)\n        );\n\n        // Calculate average direction of neighbors\n        let avgAngle = particle.angle;\n        if (neighbors.length &gt; 0) {\n          avgAngle = d3.mean(neighbors, d =&gt; d.angle);\n        }\n\n        // Update particle angle with noise\n        particle.angle = avgAngle + (Math.random() - 0.5) * noise;\n\n        // Move particle\n        particle.x += speed*Math.cos(particle.angle);\n        particle.y += speed*Math.sin(particle.angle);\n\n        // Wrap around boundaries\n        particle.x = (particle.x + width) % width;\n        particle.y = (particle.y + height) % height;\n      });\n    }\n\n    return {\n      particles,\n      step\n    };\n  }\n\n  // Set up the visualization\n  const width = 600;\n  const height = 600;\n  const particleCount = 400;\n  const noise = 2;\n  let speed = 5;\n  let radius = 20;\n\n  // Create container div\n  const container = d3.create(\"div\");\n\n  // Create slider\n  const slider = container.append(\"input\")\n    .attr(\"type\", \"range\")\n    .attr(\"min\", 1)\n    .attr(\"max\", 50)\n    .attr(\"value\", radius)\n    .style(\"width\", \"50%\")\n    .on(\"input\", function() {\n      radius = +this.value;\n      d3.select(\"#radius-value\").text(radius);\n    });\n\n    const slider1 = container.append(\"input\")\n      .attr(\"type\", \"range\")\n      .attr(\"min\", 1)\n      .attr(\"max\", 10)\n      .attr(\"value\", speed)\n      .style(\"width\", \"50%\")\n      .on(\"input\", function() {\n        speed = +this.value;\n        d3.select(\"#speed-value\").text(speed);\n      });\n\n  // Display current radius value\n  container.append(\"div\")\n    .text(\"Radius: \")\n    .append(\"span\")\n    .attr(\"id\", \"radius-value\")\n    .text(radius);\n\n  // Create SVG\n  const svg = container.append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .style(\"background\", \"#f0f0f0\");\n\n  const model = vicsekModel(width, height, particleCount, noise);\n\n  const particles = svg.selectAll(\"circle\")\n    .data(model.particles)\n    .join(\"circle\")\n    .attr(\"r\", 2)\n    .attr(\"fill\", \"blue\");\n\n  // Animation function\n  function animate() {\n    model.step(radius);\n    particles\n      .attr(\"cx\", d =&gt; d.x)\n      .attr(\"cy\", d =&gt; d.y);\n    requestAnimationFrame(animate);\n  }\n\n  // Start the animation\n  animate();\n\n  // Return the container div\n  return container.node();}"
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "Modules",
    "section": "",
    "text": "Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python module it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\n\n\n\n\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\n\n\n\n\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems.\n\n\n\n\n\n\n\n\nNamespaces\n\n\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the import math as mymath pattern.\n\n\n\n\n\n\n\n\nYou may also only import specific functions of a module.\n\n\n\n\n\n\n\n\n\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\n\n\n\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n\n\n\n\n\n\n\n\nCreate Your Own Modules\n\n\n\n\n\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here’s how you can create and use your own module:\n\n\nTo create a module, you just need to save your Python code in a file with a .py extension. For example, let’s create a module named mymodule.py with the following content:\n# mymodule.py\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\n\nOnce you have created your module, you can import it into other Python scripts using the import statement. Here’s an example of how to use the mymodule we just created:\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n\n\n\nYou can also import specific functions from a module using the from ... import ... syntax:\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n\n\n\nWhen you import a module, Python searches for the module in the following locations: 1. The directory containing the input script (or the current directory if no script is specified). 2. The directories listed in the PYTHONPATH environment variable. 3. The default directory where Python is installed.\nYou can view the module search path by printing the sys.path variable:\nimport sys\nprint(sys.path)\n\n\n\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named __init__.py, which can be empty. Here’s an example of how to create a package:\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\nYou can then import modules from the package using the dot notation:\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n\n\n\n\n\n\n\n\n\nNamespaces in Your Modules\n\n\n\n\n\n\nYou can also create sub-packages by adding more directories with __init__.py files. This allows you to create a hierarchical structure for your modules:\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\nYou can then import submodules using the full package name:\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Modules"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#modules",
    "href": "lectures/lecture02/02-lecture02.html#modules",
    "title": "Modules",
    "section": "",
    "text": "Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python module it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\n\n\n\n\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\n\n\n\n\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems.\n\n\n\n\n\n\n\n\nNamespaces\n\n\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the import math as mymath pattern.\n\n\n\n\n\n\n\n\nYou may also only import specific functions of a module.\n\n\n\n\n\n\n\n\n\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\n\n\n\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n\n\n\n\n\n\n\n\nCreate Your Own Modules\n\n\n\n\n\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here’s how you can create and use your own module:\n\n\nTo create a module, you just need to save your Python code in a file with a .py extension. For example, let’s create a module named mymodule.py with the following content:\n# mymodule.py\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\n\nOnce you have created your module, you can import it into other Python scripts using the import statement. Here’s an example of how to use the mymodule we just created:\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n\n\n\nYou can also import specific functions from a module using the from ... import ... syntax:\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n\n\n\nWhen you import a module, Python searches for the module in the following locations: 1. The directory containing the input script (or the current directory if no script is specified). 2. The directories listed in the PYTHONPATH environment variable. 3. The default directory where Python is installed.\nYou can view the module search path by printing the sys.path variable:\nimport sys\nprint(sys.path)\n\n\n\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named __init__.py, which can be empty. Here’s an example of how to create a package:\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\nYou can then import modules from the package using the dot notation:\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n\n\n\n\n\n\n\n\n\nNamespaces in Your Modules\n\n\n\n\n\n\nYou can also create sub-packages by adding more directories with __init__.py files. This allows you to create a hierarchical structure for your modules:\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\nYou can then import submodules using the full package name:\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Modules"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "Python Overview",
    "section": "",
    "text": "Functions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#functions",
    "href": "lectures/lecture02/01-lecture02.html#functions",
    "title": "Python Overview",
    "section": "",
    "text": "Functions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#loops",
    "href": "lectures/lecture02/01-lecture02.html#loops",
    "title": "Python Overview",
    "section": "Loops",
    "text": "Loops\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#conditional-statements",
    "href": "lectures/lecture02/01-lecture02.html#conditional-statements",
    "title": "Python Overview",
    "section": "Conditional Statements",
    "text": "Conditional Statements\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html",
    "href": "lectures/lecture02/3_datatypes.html",
    "title": "Data Types",
    "section": "",
    "text": "It’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe following few cells will give you a short introduction into each type.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#strings",
    "href": "lectures/lecture02/3_datatypes.html#strings",
    "title": "Data Types",
    "section": "Strings",
    "text": "Strings\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#lists",
    "href": "lectures/lecture02/3_datatypes.html#lists",
    "title": "Data Types",
    "section": "Lists",
    "text": "Lists\nLists have a variety of uses. They are useful, for example, in various bookkeeping tasks that arise in computer programming. Like arrays, they are sometimes used to store data. However, lists do not have the specialized properties and tools that make arrays so powerful for scientific computing. So in general, we prefer arrays to lists for working with scientific data. For other tasks, lists work just fine and can even be preferable to arrays.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndividual elements in a list can be accessed by the variable name and the number (index) of the list element put in square brackets. Note that the index for the elements start at 0 for the first element (left).\n\n\n\n\n\n\nIndices in Python\n\n\n\nThe first element of a list or array is accessed by the index 0. If the array has N elements, the last entry’s index is N-1.\n\n\n\n\n\n\n\n\nElements may be also accessed from the back by nagative indices. b[-1] denotes the last element in the list and b[-2], the element before the last.\n\n\n\n\n\n\n\n\n\n\n\n\nThe length of a list can be obtained by the len command if you need the number of elements in the list for your calculations.\n\n\n\n\n\n\nThere are powerful ways to iterate through a list and also through arrays in form of iterator. This is called list comprehension. We will talk about them later in more detail. Here is an example, which shows the powerful options you have in Python.\n\n\n\n\n\n\nIndividual elements in a list can be replaced by assigning a new value to them\n\n\n\n\n\n\n\n\n\n\n\n\nLists can be concatanated by the + operator\n\n\n\n\n\n\nA very useful feature for lists in python is the slicing of lists. Slicing means, that we access only a range of elements in the list, i.e. element 3 to 7. This is done by inserting the starting and the ending element number separated by a colon (:) in the square brackets. The index numbers can be positive or negative again.\n\n\n\n\n\n\nInserting a second colon behind the ending element index together with a thrid number allows even to select only ever second or third element from a list.\n\n\n\n\n\n\nIt is sometimes also useful to reverse a list. This can be easily done with the reverse command.\n\n\n\n\n\n\nLists may be created in different ways. An empty list can be created by assigning emtpy square brackets to a variable name. You can append elements to the list with the help of the append command which has to be added to the variable name as shown below. This way of adding a particular function, which is part of a certain variable class is part of object oriented programming.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA list of numbers can be easily created by the range() command.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLists (and also tuples below) can be multidimensional as well, i.e. for an image. The individual elements may then be addressed by supplying two indices in two square brackets.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#tuples",
    "href": "lectures/lecture02/3_datatypes.html#tuples",
    "title": "Data Types",
    "section": "Tuples",
    "text": "Tuples\nTuples are also list, but immutable. That means, if a tuple has been once defined, it cannot be changed. Try to change an element to see the result.\n\n\n\n\n\n\nTuples may be unpacked, e.g. its values may be assigned to normal variables in the following way",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#dictionaries",
    "href": "lectures/lecture02/3_datatypes.html#dictionaries",
    "title": "Data Types",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries are like lists, but the elements of dictionaries are accessed in a different way than for lists. The elements of lists and arrays are numbered consecutively, and to access an element of a list or an array, you simply refer to the number corresponding to its position in the sequence. The elements of dictionaries are accessed by “keys”, which can be either strings or (arbitrary) integers (in no particular order). Dictionaries are an important part of core Python. However, we do not make much use of them in this introduction to scientific Python, so our discussion of them is limited.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#sets",
    "href": "lectures/lecture02/3_datatypes.html#sets",
    "title": "Data Types",
    "section": "Sets",
    "text": "Sets\nSets are like lists but have immutable unique entries, which means the elements can not be changed once defined. An emtpy set is created by the set() method.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou may add elements to a set with the add method:\nYou may also remove objects with the discard method:\n\n\n\n\n\n\nYou may also apply a variety of operation to sets checking their intersection, union or difference.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html",
    "href": "lectures/lecture02/04-summary02.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Matplotlib Plotting Cheat Sheet\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(width, height))\n\n\n\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\nplt.legend(['Label'], loc='best')\n\n\n\nplt.scatter(x, y, marker='o')\n\n\n\nplt.hist(data, bins=10, density=True)\n\n\n\nplt.plot(x, y1, 'b-', label='Line 1')\nplt.scatter(x, y2, color='r', label='Scatter')\nplt.legend()\n\n\n\nplt.savefig('filename.pdf')\n\n\n\nplt.errorbar(x, y, yerr=yerror, fmt='ro', ecolor='black')\n\n\n\nplt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)\n\n\n\nmasked_data = np.ma.masked_where(condition, data)\n\n\n\nplt.semilogx(x, y)  # Log scale on x-axis\nplt.semilogy(x, y)  # Log scale on y-axis\nplt.loglog(x, y)    # Log scale on both axes\n\n\n\nplt.subplot(rows, cols, plot_number)\n\n\n\nplt.contour(X, Y, Z, levels)\nplt.contourf(X, Y, Z, levels)  # Filled contour plot\n\n\n\nplt.imshow(data, extent=[xmin, xmax, ymin, ymax], cmap='colormap')\n\n\n\nfrom mpl_toolkits import mplot3d\nax = plt.axes(projection='3d')\nax.plot3D(x, y, z)\nax.scatter3D(x, y, z)\nax.plot_surface(X, Y, Z)\n\n\n\nplt.rcParams.update({'font.size': 12, 'lines.linewidth': 2})\nplt.tight_layout()\nRemember to always call plt.show() to display your plots!"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#matplotlib-plotting-cheat-sheet",
    "href": "lectures/lecture02/04-summary02.html#matplotlib-plotting-cheat-sheet",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Matplotlib Plotting Cheat Sheet\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(width, height))\n\n\n\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\nplt.legend(['Label'], loc='best')\n\n\n\nplt.scatter(x, y, marker='o')\n\n\n\nplt.hist(data, bins=10, density=True)\n\n\n\nplt.plot(x, y1, 'b-', label='Line 1')\nplt.scatter(x, y2, color='r', label='Scatter')\nplt.legend()\n\n\n\nplt.savefig('filename.pdf')\n\n\n\nplt.errorbar(x, y, yerr=yerror, fmt='ro', ecolor='black')\n\n\n\nplt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)\n\n\n\nmasked_data = np.ma.masked_where(condition, data)\n\n\n\nplt.semilogx(x, y)  # Log scale on x-axis\nplt.semilogy(x, y)  # Log scale on y-axis\nplt.loglog(x, y)    # Log scale on both axes\n\n\n\nplt.subplot(rows, cols, plot_number)\n\n\n\nplt.contour(X, Y, Z, levels)\nplt.contourf(X, Y, Z, levels)  # Filled contour plot\n\n\n\nplt.imshow(data, extent=[xmin, xmax, ymin, ymax], cmap='colormap')\n\n\n\nfrom mpl_toolkits import mplot3d\nax = plt.axes(projection='3d')\nax.plot3D(x, y, z)\nax.scatter3D(x, y, z)\nax.plot_surface(X, Y, Z)\n\n\n\nplt.rcParams.update({'font.size': 12, 'lines.linewidth': 2})\nplt.tight_layout()\nRemember to always call plt.show() to display your plots!"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#basic-setup",
    "href": "lectures/lecture02/04-summary02.html#basic-setup",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(width, height))"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#line-plots",
    "href": "lectures/lecture02/04-summary02.html#line-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.plot(x, y, 'bo-')  # Blue line with circle markers\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\nplt.legend(['Label'], loc='best')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#scatter-plots",
    "href": "lectures/lecture02/04-summary02.html#scatter-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.scatter(x, y, marker='o')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#histograms",
    "href": "lectures/lecture02/04-summary02.html#histograms",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.hist(data, bins=10, density=True)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#combined-plots",
    "href": "lectures/lecture02/04-summary02.html#combined-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.plot(x, y1, 'b-', label='Line 1')\nplt.scatter(x, y2, color='r', label='Scatter')\nplt.legend()"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#saving-figures",
    "href": "lectures/lecture02/04-summary02.html#saving-figures",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.savefig('filename.pdf')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#error-bars",
    "href": "lectures/lecture02/04-summary02.html#error-bars",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.errorbar(x, y, yerr=yerror, fmt='ro', ecolor='black')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#setting-plot-limits",
    "href": "lectures/lecture02/04-summary02.html#setting-plot-limits",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#masked-arrays",
    "href": "lectures/lecture02/04-summary02.html#masked-arrays",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "masked_data = np.ma.masked_where(condition, data)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#logarithmic-plots",
    "href": "lectures/lecture02/04-summary02.html#logarithmic-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.semilogx(x, y)  # Log scale on x-axis\nplt.semilogy(x, y)  # Log scale on y-axis\nplt.loglog(x, y)    # Log scale on both axes"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#multiple-subplots",
    "href": "lectures/lecture02/04-summary02.html#multiple-subplots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.subplot(rows, cols, plot_number)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#contour-plots",
    "href": "lectures/lecture02/04-summary02.html#contour-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.contour(X, Y, Z, levels)\nplt.contourf(X, Y, Z, levels)  # Filled contour plot"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#image-plots",
    "href": "lectures/lecture02/04-summary02.html#image-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.imshow(data, extent=[xmin, xmax, ymin, ymax], cmap='colormap')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#d-plots",
    "href": "lectures/lecture02/04-summary02.html#d-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "from mpl_toolkits import mplot3d\nax = plt.axes(projection='3d')\nax.plot3D(x, y, z)\nax.scatter3D(x, y, z)\nax.plot_surface(X, Y, Z)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#customization",
    "href": "lectures/lecture02/04-summary02.html#customization",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.rcParams.update({'font.size': 12, 'lines.linewidth': 2})\nplt.tight_layout()\nRemember to always call plt.show() to display your plots!"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html",
    "href": "lectures/lecture03/01-lecture03.html",
    "title": "Lecture 3",
    "section": "",
    "text": "Lists and arrays (introduction to numpy for numerical operations).\nBasic vector operations using numpy.\n\n\n\n\n\n\n\nNumpy Array\n\n\n\nThe NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a NumPy array are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type. For example, they might be all integers or all floating point numbers. NumPy arrays are more efficient than Python lists for storing and manipulating data.\n\n\n\n\n\n\n\n\n\n\nThere are a number of ways to initialize new numpy arrays, for example from\n\na Python list or tuples using np.array\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section of this course.\n\n\n\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function. This is demonstrated in the following cells:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms and shapes. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinspace\n\n\n\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50. The function linspace always includes the end points.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlogspace\n\n\n\nlogspace is doing equivelent things with logaritmic spacing. The function logspace generates an array of N points between decades 10^start and 10^stop. The form of the function is logspace(start, stop, N). If the third argument N is omitted, then N=50. The function logspace always includes the end points.\n\n\n\n\n\n\n\n\nOther types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\nmgrid\n\n\n\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows. The arguments are similar to arange and linspace.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiag\n\n\n\ndiag generates a diagonal matrix with the list supplied to it as the diagonal values. The values can be also offset from the main diagonal by using the optional argument k. If k is positive, the diagonal is above the main diagonal, if negative, below the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeros and ones\n\n\n\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1. The argument is a tuple with the dimensions of the matrix. For example, np.zeros((3,3)) creates a 3x3 matrix filled with zeros.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSlicing is the name for extracting part of an array by the syntax M[lower:upper:step]. When any of these are unspecified, they default to the values lower=0, upper=size of dimension, step=1. We can also use negative indices to count from the end of the array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining) and can be used in any of the three slicing parameters. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays. We can slice along each axis independently. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by the formula\n\\[\\begin{equation}\n  v_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n  \\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays can be reshaped into any form, which contains the same number of elements. For example, a 4-element array can be reshaped into a 2x2 array, or a 2x2 array can be reshaped into a 4-element array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones by repeating or stacking. Please try the individual functions yourself in your notebook. We wont discuss them in detail here.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConcatenate joins arrays along an existing axis. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhstack and vstack stack arrays horizontally and vertically. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAll kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below where a is an array of numbers from 0 to 9.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperation between multiple vectors allow in particular very quick operations. The operations address then elements of the same index. These operations are called vector operations since the concern the whole array at the same time. The product between two vectors results therefore not in a dot product, which gives one number but in an array of multiplied elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxxw\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulating and plotting the trajectory of a projectile under the influence of gravity (2D motion).\nIntroduction to vector addition and resolving vectors into components.\nVisualization: Plotting the path of the projectile and velocity vectors.\nHomework: Simulate projectile motion with air resistance (optional for advanced students)."
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#creating-numpy-arrays",
    "href": "lectures/lecture03/01-lecture03.html#creating-numpy-arrays",
    "title": "Lecture 3",
    "section": "",
    "text": "There are a number of ways to initialize new numpy arrays, for example from\n\na Python list or tuples using np.array\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section of this course.\n\n\n\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function. This is demonstrated in the following cells:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms and shapes. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinspace\n\n\n\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50. The function linspace always includes the end points.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlogspace\n\n\n\nlogspace is doing equivelent things with logaritmic spacing. The function logspace generates an array of N points between decades 10^start and 10^stop. The form of the function is logspace(start, stop, N). If the third argument N is omitted, then N=50. The function logspace always includes the end points.\n\n\n\n\n\n\n\n\nOther types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\nmgrid\n\n\n\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows. The arguments are similar to arange and linspace.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiag\n\n\n\ndiag generates a diagonal matrix with the list supplied to it as the diagonal values. The values can be also offset from the main diagonal by using the optional argument k. If k is positive, the diagonal is above the main diagonal, if negative, below the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeros and ones\n\n\n\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1. The argument is a tuple with the dimensions of the matrix. For example, np.zeros((3,3)) creates a 3x3 matrix filled with zeros."
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#manipulating-numpy-arrays",
    "href": "lectures/lecture03/01-lecture03.html#manipulating-numpy-arrays",
    "title": "Lecture 3",
    "section": "",
    "text": "Slicing is the name for extracting part of an array by the syntax M[lower:upper:step]. When any of these are unspecified, they default to the values lower=0, upper=size of dimension, step=1. We can also use negative indices to count from the end of the array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining) and can be used in any of the three slicing parameters. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays. We can slice along each axis independently. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by the formula\n\\[\\begin{equation}\n  v_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n  \\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays can be reshaped into any form, which contains the same number of elements. For example, a 4-element array can be reshaped into a 2x2 array, or a 2x2 array can be reshaped into a 4-element array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones by repeating or stacking. Please try the individual functions yourself in your notebook. We wont discuss them in detail here.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConcatenate joins arrays along an existing axis. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhstack and vstack stack arrays horizontally and vertically. Here are some examples:"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#applying-mathematical-functions",
    "href": "lectures/lecture03/01-lecture03.html#applying-mathematical-functions",
    "title": "Lecture 3",
    "section": "",
    "text": "All kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below where a is an array of numbers from 0 to 9.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperation between multiple vectors allow in particular very quick operations. The operations address then elements of the same index. These operations are called vector operations since the concern the whole array at the same time. The product between two vectors results therefore not in a dot product, which gives one number but in an array of multiplied elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxxw"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#application",
    "href": "lectures/lecture03/01-lecture03.html#application",
    "title": "Lecture 3",
    "section": "",
    "text": "Simulating and plotting the trajectory of a projectile under the influence of gravity (2D motion).\nIntroduction to vector addition and resolving vectors into components.\nVisualization: Plotting the path of the projectile and velocity vectors.\nHomework: Simulate projectile motion with air resistance (optional for advanced students)."
  },
  {
    "objectID": "lectures/lecture04/1_classes.html",
    "href": "lectures/lecture04/1_classes.html",
    "title": "Classes and Objects",
    "section": "",
    "text": "File as PDF\nA very useful programming concept of modern programming is object oriented programming. In all the programs we wrote till now, we have designed our program around functions i.e. blocks of statements which manipulate data. This is called the procedure-oriented way of programming.\nThere is another way of organizing your program which is to combine data and functionality and wrap it inside something called an object. This is called the object oriented programming paradigm, which will be useful especially for larger programs.\nClasses and objects are the two main aspects of object oriented programming. * A class creates a new type where objects are instances of the class."
  },
  {
    "objectID": "lectures/lecture04/1_classes.html#definition-of-classes",
    "href": "lectures/lecture04/1_classes.html#definition-of-classes",
    "title": "Classes and Objects",
    "section": "Definition of Classes",
    "text": "Definition of Classes\nWe create a new class using the class statement and the name of the class and a colon :. This is followed by an indented block of statements which form the body of the class.\nclass Classname:\n    statements ###\nIn the following example, we have an empty block which is indicated using the pass statement.\n\n\n\n\n\n\nYou can then create a new object of the class Colloid by The print command will just inform you about the memory address at which the object is stored."
  },
  {
    "objectID": "lectures/lecture04/1_classes.html#class-methods",
    "href": "lectures/lecture04/1_classes.html#class-methods",
    "title": "Classes and Objects",
    "section": "Class Methods",
    "text": "Class Methods\nMethods are functions that belong to a class.\n\nNote: The self parameter\nClass methods have an extra first parameter at beginning of the parameter list, but you do not give a value for this parameter when you call the method, Python will provide it. This particular variable refers to the object itself, and by convention, it is given the name self. Thus, even a method without arguments has a single argument:\nclass Colloid:\n    def type(self):\n        print('I am a plastic colloid')\n\n\n\n\n\n\n\n\n\nThe __init__ method\nThe __init__ method is run as soon as an object of a class is instantiated (i.e. created). The method is useful to do any initialization (i.e. passing initial values to your object) you want to do with your object. Notice the double underscores both at the beginning and at the end of the name.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBesides the __init__method, which is commonly called constructor, there is also the __del__ method, which is called b´when an object is deleted. We will use that further down.\n\n\nThe __str__ method\nThe __str__ method that is invoked when a simple string representation of the class is needed, as for example when printed."
  },
  {
    "objectID": "lectures/lecture04/1_classes.html#class-and-object-variables",
    "href": "lectures/lecture04/1_classes.html#class-and-object-variables",
    "title": "Classes and Objects",
    "section": "Class and object variables",
    "text": "Class and object variables\nThe data part, i.e. properties, are ordinary variables that are bound to the namespaces of the classes and objects. This means that these names are valid within the context of these classes and objects only.\nThere are two types of fields - class variables and object variables which are classified depending on whether the class or the object owns the variables respectively.\n\nClass variables are shared - they can be accessed by all instances of that class. There is only one copy of the class variable and when any one object makes a change to a class variable, that change will be seen by all the other instances.\nObject variables are owned by each individual object/instance of the class. In this case, each object has its own copy of the field i.e. they are not shared and are not related in any way to the field by the same name in a different instance.\n\nHere is an example:"
  },
  {
    "objectID": "lectures/lecture04/1_quantum_mechanics.html",
    "href": "lectures/lecture04/1_quantum_mechanics.html",
    "title": "Quantum Mechanics",
    "section": "",
    "text": "In the last lecture, we have modeled electromagnetic waves not by solving the wave equation, but by taking the solutions of wave equations like a plane wave or a spherical wave. Today we will solve a wave equation, but not for electromagnetic waves, but for matter waves. We will solve the stationary Schrödinger equation with the implicit solution scheme, which we have already applied for the diffusion equation. With the help of that we will tackle the particle in a box, the harmonic oscillator and the periodic potential. All of these problems have also analytical solutions, thus we do not need the numerical solution in principle. But it will give us some practice on how to tackle such problems. As not all of you might be familiar with the physical description of quantum mechanics, we will give a short introduction into this field first.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import eigsh\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n# default values for plotting\nplt.rcParams.update({'font.size': 12,\n                     'axes.titlesize': 18,\n                     'axes.labelsize': 16,\n                     'axes.labelpad': 14,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'xtick.labelsize' : 16,\n                     'ytick.labelsize' : 16,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})"
  },
  {
    "objectID": "lectures/lecture04/1_quantum_mechanics.html#quantum-mechanics-in-a-nutshell",
    "href": "lectures/lecture04/1_quantum_mechanics.html#quantum-mechanics-in-a-nutshell",
    "title": "Quantum Mechanics",
    "section": "Quantum Mechanics in a Nutshell",
    "text": "Quantum Mechanics in a Nutshell\nQuantum Mechanics assumes that all particles propagate as waves. They are described by a wavefunction \\(\\Psi(x,t)\\). A quantum mechanical object thus posseses an amplitude and a phase which propagate in space and time. One could see the wavefunction in analogy to the electric field \\(\\vec{E}(x)\\) of an electromagnetic wave. As the square of the electric field describes the propagation of energy of a wave, the square magnitude of the wavefunction, i.e. \\(|\\Psi(x,t)|^2\\), describes the propagation of probability density of the quantum mechanical wave. The wavefunction itself is thus just the probability amplitude.\n\nTime dependent Schrödinger equation\nThe dynamics of a quantum mechanical wave is described,for example, by the time dependent Schrödinger equation\n\\[\\begin{equation}\n-i\\hbar\\frac{\\partial \\Psi(x,t)}{\\partial t} = \\left ( \\frac{-\\hbar^2 }{2m}\\frac{\\partial^2}{\\partial x^2}+V(x,t) \\right ) \\Psi(x,t)\n\\end{equation}\\]\nwhis is written here for one dimension only.\nThe bracket on the right side of the above equation contains the so-called Hamilton operator \\(\\hat{H}\\). The Hamilton operator \\(\\hat{H}\\) contains the energy operators for the kinetic and potential energies and represents the total energy of the system.\n\\[\\begin{equation}\n\\hat{H}=\\left ( \\frac{-\\hbar^2 }{2m}\\frac{\\partial^2}{\\partial x^2}+V(x,t) \\right )\n\\end{equation}\\]\n\n\nStationary Schrödinger equation\nOur first problems will be stationary problems. We will not ask for the temporal development of the quantum object. We will rather ask, what solutions without time dependence are possible. In general this is much like the question asking what kind of standing waves are possible on a string or in an optical resonator. In quantum mechanics the boundaries, which define the standing waves are formed by the potential energy \\(V(x)\\).\nWe therefore also need the stationary Schrödinger equation, where the left side of the time dependent Schrödinger equation does not depend on time, hence is constant in time. This stationary (time-independent) Schrödinger equation is\n\\[\\begin{equation}\n\\hat{H}\\Psi(x)=E\\Psi(x)\n\\end{equation}\\]\nThe Hamilton operator \\(\\hat{H}\\) gives a recipe how to calculate the energies for a given wavefunction \\(\\Psi(x)\\) in terms of derivates or multiplications by functions. If this recipe reduces to a multiplication of the wave function with a number \\(E\\), then these wavefunctions are eigenfunction of the Hamilton operator and the values of \\(E\\) are the eigenvalues of the problem, i.e. the time-independent solutions of this differential equation."
  },
  {
    "objectID": "lectures/lecture04/1_quantum_mechanics.html#recap-implicit-solution",
    "href": "lectures/lecture04/1_quantum_mechanics.html#recap-implicit-solution",
    "title": "Quantum Mechanics",
    "section": "Recap: Implicit Solution",
    "text": "Recap: Implicit Solution\nAccording to our above description, the Hamilton operator \\(\\hat{H}\\) contains two parts, a second derivative in the position, which represents the kinetic energy and the potential energy operator \\(V(x)\\), which is in the simplest case just a function of \\(x\\).\n\\[\\begin{equation}\n\\left ( \\frac{-\\hbar^2 }{2m}\\frac{\\partial^2}{\\partial x^2}+V(x) \\right ) \\Psi(x)=E\\Psi(x)\n\\end{equation}\\]\nSince we want to apply our implicit solution scheme (Cranck Nicolson), we want to represent both parts as matrices.\n\nKinetic energy\nWe remember that we can write the second derivative of our wavefunction \\(\\Psi(x)\\) in the finite difference approximation as\n\\[\\begin{equation}\n\\Psi^{''}(x)=\\frac{\\Psi(x+\\delta x)-2\\Psi(x)+\\Psi(x-\\delta x)}{\\delta x^{2}}\n\\end{equation}\\]\nIf we want to evaluate the wavefunction at certain positions \\(x_{i}\\), then this second derivative translates into\n\\(T\\Psi=\\frac{d^2}{dx^2}\\Psi=\\frac{1}{\\delta x^2}\n\\begin{bmatrix}\n-2 & 1  & 0 & 0 & 0 & 0\\\\\n1 & -2 & 1 & 0 & 0 & 0\\\\\n0 & 1  & -2 & 1 & 0 & 0\\\\\n0 & 0  & 1  & -2 & 1 & 0\\\\\n0 & 0  & 0  &  1 & -2 & 1\\\\\n0 & 0  & 0  &  0 &  1 & -2\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}\\)\nif we just use 6 positions. Please remember, that in the version above, we have imposed already boundary conditions in the first and the last row, which are \\(\\Psi(x_{0})=0\\) and \\(\\Psi(x_{7})=0\\). If we multiply this matrix by \\(-\\hbar^{2}/2m\\), we obtain the kinetic energy for an object of mass \\(m\\).\n\n\nPotential energy\nThe potential energy values are just values at the diagonal of the matrix\n\\(V\\Psi=\n\\begin{bmatrix}\nV(x_{1}) & 0  & 0 & 0 & 0 & 0\\\\\n0 & V(x_{2}) & 0 & 0 & 0 & 0\\\\\n0 & 0  & V(x_{3}) & 0 & 0 & 0\\\\\n0 & 0  & 0  & V(x_{4}) & 0 & 0\\\\\n0 & 0  & 0  &  0 & V(x_{5}) & 0\\\\\n0 & 0  & 0  &  0 &  0 & V(x_{6})\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}\\)\nan you may insert the specific potential energy values for your particular problem here.\nOur final problem \\(\\hat{H}\\Psi=E\\Psi\\) will thus have the following shape\n\\[\\begin{equation}\n\\begin{bmatrix}\n-2+V(x_{1}) & 1  & 0 & 0 & 0 & 0\\\\\n1 & -2+V(x_{2}) & 1 & 0 & 0 & 0\\\\\n0 & 1 & -2+V(x_{3})  & 1 & 0 & 0 \\\\\n0 &0 & 1  & -2+V(x_{4})  & 1 & 0 \\\\\n0 & 0 & 0  & 1  &  -2+V(x_{5}) & 1 \\\\\n0 & 0 & 0  & 0  &  1 &  -2+V(x_{6}) \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}=E\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}\n\\end{equation}\\]\nwhere I skipped the prefactor \\(-\\hbar^2/2m\\), to fit the matrices on one line. Yet I did not succeed. This is the final system of coupled equations which we can supply to any matrix solver. We will use a solver from the scipy.linalg module. In case we have special boundary conditions, we need to take them into account and replace the first and the last line for example with the particular boundary conditions."
  },
  {
    "objectID": "lectures/lecture04/2_particle_in_a_box.html",
    "href": "lectures/lecture04/2_particle_in_a_box.html",
    "title": "Particle in a box",
    "section": "",
    "text": "Let’s apply the whole thing to the problem of a particle in a box. This means, we look at a quantum mechanical object in a potential well.\nThe problem is sketched below.\nWe need to define this rectangular box with zero potential energy inside the box and finite potential energy outside. Since the quantum mechanical object is a wave, we expect that only certain standing waves of particular wavelength can exist inside the box. These waves are connected to certain probability densities of finding the particle at certain positions and specific energy values. These are the energy levels, which are often characteristic of the quantum realm."
  },
  {
    "objectID": "lectures/lecture04/2_particle_in_a_box.html#definition-of-the-problem",
    "href": "lectures/lecture04/2_particle_in_a_box.html#definition-of-the-problem",
    "title": "Particle in a box",
    "section": "Definition of the problem",
    "text": "Definition of the problem\nBefore we start, we need to define some quantities:\n\nwe will study a box of d=1 nm in width in a domain of L=5 nm\nwe will use N=1001 points for our \\(x_{i}\\)\nour potential energy shall have a barrier height of 1 eV\nthe potential energy inside the box will be zero\n\n\n\n\n\n\n\n\nPotential energy\nWe first define the diagonal potential energy matrix.\n\n\n\n\n\n\n\n\nKinetic energy\nNext are the derivatives of the kinetic energy matrix.\n\n\n\n\n\n\nAn finally the total Hamilton operator matrix.\n\n\n\n\n\n\n\n\nSolution\nThe last step is to solve the system of coupled equations usering the eigsh method of the scipy module. We can already anticipate that we get multiple solution, e.g. multiple wavelength that fit inside the box. So there must be a certain number of eigenvalues. The method eigsh allows to specify the number of eigenvalues and eigenfunctions \\(n\\) we would like to calculate.\n\n\n\n\n\n\n\n\nPlotting\n\n\n\n\n\n\nThe diagram shows the corresponding energy states (the eigenvalues of the solution) and the value \\(|\\Psi|^2\\), which gives the probability to find the particle inside the box. The latter shows, that in contrast to what we expect from classical theory, where we would expect the particle to be with equal probability found at all positions inside the box, we get in quantum mechanics only certain positions at which we would find the particle. Also, the higher the energy state, the more equally is the particle distributed over the box. For a finite box depth, however, we get only a finite number of energy states in which the particle is bound. A second interesting observation here is that the particle has a finite probability to enter the potential barrier. Especially for the higher energy states, the wavefunction decays exponentially into the barrier. This is similar to the evanescent wave we studied during the last lecture.\n\n\nEnergies of bound states\nIn the case of the particle in a box only certain energies are allowed. The energies which correspond to these distributions are increasing nonlinearly with its index. Below we plot the energy as a function of the index of the energy value. This index is called quantum number as we can enumerate the solutions in quantum mechanics. The graph shows that the energy of the bound states increases with the square of the quantum number, i.e. \\(E_{n}\\propto n^2\\)."
  },
  {
    "objectID": "lectures/lecture04/2_particle_in_a_box.html#where-to-go-from-here",
    "href": "lectures/lecture04/2_particle_in_a_box.html#where-to-go-from-here",
    "title": "Particle in a box",
    "section": "Where to go from here?",
    "text": "Where to go from here?\nYou may try at this point to create two closely spaced potential wells, e.g. two of 1 nm width with a distance of 0.1 nm or with a distance of 2 nm. You should see that for large distances of the wells the energy values in the individual wells are the same, while for the smaller distance they split up into two due to the interaction.\n\n\n\nDouble Well"
  },
  {
    "objectID": "seminars/seminar01/01-seminar01.html",
    "href": "seminars/seminar01/01-seminar01.html",
    "title": "Seminar 1",
    "section": "",
    "text": "Calculate the average of all of the integers from 1 to 10.\n\n\n\n\n\n\n\nuse the sum() and len() functions\nn = range(1, 11)\n\n\n1n = range(1, 11)\n2sum(n)/len(n)\n\n1\n\ncreate the range of numbers from 1 to 10.\n\n2\n\ncalculate the sum of the numbers and divide by the number of elements in the list."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "course-info/schedule.html",
    "href": "course-info/schedule.html",
    "title": "Zeitplan für den Kurs",
    "section": "",
    "text": "Der Kurs wird wöchentlich mit dem Zeitplan der Vorlesungen aktualisiert. Erwarten Sie also jeden\nDienstag ab 15. Oktober 2024, jeweils um 11:15\neine neue Vorlesung und eine neue Aufgabe. Bitte nutzen Sie den ersten Dienstag, um sich mit der Webseite vertraut zu machen. Die Vorlesung 1 und die Aufgabenstellung 1 folgen am XX. Oktober 2024.\nErfahrungsgemäß werden die besten Ergebnisse erzielt, wenn Sie bei den Vorlesungen im Hörsaal anwesend sind. Das gesamte Material wird jedoch auch online zur Verfügung stehen, sodass Sie jederzeit darauf zugreifen können, um zu lernen, wann immer es Ihnen passt."
  },
  {
    "objectID": "course-info/resources.html",
    "href": "course-info/resources.html",
    "title": "Quellen",
    "section": "",
    "text": "Es gibt eine Menge weiterer gut strukturierter Ressourcen zu Python im Netz. Nachfolgend finden Sie nur eine sehr kleine Auswahl.",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#molecular-nanophotonics-group",
    "href": "course-info/resources.html#molecular-nanophotonics-group",
    "title": "Quellen",
    "section": "Molecular Nanophotonics Group",
    "text": "Molecular Nanophotonics Group\n\nMolecular Nanophotonics Group Website\nHypothesis Annotation Tool Invite",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#additional-advanced-courses",
    "href": "course-info/resources.html#additional-advanced-courses",
    "title": "Quellen",
    "section": "Additional Advanced Courses",
    "text": "Additional Advanced Courses\n\nRosenow Group (Theory), Master Course on Statistical Mechanics of Deep Learning",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#python-documentation",
    "href": "course-info/resources.html#python-documentation",
    "title": "Quellen",
    "section": "Python Documentation",
    "text": "Python Documentation\n\nPython\nMatplotlib\nPandas",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#python-tutorials",
    "href": "course-info/resources.html#python-tutorials",
    "title": "Quellen",
    "section": "Python Tutorials",
    "text": "Python Tutorials\n\nIntroduction to Python for Science\nNice MatPlotLib tutorial",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#julia-tutorial",
    "href": "course-info/resources.html#julia-tutorial",
    "title": "Quellen",
    "section": "Julia Tutorial",
    "text": "Julia Tutorial\n\nJulia Programming Language",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#pluto-notebook",
    "href": "course-info/resources.html#pluto-notebook",
    "title": "Quellen",
    "section": "Pluto NoteBook",
    "text": "Pluto NoteBook\n\nPluto GitHub Webpage",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/how_to_quiz.html",
    "href": "course-info/how_to_quiz.html",
    "title": "Interactive Python Quiz",
    "section": "",
    "text": "In this quiz, you can write and execute Python code directly in your browser.\n\n\nWrite a function square(n) that returns the square of a number.\n\n\n\n\n\n# Write your Python code here\ndef square(n):\n    return n * n\n\nprint(square(5))\n\n\nRun Code"
  },
  {
    "objectID": "course-info/how_to_quiz.html#question-1",
    "href": "course-info/how_to_quiz.html#question-1",
    "title": "Interactive Python Quiz",
    "section": "",
    "text": "Write a function square(n) that returns the square of a number.\n\n\n\n\n\n# Write your Python code here\ndef square(n):\n    return n * n\n\nprint(square(5))\n\n\nRun Code"
  },
  {
    "objectID": "course-info/intructors.html",
    "href": "course-info/intructors.html",
    "title": "Instructor",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Course Info",
      "Vorlesender"
    ]
  },
  {
    "objectID": "course-info/intructors.html#prof.-dr.-frank-cichos",
    "href": "course-info/intructors.html#prof.-dr.-frank-cichos",
    "title": "Instructor",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Course Info",
      "Vorlesender"
    ]
  },
  {
    "objectID": "course-info/assignments.html",
    "href": "course-info/assignments.html",
    "title": "Übungsaufgaben",
    "section": "",
    "text": "Es werden insgesamt 6 Übungsblätter zur Verfügung gestellt. Die Übungsblätter sind Teil der Prüfungsleistung! Die Übungsblätter werden nicht benotet, aber die Bearbeitung ist für den erfolgreichen Abschluss des Moduls erforderlich. Genauere Informationen zur Wertung der Übungsblätter finden sie auf der Seite zur Prüfung.\n\nBereitstellung und Abgabe der Übungsaufgaben\n\nVeröffentlichung: Jeden Dienstag um 13:00 Uhr\nAbgabefrist: Bis zum folgenden Dienstag um 12:00 Uhr\nBearbeitungszeitraum: Eine Woche (minus eine Stunde)\nPlattform: Moodle der Universität\n\nSowohl für die Bearbeitung als auch für die Abgabe\n\nWichtig:\n\nAchten Sie auf die pünktliche Abgabe innerhalb der angegebenen Frist.\nNach Ablauf der Frist ist die Aufgabe nicht mehr verfügbar und kann nicht mehr eingereicht werden.\nAchten sie darauf, dass mehrmaliges Einreichen derselben Aufgabe die Punktzahl mit jeder Einreichung um 10% verringert",
    "crumbs": [
      "Course Info",
      "Übungsaufgaben"
    ]
  },
  {
    "objectID": "course-info/website.html",
    "href": "course-info/website.html",
    "title": "Diese Webseiten",
    "section": "",
    "text": "Diese Webseiten\nDiese Website enthält alle Informationen, die für unseren Kurs Einführung in die Modellierung Physikalischer Prozesse erforderlich sind. Sie werden hier jede Woche eine neue Vorlesung und eine neue Aufgabe finden. Die Vorlesungshefte werden von Videos begleitet, die den Inhalt der Vorlesung auf Englisch erklären, aber Sie können auch mit dem Lesen auskommen. Die Vorlesungen in Person, werden auf Deutsch stattfinden. Von diesen Webseiten aus werden Sie zu verschiedenen Ressourcen geführt, die Sie nutzen können, um das Programmieren in Python zu lernen. Dabei werden wir einige großartige Tools aus dem Internet nutzen, wie\n\nGoogle Colab Dienst, um auch Jupyter Notebooks (https://colab.research.google.com) zu hosten. Das Google Colab-Projekt bietet eine nützliche Umgebung zur gemeinsamen Nutzung von Notebooks.\n\n\n\ngoogle colab screen\n\n\nWenn Sie die folgende Website besuchen, werden Sie an mehreren Stellen das folgende Symbol sehen.\n![Substitution Name1]\nDieses Symbol zeigt an, dass diese Webseite auf einem Jupyter Notebook basiert. Anstatt nur die Website zu betrachten, können Sie auf das Symbol klicken und der Google Colab-Dienst wird geöffnet, damit Sie das Notizbuch interaktiv nutzen können. Google Colab öffnet sich viel schneller als myBinder, aber die Notizbücher sind für die Arbeit mit myBinder gemacht und nicht alle Funktionen funktionieren mit Colab. Ich arbeite jedoch an der Kompatibilität.\nGitHub and GitHub Pages Dienst zum Hosting von Websites (https://github.com). GitHub ist ein großartiger Ort, um Ihre kollaborativen Coding-Projekte einschließlich Versionskontrolle zu hosten. In der oberen rechten Ecke finden Sie auch einen Link zum GitHub-Repository, in dem die Notebooks gehostet werden.\n\n\n\ngithub screen\n\n\nAnaconda Jupyter package für Notebooks auf dem eigenen Computer (https://www.anaconda.com/distribution/). Das Paket anaconda stellt Ihnen die Jupyter Notebook-Umgebung einschließlich Python zur Verfügung. Wenn Sie Jupyter zu Hause ohne Online-Zugang verwenden möchten, ist dies ein gutes Paket zur Installation.\n\n\n\nanaconda screen"
  },
  {
    "objectID": "course-info/exam.html",
    "href": "course-info/exam.html",
    "title": "Prüfung",
    "section": "",
    "text": "Die Prüfungsleistung in diesem Modul ist eine Portfolio-Prüfung und besteht aus zwei Portfolio-Teilen:\n\nÜbungsaufgaben:\n\n6 Serien von Aufgaben, die nicht benotet werden\nMindestens 50% der Gesamtpunktzahl aller Übungsaufgaben muss erreicht werden\n\nZwei Tests:\n\nJeder Test dauert 45 Minuten\nFinden in Person während zwei separater Übungsseminare statt\nDie Tests werden vorher angekündigt\nDie Punkte beider Tests werden addiert und ergeben eine Gesamtnote\n\n\nWichtige Hinweise: - Beide Portfolio-Teile (Übungsaufgaben und Tests) müssen bestanden werden, um das Modul erfolgreich abzuschließen. - Die Gesamtnote der Tests entspricht der Abschlussnote des Moduls.",
    "crumbs": [
      "Course Info",
      "Prüfungen"
    ]
  },
  {
    "objectID": "course-info/exam.html#erstteilnehmer",
    "href": "course-info/exam.html#erstteilnehmer",
    "title": "Prüfung",
    "section": "",
    "text": "Die Prüfungsleistung in diesem Modul ist eine Portfolio-Prüfung und besteht aus zwei Portfolio-Teilen:\n\nÜbungsaufgaben:\n\n6 Serien von Aufgaben, die nicht benotet werden\nMindestens 50% der Gesamtpunktzahl aller Übungsaufgaben muss erreicht werden\n\nZwei Tests:\n\nJeder Test dauert 45 Minuten\nFinden in Person während zwei separater Übungsseminare statt\nDie Tests werden vorher angekündigt\nDie Punkte beider Tests werden addiert und ergeben eine Gesamtnote\n\n\nWichtige Hinweise: - Beide Portfolio-Teile (Übungsaufgaben und Tests) müssen bestanden werden, um das Modul erfolgreich abzuschließen. - Die Gesamtnote der Tests entspricht der Abschlussnote des Moduls.",
    "crumbs": [
      "Course Info",
      "Prüfungen"
    ]
  },
  {
    "objectID": "course-info/exam.html#wiederholer",
    "href": "course-info/exam.html#wiederholer",
    "title": "Prüfung",
    "section": "Wiederholer",
    "text": "Wiederholer\nFür Studierende, die das Modul bereits im WS 2023/24 belegt haben und nun wiederholen:\n\nÜbungsaufgaben:\n\nWenn Sie im WS 2023/24 ≥50% erreicht haben: Nur Projektabgabe erforderlich\nWenn Sie im WS 2023/24 &lt;50% erreicht haben: Übungsaufgaben und Projektabgabe erforderlich\nEine Liste der erreichten Übungspunkte wird im internen Bereich der MONA Webseite veröffentlicht\n\nEinschreibung:\n\nErneute Moduleinschreibung nicht notwendig\nFür Moodle-Zugang: Kontaktieren Sie Andrea Kramer per Uni-E-Mail\n\nProjektabgabe für Wiederholer:\n\nFrist: 12.03.2025, 13:00 Uhr\nSpätere Abgaben werden nicht berücksichtigt",
    "crumbs": [
      "Course Info",
      "Prüfungen"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EMPP 2024",
    "section": "",
    "text": "Willkommen zum Kurs Einführung in die Modellierung Physikalischer Prozesse!\nDie Programmiersprache Python ist für alle Arten von wissenschaftlichen und technischen Aufgaben nützlich. Sie können mit ihr Daten analysieren und darstellen. Sie können mit ihr auch wissenschaftliche Probleme numerisch lösen, die analytisch nur schwer oder gar nicht zu lösen sind. Python ist frei verfügbar und wurde aufgrund seines modularen Aufbaus um eine nahezu unendliche Anzahl von Modulen für verschiedene Zwecke erweitert.\nDieser Kurs soll Sie in die Programmierung mit Python einführen. Er richtet sich eher an den Anfänger, wir hoffen aber, dass er auch für Fortgeschrittene interessant ist. Wir beginnen den Kurs mit einer Einführung in die Jupyter Notebook-Umgebung, die wir während des gesamten Kurses verwenden werden. Danach werden wir eine Einführung in Python geben und Ihnen einige grundlegende Funktionen zeigen, wie z.B. das Plotten und Analysieren von Daten durch Kurvenanpassung, das Lesen und Schreiben von Dateien, was einige der Aufgaben sind, die Ihnen während Ihres Physikstudiums begegnen werden. Wir zeigen Ihnen auch einige fortgeschrittene Themen wie die Animation in Jupyter und die Simulation von physikalischen Prozessen in\nMechanik Elektrostatik Wellen Optik Falls am Ende des Kurses Zeit bleibt, werden wir auch einen Blick auf Verfahren des maschinellen Lernens werfen, das mittlerweile auch in der Physik zu einem wichtigen Werkzeug geworden ist.\nWir werden keine umfassende Liste von numerischen Simulationsschemata präsentieren, sondern die Beispiele nutzen, um Ihre Neugierde zu wecken. Da es leichte Unterschiede in der Syntax der verschiedenen Python-Versionen gibt, werden wir uns im Folgenden immer auf den Python 3-Standard beziehen.\nDer Kurs wird auf Deutsch gehalten werden. Die Webseiten, die Sie für den Überblick zu Python zur Verfügung gestellt bekommen, werden allerdings auf Englisch sein. Übungsaufgaben werden werden auf Deutsch gestellt.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "tt.html",
    "href": "tt.html",
    "title": "Introduction to Python and Basic Calculations",
    "section": "",
    "text": "A Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and imas,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org."
  },
  {
    "objectID": "tt.html#what-is-jupyter-notebook",
    "href": "tt.html#what-is-jupyter-notebook",
    "title": "Introduction to Python and Basic Calculations",
    "section": "",
    "text": "A Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and imas,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org."
  },
  {
    "objectID": "tt.html#key-components-of-a-notebook",
    "href": "tt.html#key-components-of-a-notebook",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Key Components of a Notebook",
    "text": "Key Components of a Notebook\nThe Jupyter Notebook combines three components:\n\n\n\n\n\n\nNotebook editor\n\n\n\nThe Notebook editor is an interactive application for writing and running code interactively and editing notebook documents. If you run Jupyter on a server, you will be using Jupyter’s web application or JupyterLab, which is a more advanced version of the notebook editor.\n\n\nThe Notebook editor enables you to\n\nEdit code in individual cell\nRun code in individuall cells in arbitrary oder and display results of the computation in various formats (HTML, LaTeX, PNG, SVG, PDF)\nCreate and use interactive JavaScript widgets, which bind interactive user interface controls and visualizations to reactive kernel side computations.\nAdd documentation text using Markdown markup language, including LaTeX equations\n\n\n\n\n\n\n\nKernels\n\n\n\nKernels are separate processes started by Jupyter on your server, that runs users’ code in a given language and returns output back to the notebook web application. The kernel also handles things like computations for interactive widgets, tab completion and introspection.\n\n\nThe Jupyter notebook is not bound to any specific programming language, but can be used for almost any type of language. Each Jupyter notebook starts a server application that is connected to a kernel that runs the code in the notebook. This kernel is dedicated to a specific programming language. Thus installing different kernels 100+ languages allows you to execute code in Python, Julia, R, Ruby, Haskell, Scala, and many others.\nYet, the default kernel runs Python code. The notebook provides a simple way for users to pick which of these kernels is used for a given notebook. Each of these kernels communicate with the notebook editor using JSON over ZeroMQ/WebSockets message protocol that is described here. Most users don’t need to know about these details, but it helps to understand that “kernels run code”.\n\n\n\n\n\n\nNotebook documents\n\n\n\nSelf-contained documents that contain a representation of all content visible in the notebook editor, including inputs and outputs of the computations, markdown text, equations, images, and rich media representations of objects. Each notebook document has its own kernel.\n\n\nNotebook documents, or notebooks, contain the inputs and outputs of an interactive session as well as documentation text that accompanies the code but is not meant for execution.\nA notebook is just a file on your server’s filesystem with a .ipynb extension. This allows you to share your notebook easily.\nNotebooks consist of a linear sequence of cells. There are three basic cell types:\n\nCode cells: Input and output of live code that is run in the kernel.\nMarkdown cells: Narrative text with embedded LaTeX equations.\nRaw cells: Unformatted text that is included, without modification, when notebooks are converted to different formats using nbconvert.\n\nInternally, notebook documents are JSON text files with binary data encoded in base64. This allows them to be read and manipulated programmatically by any programming language.\nNotebooks can be exported to different static formats including HTML, reStructeredText, LaTeX, PDF, and slide shows (reveal.js) using Jupyter’s nbconvert utility.\nFurthermore, any notebook document available from a public URL on or GitHub can be shared via nbviewer. This service loads the notebook document from the URL and renders it as a static web page. The resulting web page may thus be shared with others without their needing to install the Jupyter Notebook."
  },
  {
    "objectID": "tt.html#using-the-notebook-editor",
    "href": "tt.html#using-the-notebook-editor",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Using the Notebook Editor",
    "text": "Using the Notebook Editor\nA Jupyter Notebook provides an interface with essentially two modes\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab, which we are using on myBinder, this will look like that\n\nEdit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area:\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor.\n\n\nCommand mode\nCommand mode is indicated by a grey cell border:\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\nKeyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor. Thus, in edit mode there are relatively few shortcuts. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\nRunning code in your notebook\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\nv = 23752636\nprint(v)\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below."
  },
  {
    "objectID": "tt.html#managing-the-kernel",
    "href": "tt.html#managing-the-kernel",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Managing the kernel",
    "text": "Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.\nEntering code is pretty easy. You just have to click into a cell and type the commands you want to type. If you have multiple lines of code, just press enter at the end of the line and start a new one.\n\ncode blocks Python identifies blocks of codes belonging together by its identation. This will become important if you write longer code in a cell later. To indent the block, you may use either whitespaces or tabs.\ncomments Comments can be added to annotate the code, such that you or someone else can understand the code.\n\nComments in a single line are started with the # character at in front of the comment.\nComments over multiple lines can be started with '''and end with the same '''. They are used as docstrings to provide a help text.\n\n\n\n# typical function\n\ndef function(x):\n    ''' function to calculate a function\n    arguments:\n        x ... float or integer value\n    returns:\n        y ... two times the integer value\n    '''\n    y=2*x # don't forget the identation of the block\n    return(y)\n\nhelp(function)"
  },
  {
    "objectID": "tt.html#entering-markdown",
    "href": "tt.html#entering-markdown",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Entering Markdown",
    "text": "Entering Markdown\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://daringfireball.net/projects/markdown/\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\nMarkdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold.\nYou can build nested itemized or enumerated lists:\n\nfirst item\n\nfirst subitem\n\nfirst subsubitem\n\nsecond subitem - first subitem of second subitem - second subitem of second subitem\n\nsecond item\n\nfirst subitem\n\nthird item\n\nfirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\nHere is a blockquote:\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one– and preferably only one –obvious way to do it. Although that way may not be obvious at first unless you’re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea – let’s do more of those!\n\nAnd shorthand for links:\nJupyter’s website\n\n\nHeadings\nYou can add headings by starting a line with one (or multiple) # followed by a space, as in the following example:\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\nEmbedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\nor other languages:\nif (i=0; i&lt;n; i++) {\n  printf(\"hello %d\\n\", i);\n  x += 4;\n}\n\n\nLaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\nImages\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\nfrom IPython.display import Image, display;\nimport ssl\nfrom urllib.request import urlopen\n\n# URL of the image\nurl = \"https://github.com/fcichos/CompSoft23/raw/master/source/notebooks/Intro/img/particle.png\"\n\n# Create an SSL context that does not verify certificates\nssl._create_default_https_context = ssl._create_unverified_context\n\n# Open the URL and display the image\nwith urlopen(url) as response:\n    display(Image(response.read()))\n\n\ndisplay(Image(filename='img/particle.png'))\n\n\n\nVideos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.\n\nfrom IPython.display import YouTubeVideo\nYouTubeVideo('QlLx32juGzI',width=600)\n\n\n\nPython Basics\n\nVariables and data types (integers, floats, strings).\nBasic arithmetic operations (+, -, *, /, **)."
  },
  {
    "objectID": "tt.html#introduction-to-variables",
    "href": "tt.html#introduction-to-variables",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Introduction to Variables",
    "text": "Introduction to Variables\n\nSymbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter.\nBy convention, variable names typically start with a lower-case letter, while Class names start with a capital letter.\n\n\n\n\n\n\nWarning\n\n\n\nNote: Reserved Keywords\nThere are a number of Python keywords that cannot be used as variable names. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\nVariable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n# variable assignments\nx = 1.0\nmy_favorite_variable = 12.2\nx\n\n1.0\n\n\nAlthough not explicitly specified, a variable does have a type associated with it. The type is derived from the value that was assigned to it.\n\ntype(x)\n\nfloat\n\n\nIf we assign a new value to a variable, its type can change.\n\nx = 1\n\n\ntype(x)\n\nint\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError:\n\n#print(g)"
  },
  {
    "objectID": "tt.html#number-types",
    "href": "tt.html#number-types",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Number Types",
    "text": "Number Types\n\nOverview of Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers.\n\n\nIntegers\n\nInteger Representation: Numbers without a decimal point are treated as integers.\n\n\nx = 1\ntype(x)\n\nint\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n0b1010111110  # Binary\n0x0F          # Hexadecimal\n\n15\n\n\n\n\nFloating Point Numbers\n\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\nx = 3.141\ntype(x)\n\nfloat\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n1.7976931348623157e+308 * 2  # Output: inf\n\ninf\n\n\n\n\nComplex Numbers\n\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\nc = 2 + 4j\ntype(c)\n\ncomplex\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\nprint(c.real)\nprint(c.imag)\n\n2.0\n4.0\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.\n\n\nc = c.conjugate()\nprint(c)\n\n(2-4j)"
  },
  {
    "objectID": "tt.html#type-conversion",
    "href": "tt.html#type-conversion",
    "title": "Introduction to Python and Basic Calculations",
    "section": "Type Conversion",
    "text": "Type Conversion\n\nImplicit Type Conversion\n\nAutomatic Conversion: Python automatically converts types during operations.\n\n\ninteger_number = 123\nfloat_number = 1.23\nnew_number = integer_number + float_number\ntype(new_number)\n\n\n\nExplicit Type Conversion\n\nManual Conversion: Use functions like int(), float(), and str() to explicitly convert types.\n\n\nnum_string = \"12\"\nnum_string = int(num_string)\ntype(num_string)\n\n\nConverting Between Types:\n\n\nx = 5 / 2\nx = int(x)\nz = complex(x)\n\n\nHandling Complex Numbers:\n\nComplex numbers cannot be directly converted to floats or integers; extract the real or imaginary part first.\n\n\n\ny = bool(z.real)\nprint(z.real, \" -&gt; \", y, type(y))\n\n\n\nApplication\n\n# 1. Converting Units of Distance\n# Distance in kilometers\ndistance_km = 5.0\n\n# Conversion factor from kilometers to meters\nconversion_factor = 1000\n\n# Convert distance to meters\ndistance_meters = distance_km * conversion_factor\n\n# 2. Calculating Time from Distance and Speed\n# Given distance in meters\ndistance = 1000.0  # meters\n\n# Given speed in meters per second\nspeed = 5.0  # meters per second\n\n# Calculate time in seconds\ntime = distance / speed\n\n# 3. Energy Calculation Using Kinetic Energy Formula\n# Mass in kilograms\nmass = 70.0  # kg\n\n# Velocity in meters per second\nvelocity = 10.0  # m/s\n\n# Calculate kinetic energy\nkinetic_energy = 0.5 * mass * velocity ** 2\n\n# 4. Temperature Conversion (Celsius to Fahrenheit)\n# Temperature in Celsius\ntemp_celsius = 25.0  # degrees Celsius\n\n# Convert to Fahrenheit\ntemp_fahrenheit = (temp_celsius * 9/5) + 32\n\n# 5. Power Calculation Using Work and Time\n# Work done in joules\nwork_done = 500.0  # joules\n\n# Time taken in seconds\ntime_taken = 20.0  # seconds\n\n# Calculate power\npower_output = work_done / time_taken\n\n# 6. Calculating Force Using Newton's Second Law\n# Mass in kilograms\nmass = 10.0  # kg\n\n# Acceleration in meters per second squared\nacceleration = 9.8  # m/s^2\n\n# Calculate force\nforce = mass * acceleration\n\n# Output Results\nprint(f\"Distance in meters: {distance_meters} m\")\nprint(f\"Time to travel {distance} meters at {speed} m/s: {time} seconds\")\nprint(f\"Kinetic energy: {kinetic_energy} joules\")\nprint(f\"Temperature in Fahrenheit: {temp_fahrenheit} °F\")\nprint(f\"Power output: {power_output} watts\")\nprint(f\"Force: {force} newtons\")\n\n\nSimple calculations relevant to physics, such as converting units or calculating simple quantities (e.g., distance = speed × time).\n\nHomework: Basic practice problems to reinforce Python syntax and operations."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion.html",
    "href": "lectures/lecture04/2_brownian_motion.html",
    "title": "Brownian Motion",
    "section": "",
    "text": "File as PDF\nWe will apply our newly acquired knowledge about classes to simulate Brownian motion. This task aligns perfectly with the principles of object-oriented programming, as each Brownian particle (or colloid) can be represented as an object instantiated from the same class, albeit with different properties. For instance, some particles might be larger while others are smaller. We have already touched on some aspects of this in previous lectures."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion.html#physics",
    "href": "lectures/lecture04/2_brownian_motion.html#physics",
    "title": "Brownian Motion",
    "section": "Physics",
    "text": "Physics\nThe Brownian motion of a colloidal particle (referred to as a solute) results from collisions with surrounding solvent molecules. These collisions impart a mean kinetic energy to the particle, determined by the temperature. With this kinetic energy, the particle travels a mean distance \\(l\\) before changing direction and taking another step of length \\(l\\). In liquids, this mean distance is extremely short, on the order of picometers. Lindenberg and Lévy have demonstrated that a sequence of many such infinitesimally small random steps results in a total effect that can be approximated by a normal distribution. This significant result is known as the central limit theorem.\nFor our Brownian motion, the sequence of tiny steps leads, after a time \\(t\\), to the following probability distribution for finding the particle at position \\(x\\) if it initially started at \\(x=0\\):\n\\[\np(x,\\Delta t)=\\frac{1}{\\sqrt{4\\pi D \\Delta t}}e^{-\\frac{x^2}{4D \\Delta t}}\n\\]\nwhere \\(D\\) is the diffusion coefficient. Therefore, each step in our Brownian motion simulation for a timestep of \\(\\Delta t\\) is drawn from a Gaussian distribution with a variance of \\(\\sigma^2=2D \\Delta t\\).\nFor our simulation that means that we can draw numbers from a normal distribution with np.random.normal with the standard deviation \\(\\sigma=\\sqrt{2D \\Delta t}\\) as a parameter. This has to be done for the x-coordinate and the y-coordinate.\nThe code for our Brownian motion therefore is\nsigma=np.sqrt(2*D*dt)\ndx,dy=[(np.random.normal(0.0, sigma),np.random.normal(0.0, sigma)]\nx=x+dx\ny=y+dy\nwhich gives a whole 2d trajectory. With the help of this, we would like to write a colloidal particle class. So lets make a plan how this could work out."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion.html#class-planning",
    "href": "lectures/lecture04/2_brownian_motion.html#class-planning",
    "title": "Brownian Motion",
    "section": "Class Planning",
    "text": "Class Planning\n\nPhysics project Colloidal particle class\nWe will define a class for a colloidal particle, which we may use later for our projects as well. This makes sense, as we can have different colloidal particles of different radius for example, which do start to carry out Brownian motion from different positions. A colloidal particle is and object, which has properties very much in the same way as classes intend that. The whole definition requires some planning, especially on what the class should keep track of and what the object.\nThe particle class shall keep track of\n* the total number of colloidal particles\n* the value of k_B T/(6 pi eta) = 2.2e-19\nThe class shall provide the class specific methods\n* how_many() which returns the total number of colloids\n* __str__ which returns a string with radius and position of the particle\n\n\nPhysics interlude: Colloidal particle class\nEach object shall then contain the following properties\n* the particle radius, R\n* a list of all x position, x\n* a list of all y position, y\n* the index of the colloid, index\n* the diffusion coefficient given by k_B T/(6 pi eta R), D\nThe object shall provide the following methods\n* sim_trajectory() simulate a whole trajectory at once\n* update(dt) do one step of Brownian motion with a time step dt as argument, return the current position\n* get_trajectory() return the trajectory as a pandas DataFrame with the columns x and y\n* get_D() return the diffusion coefficient\n\n\n\n\n\n\n\n\nNote:\nNote that the function sim_trajectory is actually calling the function update of the same object to generate the whole trajectory at once."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion.html#simulating",
    "href": "lectures/lecture04/2_brownian_motion.html#simulating",
    "title": "Brownian Motion",
    "section": "Simulating",
    "text": "Simulating\nWith the help of this Colloid class, we would like to carry out simulations of Brownian motion of multiple particles. The simulations shall\n\ntake n=200 particles\nhave N=200 trajectory points each\nstart all at 0,0\nparticle objects should be stored in a list p_list"
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion.html#plotting-the-trajectories",
    "href": "lectures/lecture04/2_brownian_motion.html#plotting-the-trajectories",
    "title": "Brownian Motion",
    "section": "Plotting the trajectories",
    "text": "Plotting the trajectories\nThe next step is to plot all the trajectories."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion.html#characterizing-the-brownian-motion",
    "href": "lectures/lecture04/2_brownian_motion.html#characterizing-the-brownian-motion",
    "title": "Brownian Motion",
    "section": "Characterizing the Brownian motion",
    "text": "Characterizing the Brownian motion\nNow that we have a number of trajectories, we can analyze the motion of our Brownian particles.\n\nCalculate the particle speed\nOne way is to calculate its speed by measuring how far it traveled within a certain time \\(n\\, dt\\), where \\(dt\\) is the timestep of out simulation. We can do that as\n\\[\\begin{equation}\nv(n dt) = \\frac{&lt;\\sqrt{(x_{i+n}-x_{i})^2+(y_{i+n}-y_{i})^2}&gt;}{n\\,dt}\n\\end{equation}\\]\nThe angular brackets on the top take care of the fact that we can measure the distance traveled within a certain time \\(n\\, dt\\) several times along a trajectory.\n\n\n\nmsd\n\n\nThese values can be used to calculate a mean speed. Note that there is not an equal amount of data pairs for all separations available. For \\(n=1\\) there are 5 distances available. For \\(n=5\\), however, only 1. This changes the statistical accuracy of the mean.\n\n\n\n\n\n\nThe result of this analysis shows, that each particle has an apparent speed which seems to increase with decreasing time of observation or which decreases with increasing time. This would mean that there is some friction at work, which slows down the particle in time, but this is apparently not true. Also an infinite speed at zero time appears to be unphysical. The correct answer is just that the speed is no good measure to characterize the motion of a Brownian particle.\n\n\nCalculate the particle mean squared displacement\nA better way to characterize the motion of a Brownian particle is the mean squared displacement, as we have already mentioned it in previous lectures. We may compare our simulation now to the theoretical prediction, which is\n\\[\\begin{equation}\n\\langle \\Delta r^{2}(t)\\rangle=2 d D t\n\\end{equation}\\]\nwhere \\(d\\) is the dimension of the random walk, which is \\(d=2\\) in our case.\n\n\n\n\n\n\nThe results show that the mean squared displacement of the individual particles follows on average the theoretical predictions of a linear growth in time. That means, we are able to read the diffusion coefficient from the slope of the MSD of the individual particles if recorded in a simulation or an experiment.\nYet, each individual MSD is deviating strongly from the theoretical prediction especially at large times. This is due to the fact mentioned earlier that our simulation (or experimental) data only has a limited number of data points, while the theoretical prediction is made for the limit of infinite data points.\n\nWarning: Analysis of MSD data\nSingle particle tracking, either in the experiment or in numerical simulations can therefore only deliver an estimate of the diffusion coefficient and care should be taken when using the whole MSD to obtain the diffusion coefficient. One typically uses only a short fraction of the whole MSD data at short times."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html",
    "href": "lectures/lecture04/2_brownian_motion copy.html",
    "title": "Brownian Motion",
    "section": "",
    "text": "File as PDF\nWe will use our newly gained knowledge about classes for the simulation of Brownian motion. This actually perfectly fits to the object oriented programming topic, as each Brownian particle (or colloid) can be seen as an object instanciated from the same class, but perhaps with different properties. Some particles might be larger and some smaller for example. We know already some part of that, as we have covered it in earlier lectures."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#physics",
    "href": "lectures/lecture04/2_brownian_motion copy.html#physics",
    "title": "Brownian Motion",
    "section": "Physics",
    "text": "Physics\nThe Brownian motion of a colloidal particle (called solute) results from the collisions with the surrounding solvent molecules. Due to these collisions, the particle has in equilibrium a mean kinetic energy defined by the temperature. With this kinetic energy it would travel a mean distance \\(l\\) before it takes another random direction and go another step length \\(l\\). This mean distance the particle travels is very short in liquids. It is on the other of picometers. It has been shown by Lindenberg and Lévy that a sequence of many such infinitesimal small random steps leads to a total effect, which can be approximated by a normal distribution. This important theorem is called the central limit theorem.\nFor our Brownian motion the sequence of tiny steps leads after a time \\(t\\) to the following probability distribution to find the particle at a position \\(x\\) if it initially started at \\(x=0\\):\n\\[\\begin{equation}\np(x,\\Delta t)=\\frac{1}{\\sqrt{4\\pi D \\Delta t}}e^{-\\frac{x^2}{4D \\Delta t}}\n\\end{equation}\\]\nwhere \\(D\\) is the diffusion coefficient. Thus each step of our Brownian motion simulation for a timestep of \\(\\Delta t\\) is taken from a Gaussian distribution with a varaince of \\(\\sigma^2=2D \\Delta t\\).\nFor our simulation that means that we can draw numbers from a normal distribution with np.random.normal with the standard deviation \\(\\sigma=\\sqrt{2D \\Delta t}\\) as a parameter. This has to be done for the x-coordinate and the y-coordinate.\nThe code for our Brownian motion therefore is\nsigma=np.sqrt(2*D*dt)\ndx,dy=[(np.random.normal(0.0, sigma),np.random.normal(0.0, sigma)]\nx=x+dx\ny=y+dy\nwhich gives a whole 2d trajectory. With the help of this, we would like to write a colloidal particle class. So lets make a plan how this could work out."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#class-planning",
    "href": "lectures/lecture04/2_brownian_motion copy.html#class-planning",
    "title": "Brownian Motion",
    "section": "Class Planning",
    "text": "Class Planning\n\nPhysics project Colloidal particle class\nWe will define a class for a colloidal particle, which we may use later for our projects as well. This makes sense, as we can have different colloidal particles of different radius for example, which do start to carry out Brownian motion from different positions. A colloidal particle is and object, which has properties very much in the same way as classes intend that. The whole definition requires some planning, especially on what the class should keep track of and what the object.\nThe particle class shall keep track of\n* the total number of colloidal particles\n* the value of k_B T/(6 pi eta) = 2.2e-19\nThe class shall provide the class specific methods\n* how_many() which returns the total number of colloids\n* __str__ which returns a string with radius and position of the particle\n\n\nPhysics interlude: Colloidal particle class\nEach object shall then contain the following properties\n* the particle radius, R\n* a list of all x position, x\n* a list of all y position, y\n* the index of the colloid, index\n* the diffusion coefficient given by k_B T/(6 pi eta R), D\nThe object shall provide the following methods\n* sim_trajectory() simulate a whole trajectory at once\n* update(dt) do one step of Brownian motion with a time step dt as argument, return the current position\n* get_trajectory() return the trajectory as a pandas DataFrame with the columns x and y\n* get_D() return the diffusion coefficient\n\n\n\n\n\n\n\n\nNote:\nNote that the function sim_trajectory is actually calling the function update of the same object to generate the whole trajectory at once."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#simulating",
    "href": "lectures/lecture04/2_brownian_motion copy.html#simulating",
    "title": "Brownian Motion",
    "section": "Simulating",
    "text": "Simulating\nWith the help of this Colloid class, we would like to carry out simulations of Brownian motion of multiple particles. The simulations shall\n\ntake n=200 particles\nhave N=200 trajectory points each\nstart all at 0,0\nparticle objects should be stored in a list p_list"
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#plotting-the-trajectories",
    "href": "lectures/lecture04/2_brownian_motion copy.html#plotting-the-trajectories",
    "title": "Brownian Motion",
    "section": "Plotting the trajectories",
    "text": "Plotting the trajectories\nThe next step is to plot all the trajectories."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#characterizing-the-brownian-motion",
    "href": "lectures/lecture04/2_brownian_motion copy.html#characterizing-the-brownian-motion",
    "title": "Brownian Motion",
    "section": "Characterizing the Brownian motion",
    "text": "Characterizing the Brownian motion\nNow that we have a number of trajectories, we can analyze the motion of our Brownian particles.\n\nCalculate the particle speed\nOne way is to calculate its speed by measuring how far it traveled within a certain time \\(n\\, dt\\), where \\(dt\\) is the timestep of out simulation. We can do that as\n\\[\\begin{equation}\nv(n dt) = \\frac{&lt;\\sqrt{(x_{i+n}-x_{i})^2+(y_{i+n}-y_{i})^2}&gt;}{n\\,dt}\n\\end{equation}\\]\nThe angular brackets on the top take care of the fact that we can measure the distance traveled within a certain time \\(n\\, dt\\) several times along a trajectory.\n\n\n\nmsd\n\n\nThese values can be used to calculate a mean speed. Note that there is not an equal amount of data pairs for all separations available. For \\(n=1\\) there are 5 distances available. For \\(n=5\\), however, only 1. This changes the statistical accuracy of the mean.\n\n\n\n\n\n\nThe result of this analysis shows, that each particle has an apparent speed which seems to increase with decreasing time of observation or which decreases with increasing time. This would mean that there is some friction at work, which slows down the particle in time, but this is apparently not true. Also an infinite speed at zero time appears to be unphysical. The correct answer is just that the speed is no good measure to characterize the motion of a Brownian particle.\n\n\nCalculate the particle mean squared displacement\nA better way to characterize the motion of a Brownian particle is the mean squared displacement, as we have already mentioned it in previous lectures. We may compare our simulation now to the theoretical prediction, which is\n\\[\\begin{equation}\n\\langle \\Delta r^{2}(t)\\rangle=2 d D t\n\\end{equation}\\]\nwhere \\(d\\) is the dimension of the random walk, which is \\(d=2\\) in our case.\n\n\n\n\n\n\nThe results show that the mean squared displacement of the individual particles follows on average the theoretical predictions of a linear growth in time. That means, we are able to read the diffusion coefficient from the slope of the MSD of the individual particles if recorded in a simulation or an experiment.\nYet, each individual MSD is deviating strongly from the theoretical prediction especially at large times. This is due to the fact mentioned earlier that our simulation (or experimental) data only has a limited number of data points, while the theoretical prediction is made for the limit of infinite data points.\n\nWarning: Analysis of MSD data\nSingle particle tracking, either in the experiment or in numerical simulations can therefore only deliver an estimate of the diffusion coefficient and care should be taken when using the whole MSD to obtain the diffusion coefficient. One typically uses only a short fraction of the whole MSD data at short times."
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html",
    "href": "lectures/lecture04/01-lecture04.html",
    "title": "Lecture 4",
    "section": "",
    "text": "Introduction to loops for numerical integration (e.g., trapezoidal rule).\nFunctions for calculating work, power, and energy.\n\n\n\n\n\nWriting Python code to calculate the work done by a variable force (e.g., spring force) using numerical integration.\nSimulating energy conservation in a closed system (e.g., pendulum).\nVisualization: Plotting energy vs. time for the system.\nHomework: Modify the code to simulate a different system, such as a mass-spring system.\n\n\n\n\n    \n    \n    D3.js Shaded Spheres"
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#work-power-energy",
    "href": "lectures/lecture04/01-lecture04.html#work-power-energy",
    "title": "Lecture 4",
    "section": "",
    "text": "Introduction to loops for numerical integration (e.g., trapezoidal rule).\nFunctions for calculating work, power, and energy.\n\n\n\n\n\nWriting Python code to calculate the work done by a variable force (e.g., spring force) using numerical integration.\nSimulating energy conservation in a closed system (e.g., pendulum).\nVisualization: Plotting energy vs. time for the system.\nHomework: Modify the code to simulate a different system, such as a mass-spring system.\n\n\n\n\n    \n    \n    D3.js Shaded Spheres"
  },
  {
    "objectID": "lectures/lecture02/03-lecture02.html",
    "href": "lectures/lecture02/03-lecture02.html",
    "title": "Plotting",
    "section": "",
    "text": "Writing a Python function to calculate and plot the position vs. time for an object moving with constant velocity or constant acceleration.\nVisualization: Use matplotlib to plot simple kinematic graphs (position vs. time, velocity vs. time).\nHomework: Extend the kinematic function to handle different initial conditions and plot the results."
  },
  {
    "objectID": "lectures/lecture02/03-lecture02.html#plotting",
    "href": "lectures/lecture02/03-lecture02.html#plotting",
    "title": "Plotting",
    "section": "",
    "text": "Writing a Python function to calculate and plot the position vs. time for an object moving with constant velocity or constant acceleration.\nVisualization: Use matplotlib to plot simple kinematic graphs (position vs. time, velocity vs. time).\nHomework: Extend the kinematic function to handle different initial conditions and plot the results."
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html",
    "href": "lectures/lecture02/04-lecture02.html",
    "title": "Plotting",
    "section": "",
    "text": "Data visualization through plotting is a crucial tool for analyzing and interpreting scientific data and theoretical predictions. While plotting capabilities are not built into Python’s core, they are available through various external library modules. Matplotlib is widely recognized as the de facto standard for plotting in Python. However, several other powerful plotting libraries exist, including PlotLy, Seaborn, and Bokeh, each offering unique features and capabilities for data visualization.\nAs Matplotlib is an external library (actually a collection of libraries), it must be imported into any script that uses it. While Matplotlib relies heavily on NumPy, importing NumPy separately is not always necessary for basic plotting. However, for most scientific applications, you’ll likely use both. To create 2D plots, you typically start by importing Matplotlib’s pyplot module:\nThis import introduces the implicit interface of pyplot for creating figures and plots. Matplotlib offers two main interfaces:\nWe will use most of the the the pyplot interface as in the examples below. The section Additional Plotting will refer to the explicit programming of figures.\nWe can set some of the parameters for the appearance of graphs globally. In case you still want to modify a part of it, you can set individual parameters later during plotting. The command used here is the\nfunction, which takes a dictionary with the specific parameters as key.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#simple-plotting",
    "href": "lectures/lecture02/04-lecture02.html#simple-plotting",
    "title": "Plotting",
    "section": "Simple Plotting",
    "text": "Simple Plotting\nMatplotlib offers multiple levels of functionality for creating plots. Throughout this section, we’ll primarily focus on using commands that leverage default settings. This approach simplifies the process, as Matplotlib automatically handles much of the graph layout. These high-level commands are ideal for quickly creating effective visualizations without delving into intricate details. At the end of this section, we’ll briefly touch upon more advanced techniques that provide greater control over plot elements and layout.\n\nLine Plot\nTo create a basic line plot, use the following command:\nplt.plot(x, y)\nBy default, this generates a line plot. However, you can customize the appearance by adjusting various parameters within the plot() function. For instance, you can modify it to resemble a scatter plot by changing certain arguments. The versatility of this command allows for a range of visual representations beyond simple line plots.\nLet’s create a simple line plot of the sine function over the interval [0, 4π]. We’ll use NumPy to generate the x-values and calculate the corresponding y-values. The following code snippet demonstrates this process:\n1x = np.linspace(0, 4.*np.pi, 100)\n2y = np.sin(x)\n\n3plt.figure(figsize=(4,3))\n4plt.plot(x, y)\n5plt.tight_layout()\nplt.show()\n\n1\n\nCreate an array of 100 values between 0 and 4π.\n\n2\n\nCalculate the sine of each value in the array.\n\n3\n\ncreate a new figure\n\n4\n\nautomatically adjust the layout\n\n5\n\nshow the figure\n\n\nHere is the code in a Python cell:\n\n\n\n\n\n\nTry to change the values of the x and y arrays and see how the plot changes.\n\n\n\n\n\n\nWhy use plt.tight_layout()\n\n\n\n\n\nplt.tight_layout() is a very useful function in Matplotlib that automatically adjusts the spacing between plot elements to prevent overlapping and ensure that all elements fit within the figure area. Here’s what it does:\n\nPadding Adjustment: It adjusts the padding between and around subplots to prevent overlapping of axis labels, titles, and other elements.\nSubplot Spacing: It optimizes the space between multiple subplots in a figure.\nText Accommodation: It ensures that all text elements (like titles, labels, and legends) fit within the figure without being cut off.\nMargin Adjustment: It adjusts the margins around the entire figure to make sure everything fits neatly.\nAutomatic Resizing: If necessary, it can slightly resize subplot areas to accommodate all elements.\nLegend Positioning: It takes into account the presence and position of legends when adjusting layouts.\n\nKey benefits of using plt.tight_layout():\n\nIt saves time in manual adjustment of plot elements.\nIt helps create more professional-looking and readable plots.\nIt’s particularly useful when creating figures with multiple subplots or when saving figures to files.\n\nYou typically call plt.tight_layout() just before plt.show() or plt.savefig(). For example:\nplt.figure()\n# ... (your plotting code here)\nplt.tight_layout()\nplt.show()\n\n\n\n\nAxis Labels\nTo enhance the clarity and interpretability of our plots, it’s crucial to provide context through proper labeling. Let’s add descriptive axis labels to our diagram, a practice that significantly improves the readability and comprehension of the data being presented.\nplt.xlabel('x-label')\nplt.ylabel('y-label')\n\n\n\n\n\n\n\n\nLegends\nplt.plot(..., label=r'$\\sin(x)$')\nplt.legend(loc='lower left')\n\n\n\n\n\n\n\n\n\nScatter plot\nIf you prefer to use symbols for plotting just use the\nplt.scatter(x,y)\ncommand of pylab. Note that the scatter command requires a x and y values and you can set the marker symbol (see an overview of the marker symbols).\n\n\n\n\n\n\n\n\nHistograms\nA very useful plotting command is also the hist command. It generates a histogram of the data provided. If only the data is given, bins are calculated automatically. If you supply an array of intervalls with hist(data,bins=b), where b is and array, the hist command calculates the histogram for the supplied bins. density=True normalizes the area below the histogram to 1. The hist command not only returns the graph, but also the occurrences and bins.\n\n\n\n\n\n\nPhysics Interlude- Probability density for finding an oscillating particle\n\n\n\nLet’s take this opportunity to integrate histogram plotting with a physics concept. We’ll examine the simple harmonic oscillator in one dimension, a fundamental model in physics. As you may recall, this system is described by a specific equation of motion, which we’ll explore in the context of data visualization using histograms.\n\\[\\begin{equation}\n\\ddot{x}(t)=-\\omega^{2}x(t)\n\\end{equation}\\]\nThe solution of that equation of motion for an initial elongation \\(\\Delta x\\) at \\(t=0\\) is given by\n\\[\\begin{equation}\nx(t)=\\Delta x \\cos(\\omega t)\n\\end{equation}\\]\nIf you now need to calculate the probability to find the spring at a certain elongation you need to calculate the time the oscillator spends at different positions. The time \\(dt\\) spend in the interval [\\(x(t)\\),\\(x(t)+dx\\)] depends on the speed, i.e.\n\\[\\begin{equation}\nv(t)=\\frac{dx}{dt}=-\\omega \\Delta x  \\sin(\\omega t)\n\\end{equation}\\]\nThe probability to find the oscillator at a certain intervall then is the fraction of time residing in this intervall normalized by the half the oscillation period \\(T/2\\).\n\\[\\begin{equation}\n\\frac{dt}{T/2}=\\frac{1}{T/2}\\frac{dx}{v(t)}=\\frac{1}{T/2}\\frac{-dx}{\\omega \\Delta x  \\sin(\\omega t)}\n\\end{equation}\\]\nAs the frequency of the oscillator is \\(\\omega=2\\pi/T\\) we can replace \\(T\\) by \\(T=2\\pi/\\omega\\) which yields\n\\[\\begin{equation}\np(x)dx=\\frac{1}{\\pi \\Delta x}\\frac{dx}{\\sqrt{1-\\left (\\frac{x(t)}{\\Delta x}\\right )^2}}\n\\end{equation}\\]\nThis is the probability density of finding an oscillating spring at a certain elongation \\(x(t)\\). If you look at the example more closely, it tells you, that you find and elongation more likely when the speed of the mass is low. This is even a more general issue in non-equilibrium physics. If cells or cars are moving with variable speed, they are more likely to be found at places where they are slow.\nThis can be also addressed with the histogram function. If we use the solution of the equation of motion and evaluate the position at equidistant times, the the historgram over the corresponding positions will tell us the probability of finding a certain position value if normalized properly.\n\n\n\n\n\n\n\n\n\n\nCombined plots\nYou can combine multiple data with the same axes by stacking multiple plots.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#saving-figures",
    "href": "lectures/lecture02/04-lecture02.html#saving-figures",
    "title": "Plotting",
    "section": "Saving figures",
    "text": "Saving figures\nTo save a figure to a file we can use the savefig method in the Figure class. Matplotlib can generate high-quality output in a number formats, including PNG, JPG, EPS, SVG, PGF and PDF. For scientific papers, I recommend using PDF whenever possible. (LaTeX documents compiled with pdflatex can include PDFs using the includegraphics command). In some cases, PGF can also be good alternative.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#plots-with-error-bars",
    "href": "lectures/lecture02/04-lecture02.html#plots-with-error-bars",
    "title": "Plotting",
    "section": "Plots with error bars",
    "text": "Plots with error bars\nWhen plotting experimental data it is customary to include error bars that indicate graphically the degree of uncertainty that exists in the measurement of each data point. The MatPlotLib function errorbar plots data with error bars attached. It can be used in a way that either replaces or augments the plot function. Both vertical and horizontal error bars can be displayed. The figure below illustrates the use of error bars.\n\n\n\n\n\n\n\nSetting plotting limits and excluding data\nIf you want to zoom in to s specific region of a plot you can set the limits of the individual axes.\n\n\n\n\n\n\n\nMasked arrays\nSometimes you encounter situations, when you wish to mask some of the data of your plot, because they are not showing real data as the vertical lines in the plot above. For this purpose, you can mask the data arrays in various ways to not show up. The example below uses the\nnp.ma.masked_where()\nfunction of NumPy, which takes a condition as the first argument and what should be returned if that condition is fulfilled.\n\n\n\n\n\n\nIf you look at the resulting array, you will find, that the entries have not been removed but replaced by --, so the values are not existent and thefore not plotted.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#logarithmic-plots",
    "href": "lectures/lecture02/04-lecture02.html#logarithmic-plots",
    "title": "Plotting",
    "section": "Logarithmic plots",
    "text": "Logarithmic plots\nData sets can span many orders of magnitude from fractional quantities much smaller than unity to values much larger than unity. In such cases it is often useful to plot the data on logarithmic axes.\n\nSemi-log plots\nFor data sets that vary exponentially in the independent variable, it is often useful to use one or more logarithmic axes. Radioactive decay of unstable nuclei, for example, exhibits an exponential decrease in the number of particles emitted from the nuclei as a function of time.\nMatPlotLib provides two functions for making semi-logarithmic plots, semilogx and semilogy, for creating plots with logarithmic x and y axes, with linear y and x axes, respectively. We illustrate their use in the program below, which made the above plots.\n\n\n\n\n\n\n\n\nLog-log plots\nMatPlotLib can also make log-log or double-logarithmic plots using the function loglog. It is useful when both the \\(x\\) and \\(y\\) data span many orders of magnitude. Data that are described by a power law \\(y=Ax^b\\), where \\(A\\) and \\(b\\) are constants, appear as straight lines when plotted on a log-log plot. Again, the loglog function works just like the plot function but with logarithmic axes.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#arranging-multiple-plots",
    "href": "lectures/lecture02/04-lecture02.html#arranging-multiple-plots",
    "title": "Plotting",
    "section": "Arranging multiple plots",
    "text": "Arranging multiple plots\nOften you want to create two or more graphs and place them next to one another, generally because they are related to each other in some way.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#contour-and-density-plots",
    "href": "lectures/lecture02/04-lecture02.html#contour-and-density-plots",
    "title": "Plotting",
    "section": "Contour and Density Plots",
    "text": "Contour and Density Plots\nA contour plots are useful tools to study two dimensional data, meaning \\(Z(X,Y)\\). A contour plots isolines of the function \\(Z\\).\n\nSimple contour plot\n\n\n\n\n\n\nPhysics Interlude\n\n\n\nInterference of spherical waves\nWe want to use contour plots to explore the interference of two spherical waves. A spherical wave can be given by a complex spatial amplitude\n\\[\\begin{equation}\nU(r)=U_{0}\\frac{e^{-i\\,k r}}{r}\n\\end{equation}\\]\nwhere \\(U_{0}\\) is the amplitude, \\(k\\) the magnitude of the k-vector, i.e. \\(k=2\\pi/\\lambda\\) and \\(r=\\sqrt{x^2+y^2}\\) the distance, here in 2 dimensions. Note that the total wavefunction also contains a temporal part such that\n\\[\\begin{equation}\nU(r,t)=U_{0}\\frac{e^{-i\\,k r}}{r}e^{i\\omega t}\n\\end{equation}\\]\nWe will however ignore the temporal factor, as we are interested in the spatial interference pattern with a time-averaged intensity.\nTo show interference, we just use two of those monochromatic waves located at \\(\\vec{r}_{1}\\) and \\(\\vec{r}_{2}\\).\n\n\n\ninterference\n\n\nTo obtain the total amplitude we have to sum up the wavefunctions of the two sources.\n\\[\\begin{equation}\nU(\\vec{r})=U_{01}\\frac{e^{-i\\,k |\\vec{r}-\\vec{r}_1|}}{|\\vec{r}-\\vec{r}_1|}+U_{02}\\frac{e^{-i\\,k |\\vec{r}-\\vec{r}_2|}}{|\\vec{r}-\\vec{r}_2|}\n\\end{equation}\\]\nThe intensity of the wave at a position is then related to the magnitude square of the wavefunction\n\\[\\begin{equation}\nI(r)\\propto |U(r)|^2\n\\end{equation}\\]\nTo keep it simple we will skip the \\(1/r\\) amplitude decay.\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor contour plot\n\n\n\n\n\n\n\n\nImage plot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvanced Plotting - Explicit Version\n\n\n\n\n\nAdvanced Plotting - Explicit Version\nWhile we have so far largely relied on the default setting and the automatic arrangement of plots, there is also a way to precisely design your plot. Python provides the tools of object oriented programming and thus modules provide classes which can be instanced into objects. This explicit interfaces allows you to control all details without the automatisms of pyplot.\nThe figure below, which is taken from the matplotlib documentation website shows the sets of commands and the objects in the figure, the commands refer to. It is a nice reference, when creating a figure.\n\n\n\nanatomy of a figure\n\n\n\nPlots with Multiple Spines\nSometimes it is very useful to plot different quantities in the same plot with the same x-axis but with different y-axes. Here is some example, where each line plot has its own y-axis.\n\n\n\n\n\n\n\n\nInsets\nInsets are plots within plots using their own axes. We therefore need to create two axes systems, if we want to have a main plot and and inset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpine axis\n\n\n\n\n\n\n\n\nPolar plot\n\n\n\n\n\n\n\n\nText annotation\nAnnotating text in matplotlib figures can be done using the text function. It supports LaTeX formatting just like axis label texts and titles:\n\n\n\n\n\n\n\n\n3D Plotting\nMatplotlib was initially designed with only two-dimensional plotting in mind. Around the time of the 1.0 release, some three-dimensional plotting utilities were built on top of Matplotlib’s two-dimensional display, and the result is a convenient (if somewhat limited) set of tools for three-dimensional data visualization. Three-dimensional plots are enabled by importing the mplot3d toolkit, included with the main Matplotlib installation:\n\n\n\n\n\n\nOnce this submodule is imported, a three-dimensional axes can be created by passing the keyword projection=‘3d’ to any of the normal axes creation routines:\n\nProjection Scence\n\n\n\n\n\n\nWith this three-dimensional axes enabled, we can now plot a variety of three-dimensional plot types. Three-dimensional plotting is one of the functionalities that benefits immensely from viewing figures interactively rather than statically in the notebook; recall that to use interactive figures, you can use %matplotlib notebook rather than %matplotlib inline when running this code.\n\n\nLine Plotting in 3D\nfrom sets of (x, y, z) triples. In analogy with the more common two-dimensional plots discussed earlier, these can be created using the ax.plot3D and ax.scatter3D functions. The call signature for these is nearly identical to that of their two-dimensional counterparts, so you can refer to Simple Line Plots and Simple Scatter Plots for more information on controlling the output. Here we’ll plot a trigonometric spiral, along with some points drawn randomly near the line:\n\n\n\n\n\n\nNotice that by default, the scatter points have their transparency adjusted to give a sense of depth on the page. While the three-dimensional effect is sometimes difficult to see within a static image, an interactive view can lead to some nice intuition about the layout of the points. Use the scatter3D or the plot3D method to plot a random walk in 3-dimensions in your exercise.\n\n\nSurface Plotting\nA surface plot is like a wireframe plot, but each face of the wireframe is a filled polygon. Adding a colormap to the filled polygons can aid perception of the topology of the surface being visualized:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#interference-of-spherical-waves",
    "href": "lectures/lecture02/04-lecture02.html#interference-of-spherical-waves",
    "title": "Plotting",
    "section": "Interference of spherical waves",
    "text": "Interference of spherical waves\nWe want to use contour plots to explore the interference of two spherical waves. A spherical wave can be given by a complex spatial amplitude\n\\[\\begin{equation}\nU(r)=U_{0}\\frac{e^{-i\\,k r}}{r}\n\\end{equation}\\]\nwhere \\(U_{0}\\) is the amplitude, \\(k\\) the magnitude of the k-vector, i.e. \\(k=2\\pi/\\lambda\\) and \\(r=\\sqrt{x^2+y^2}\\) the distance, here in 2 dimensions. Note that the total wavefunction also contains a temporal part such that\n\\[\\begin{equation}\nU(r,t)=U_{0}\\frac{e^{-i\\,k r}}{r}e^{i\\omega t}\n\\end{equation}\\]\nWe will however ignore the temporal factor, as we are interested in the spatial interference pattern with a time-averaged intensity.\nTo show interference, we just use two of those monochromatic waves located at \\(\\vec{r}_{1}\\) and \\(\\vec{r}_{2}\\).\n\n\n\ninterference\n\n\nTo obtain the total amplitude we have to sum up the wavefunctions of the two sources.\n\\[\\begin{equation}\nU(\\vec{r})=U_{01}\\frac{e^{-i\\,k |\\vec{r}-\\vec{r}_1|}}{|\\vec{r}-\\vec{r}_1|}+U_{02}\\frac{e^{-i\\,k |\\vec{r}-\\vec{r}_2|}}{|\\vec{r}-\\vec{r}_2|}\n\\end{equation}\\]\nThe intensity of the wave at a position is then related to the magnitude square of the wavefunction\n\\[\\begin{equation}\nI(r)\\propto |U(r)|^2\n\\end{equation}\\]\nTo keep it simple we will skip the \\(1/r\\) amplitude decay.\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor contour plot\n\n\n\n\n\n\n\n\nImage plot",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-lecture02.html#advanced-plotting---explicit-version",
    "href": "lectures/lecture02/04-lecture02.html#advanced-plotting---explicit-version",
    "title": "Plotting",
    "section": "Advanced Plotting - Explicit Version",
    "text": "Advanced Plotting - Explicit Version\nWhile we have so far largely relied on the default setting and the automatic arrangement of plots, there is also a way to precisely design your plot. Python provides the tools of object oriented programming and thus modules provide classes which can be instanced into objects. This explicit interfaces allows you to control all details without the automatisms of pyplot.\nThe figure below, which is taken from the matplotlib documentation website shows the sets of commands and the objects in the figure, the commands refer to. It is a nice reference, when creating a figure.\n\n\n\nanatomy of a figure\n\n\n\nPlots with Multiple Spines\nSometimes it is very useful to plot different quantities in the same plot with the same x-axis but with different y-axes. Here is some example, where each line plot has its own y-axis.\n\n\n\n\n\n\n\n\nInsets\nInsets are plots within plots using their own axes. We therefore need to create two axes systems, if we want to have a main plot and and inset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpine axis\n\n\n\n\n\n\n\n\nPolar plot\n\n\n\n\n\n\n\n\nText annotation\nAnnotating text in matplotlib figures can be done using the text function. It supports LaTeX formatting just like axis label texts and titles:\n\n\n\n\n\n\n\n\n3D Plotting\nMatplotlib was initially designed with only two-dimensional plotting in mind. Around the time of the 1.0 release, some three-dimensional plotting utilities were built on top of Matplotlib’s two-dimensional display, and the result is a convenient (if somewhat limited) set of tools for three-dimensional data visualization. Three-dimensional plots are enabled by importing the mplot3d toolkit, included with the main Matplotlib installation:\n\n\n\n\n\n\nOnce this submodule is imported, a three-dimensional axes can be created by passing the keyword projection=‘3d’ to any of the normal axes creation routines:\n\nProjection Scence\n\n\n\n\n\n\nWith this three-dimensional axes enabled, we can now plot a variety of three-dimensional plot types. Three-dimensional plotting is one of the functionalities that benefits immensely from viewing figures interactively rather than statically in the notebook; recall that to use interactive figures, you can use %matplotlib notebook rather than %matplotlib inline when running this code.\n\n\nLine Plotting in 3D\nfrom sets of (x, y, z) triples. In analogy with the more common two-dimensional plots discussed earlier, these can be created using the ax.plot3D and ax.scatter3D functions. The call signature for these is nearly identical to that of their two-dimensional counterparts, so you can refer to Simple Line Plots and Simple Scatter Plots for more information on controlling the output. Here we’ll plot a trigonometric spiral, along with some points drawn randomly near the line:\n\n\n\n\n\n\nNotice that by default, the scatter points have their transparency adjusted to give a sense of depth on the page. While the three-dimensional effect is sometimes difficult to see within a static image, an interactive view can lead to some nice intuition about the layout of the points. Use the scatter3D or the plot3D method to plot a random walk in 3-dimensions in your exercise.\n\n\nSurface Plotting\nA surface plot is like a wireframe plot, but each face of the wireframe is a filled polygon. Adding a colormap to the filled polygons can aid perception of the topology of the surface being visualized:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html",
    "href": "lectures/lecture02/05-lecture02.html",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a new figure\nplt.figure(figsize=(width, height))\n\n# Create a plot\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\n\n# Set labels and title\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\n\n# Add a legend\nplt.legend(['Label'], loc='best')\n\n# Show the plot\nplt.show()\n\n\n\n\nLine plot: plt.plot(x, y)\nScatter plot: plt.scatter(x, y)\nBar plot: plt.bar(x, height)\nHistogram: plt.hist(data, bins=10)\nBox plot: plt.boxplot(data)\nErrorbar plot: plt.errorbar(x, y, yerr=error)\n\n\n\n\n\nSet axis limits: plt.xlim(xmin, xmax), plt.ylim(ymin, ymax)\nSet axis scales: plt.xscale('log'), plt.yscale('log')\nSet tick marks: plt.xticks(ticks, labels), plt.yticks(ticks, labels)\nAdd a grid: plt.grid(True)\nChange line style: plt.plot(x, y, linestyle='--', color='r', linewidth=2)\nChange marker style: plt.plot(x, y, marker='o', markersize=5)\n\n\n\n\n\nSubplots: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\nPlot on specific axes: ax1.plot(x, y)\n\n\n\n\nplt.savefig('filename.png', dpi=300, bbox_inches='tight')\n\n\n\n\nContour plot: plt.contour(X, Y, Z)\n3D plot:\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(X, Y, Z)\n\n\n\n\n\nAdjust layout: plt.tight_layout()\nSet style: plt.style.use('ggplot')\nColormap: plt.imshow(data, cmap='viridis')\n\n\n\n\n\nColors: ‘b’ (blue), ‘g’ (green), ‘r’ (red), ‘c’ (cyan), ‘m’ (magenta), ‘y’ (yellow), ‘k’ (black), ‘w’ (white)\nMarkers: ‘.’ (point), ‘o’ (circle), ‘s’ (square), ‘^’ (triangle up), ‘v’ (triangle down)\nLinestyles: ‘-’ (solid), ‘–’ (dashed), ‘:’ (dotted), ‘-.’ (dash-dot)\n\nRemember to always check the Matplotlib documentation for the most up-to-date and detailed information!"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#basic-plot-setup",
    "href": "lectures/lecture02/05-lecture02.html#basic-plot-setup",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a new figure\nplt.figure(figsize=(width, height))\n\n# Create a plot\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\n\n# Set labels and title\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\n\n# Add a legend\nplt.legend(['Label'], loc='best')\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#common-plot-types",
    "href": "lectures/lecture02/05-lecture02.html#common-plot-types",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Line plot: plt.plot(x, y)\nScatter plot: plt.scatter(x, y)\nBar plot: plt.bar(x, height)\nHistogram: plt.hist(data, bins=10)\nBox plot: plt.boxplot(data)\nErrorbar plot: plt.errorbar(x, y, yerr=error)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#customization",
    "href": "lectures/lecture02/05-lecture02.html#customization",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Set axis limits: plt.xlim(xmin, xmax), plt.ylim(ymin, ymax)\nSet axis scales: plt.xscale('log'), plt.yscale('log')\nSet tick marks: plt.xticks(ticks, labels), plt.yticks(ticks, labels)\nAdd a grid: plt.grid(True)\nChange line style: plt.plot(x, y, linestyle='--', color='r', linewidth=2)\nChange marker style: plt.plot(x, y, marker='o', markersize=5)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#multiple-plots",
    "href": "lectures/lecture02/05-lecture02.html#multiple-plots",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Subplots: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\nPlot on specific axes: ax1.plot(x, y)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#saving-plots",
    "href": "lectures/lecture02/05-lecture02.html#saving-plots",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "plt.savefig('filename.png', dpi=300, bbox_inches='tight')"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#advanced-plots",
    "href": "lectures/lecture02/05-lecture02.html#advanced-plots",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Contour plot: plt.contour(X, Y, Z)\n3D plot:\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(X, Y, Z)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#useful-settings",
    "href": "lectures/lecture02/05-lecture02.html#useful-settings",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Adjust layout: plt.tight_layout()\nSet style: plt.style.use('ggplot')\nColormap: plt.imshow(data, cmap='viridis')"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#common-parameters",
    "href": "lectures/lecture02/05-lecture02.html#common-parameters",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Colors: ‘b’ (blue), ‘g’ (green), ‘r’ (red), ‘c’ (cyan), ‘m’ (magenta), ‘y’ (yellow), ‘k’ (black), ‘w’ (white)\nMarkers: ‘.’ (point), ‘o’ (circle), ‘s’ (square), ‘^’ (triangle up), ‘v’ (triangle down)\nLinestyles: ‘-’ (solid), ‘–’ (dashed), ‘:’ (dotted), ‘-.’ (dash-dot)\n\nRemember to always check the Matplotlib documentation for the most up-to-date and detailed information!"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html",
    "href": "lectures/lecture02/01-summary02.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\ndef function_name(parameter1: type, parameter2: type) -&gt; return_type:\n    # function body\n    return value\n\n\n\nresult = function_name(argument1, argument2)\n\n\n\n\n\n\nfor item in sequence:\n    # code to be executed for each item\nExample:\nfor i in range(1, 11):\n    print(i)\n\n\n\nwhile condition:\n    # code to be executed while condition is true\n    # remember to update the condition\nExample:\ni = 1\nwhile i &lt;= 10:\n    print(i)\n    i += 1\n\n\n\n\n\n\nif condition:\n    # code to be executed if condition is true\n\n\n\nif condition:\n    # code to be executed if condition is true\nelse:\n    # code to be executed if condition is false\n\n\n\nif condition1:\n    # code for condition1\nelif condition2:\n    # code for condition2\nelse:\n    # code if no conditions are true\n\n\n\n\n\nUse descriptive function names\nSpecify parameter and return types for clarity\nIndent properly in loops and conditional statements\nRemember to increment counters in while loops\nUse range() for numeric loops in for statements\nConsider multiple conditions with elif for complex logic"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#python-basics-cheat-sheet",
    "href": "lectures/lecture02/01-summary02.html#python-basics-cheat-sheet",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\ndef function_name(parameter1: type, parameter2: type) -&gt; return_type:\n    # function body\n    return value\n\n\n\nresult = function_name(argument1, argument2)\n\n\n\n\n\n\nfor item in sequence:\n    # code to be executed for each item\nExample:\nfor i in range(1, 11):\n    print(i)\n\n\n\nwhile condition:\n    # code to be executed while condition is true\n    # remember to update the condition\nExample:\ni = 1\nwhile i &lt;= 10:\n    print(i)\n    i += 1\n\n\n\n\n\n\nif condition:\n    # code to be executed if condition is true\n\n\n\nif condition:\n    # code to be executed if condition is true\nelse:\n    # code to be executed if condition is false\n\n\n\nif condition1:\n    # code for condition1\nelif condition2:\n    # code for condition2\nelse:\n    # code if no conditions are true\n\n\n\n\n\nUse descriptive function names\nSpecify parameter and return types for clarity\nIndent properly in loops and conditional statements\nRemember to increment counters in while loops\nUse range() for numeric loops in for statements\nConsider multiple conditions with elif for complex logic"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#functions",
    "href": "lectures/lecture02/01-summary02.html#functions",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "def function_name(parameter1: type, parameter2: type) -&gt; return_type:\n    # function body\n    return value\n\n\n\nresult = function_name(argument1, argument2)"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#loops",
    "href": "lectures/lecture02/01-summary02.html#loops",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "for item in sequence:\n    # code to be executed for each item\nExample:\nfor i in range(1, 11):\n    print(i)\n\n\n\nwhile condition:\n    # code to be executed while condition is true\n    # remember to update the condition\nExample:\ni = 1\nwhile i &lt;= 10:\n    print(i)\n    i += 1"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#conditional-statements",
    "href": "lectures/lecture02/01-summary02.html#conditional-statements",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "if condition:\n    # code to be executed if condition is true\n\n\n\nif condition:\n    # code to be executed if condition is true\nelse:\n    # code to be executed if condition is false\n\n\n\nif condition1:\n    # code for condition1\nelif condition2:\n    # code for condition2\nelse:\n    # code if no conditions are true"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#tips",
    "href": "lectures/lecture02/01-summary02.html#tips",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Use descriptive function names\nSpecify parameter and return types for clarity\nIndent properly in loops and conditional statements\nRemember to increment counters in while loops\nUse range() for numeric loops in for statements\nConsider multiple conditions with elif for complex logic"
  },
  {
    "objectID": "lectures/lecture05/01-lecture05.html",
    "href": "lectures/lecture05/01-lecture05.html",
    "title": "Lecture 5",
    "section": "",
    "text": "Introduction to classes in Python (optional, for organizing code).\nRotational kinematics and dynamics (moment of inertia, angular momentum).\n\n\n\n\n\nSimulating the motion of a rotating object (e.g., a spinning disk) and calculating its angular momentum.\nVisualizing the effect of torque on the object’s rotation.\nHomework: Extend the simulation to include the effect of external forces, such as friction."
  },
  {
    "objectID": "lectures/lecture05/01-lecture05.html#angular-momentum-and-rotational-motion",
    "href": "lectures/lecture05/01-lecture05.html#angular-momentum-and-rotational-motion",
    "title": "Lecture 5",
    "section": "",
    "text": "Introduction to classes in Python (optional, for organizing code).\nRotational kinematics and dynamics (moment of inertia, angular momentum).\n\n\n\n\n\nSimulating the motion of a rotating object (e.g., a spinning disk) and calculating its angular momentum.\nVisualizing the effect of torque on the object’s rotation.\nHomework: Extend the simulation to include the effect of external forces, such as friction."
  },
  {
    "objectID": "lectures/lecture10/01-lecture10.html",
    "href": "lectures/lecture10/01-lecture10.html",
    "title": "Lecture 10",
    "section": "",
    "text": "Introduction to flow simulation and basic fluid mechanics principles (continuity equation, Bernoulli’s equation).\nUsing matplotlib for more advanced visualizations (e.g., vector fields).\n\n\n\n\n\nSimulating fluid flow in simple scenarios (e.g., flow through a pipe, around an object).\nVisualizing pressure and velocity fields.\nHomework: Simulate and visualize a more complex fluid system, such as flow over a wing."
  },
  {
    "objectID": "lectures/lecture10/01-lecture10.html#fluid-dynamics-and-surface-tension",
    "href": "lectures/lecture10/01-lecture10.html#fluid-dynamics-and-surface-tension",
    "title": "Lecture 10",
    "section": "",
    "text": "Introduction to flow simulation and basic fluid mechanics principles (continuity equation, Bernoulli’s equation).\nUsing matplotlib for more advanced visualizations (e.g., vector fields).\n\n\n\n\n\nSimulating fluid flow in simple scenarios (e.g., flow through a pipe, around an object).\nVisualizing pressure and velocity fields.\nHomework: Simulate and visualize a more complex fluid system, such as flow over a wing."
  },
  {
    "objectID": "lectures/lecture09/01-lecture09.html",
    "href": "lectures/lecture09/01-lecture09.html",
    "title": "Lecture 9",
    "section": "",
    "text": "Basic file handling for reading and writing data (e.g., stress-strain data).\nCurve fitting using numpy or scipy to analyze experimental data.\n\n\n\n\n\nSimulating the deformation of a solid under load (e.g., Hooke’s law for springs).\nPlotting stress-strain curves and fitting them to experimental data.\nHomework: Extend the simulation to include plastic deformation or fracture."
  },
  {
    "objectID": "lectures/lecture09/01-lecture09.html#deformation-of-solids",
    "href": "lectures/lecture09/01-lecture09.html#deformation-of-solids",
    "title": "Lecture 9",
    "section": "",
    "text": "Basic file handling for reading and writing data (e.g., stress-strain data).\nCurve fitting using numpy or scipy to analyze experimental data.\n\n\n\n\n\nSimulating the deformation of a solid under load (e.g., Hooke’s law for springs).\nPlotting stress-strain curves and fitting them to experimental data.\nHomework: Extend the simulation to include plastic deformation or fracture."
  },
  {
    "objectID": "lectures/lecture06/01-lecture06.html",
    "href": "lectures/lecture06/01-lecture06.html",
    "title": "Lecture 6",
    "section": "",
    "text": "Advanced conditionals and loops for simulating complex scenarios.\nIntroduction to basic data structures (dictionaries) for handling multiple objects.\n\n\n\n\n\nSimulating elastic and inelastic collisions in one and two dimensions.\nApplying conservation laws (momentum and energy) to check the validity of the simulation.\nVisualization: Plotting the trajectories and velocities of colliding objects.\nHomework: Simulate a multi-object collision scenario."
  },
  {
    "objectID": "lectures/lecture06/01-lecture06.html#collisions-and-conservation-laws",
    "href": "lectures/lecture06/01-lecture06.html#collisions-and-conservation-laws",
    "title": "Lecture 6",
    "section": "",
    "text": "Advanced conditionals and loops for simulating complex scenarios.\nIntroduction to basic data structures (dictionaries) for handling multiple objects.\n\n\n\n\n\nSimulating elastic and inelastic collisions in one and two dimensions.\nApplying conservation laws (momentum and energy) to check the validity of the simulation.\nVisualization: Plotting the trajectories and velocities of colliding objects.\nHomework: Simulate a multi-object collision scenario."
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "Jupyter Notebooks",
    "section": "",
    "text": "A Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.\n\n\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\n\n\n\n\n\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-jupyter-notebook",
    "title": "Jupyter Notebooks",
    "section": "",
    "text": "A Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.\n\n\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\n\n\n\n\n\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "Jupyter Notebooks",
    "section": "Using the Notebook Editor",
    "text": "Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\nEdit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\nCommand mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\nKeyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\nRunning code\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\nv = 23752636\nprint(v)\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "Jupyter Notebooks",
    "section": "Managing the kernel",
    "text": "Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "Jupyter Notebooks",
    "section": "Markdown in Notebooks",
    "text": "Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\nMarkdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\nHere is a blockquote:\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\nAnd Web links:\nJupyter’s website\n\n\nHeadings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\nEmbedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\nLaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\nImages\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\nVideos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.\n\nfrom IPython.display import YouTubeVideo\nYouTubeVideo('QlLx32juGzI',width=600)",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture12/01-lecture12.html",
    "href": "lectures/lecture12/01-lecture12.html",
    "title": "Lecture 12",
    "section": "",
    "text": "Introduction to more advanced simulation techniques (e.g., finite difference methods).\nStructuring a Python project (modules, documentation, testing).\n\n\n\n\n\nSimulating wave propagation, reflection, and transmission in different media.\nVisualization: Animating wave motion and energy transfer.\n\n\n\n- Introduction to the final project, where students choose a physics problem to model and solve using Python.\n- Discussion of project expectations, timelines, and resources.\n- Homework: Start working on the final project by selecting a topic and outlining the approach.\n\n\n\n## Ideal Gas Simulation with Pressure, Gravity, and Collisions\n\nUse the sliders below to adjust the speed of the gas particles and the gravitational force acting on them. The pressure exerted by the particles on the container walls will be displayed.\n\n  Adjust Particle Speed:\n  \n\n\n  Adjust Gravity:\n  \n\nPressure: 0 Pa"
  },
  {
    "objectID": "lectures/lecture12/01-lecture12.html#advanced-waves-and-final-project-introduction",
    "href": "lectures/lecture12/01-lecture12.html#advanced-waves-and-final-project-introduction",
    "title": "Lecture 12",
    "section": "",
    "text": "Introduction to more advanced simulation techniques (e.g., finite difference methods).\nStructuring a Python project (modules, documentation, testing).\n\n\n\n\n\nSimulating wave propagation, reflection, and transmission in different media.\nVisualization: Animating wave motion and energy transfer.\n\n\n\n- Introduction to the final project, where students choose a physics problem to model and solve using Python.\n- Discussion of project expectations, timelines, and resources.\n- Homework: Start working on the final project by selecting a topic and outlining the approach.\n\n\n\n## Ideal Gas Simulation with Pressure, Gravity, and Collisions\n\nUse the sliders below to adjust the speed of the gas particles and the gravitational force acting on them. The pressure exerted by the particles on the container walls will be displayed.\n\n  Adjust Particle Speed:\n  \n\n\n  Adjust Gravity:\n  \n\nPressure: 0 Pa"
  }
]