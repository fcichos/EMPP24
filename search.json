[
  {
    "objectID": "Assignment 4.html",
    "href": "Assignment 4.html",
    "title": "Assignment 3",
    "section": "",
    "text": "Problem 1\nThere are two files with a list of integers a.txt and b.txt. Calculate the greatest common divisors of each pair of values from these files and store them in the file result.txt. Check out the numpy function np.gcd() for this purpose. \nAufgabenstellung klarer!\n\nimport numpy as np\n\nwith open('a.txt', 'r') as file_1, open('b.txt', 'r') as file_2, open('result.txt', 'w') as result:\n    for a, b in zip(file_1, file_2):\n        result.write(f\"{np.gcd(int(a),int(b))}\\n\")\n\n\nfile=open('a.txt','r')\nfile1=open('b.txt','r')\n\n\na=file.readlines()\nb=file1.readlines()\n\n\nlist(zip(a,b))\n\n[('12\\n', '5\\n'),\n ('2\\n', '8\\n'),\n ('4\\n', '4\\n'),\n ('3\\n', '6\\n'),\n ('4', '87\\n')]\n\n\nProblem 2\nAssign the 100 numbers between -10 and 10 including -10 and 10 to the variable x using the linspace function of numpy. Assign the function values ( x²-20 ) to the variable y. Store the paired values in the file named “data.txt” in the form “x, y” (e.g. -10, 80) for each line of the file.\nLeerzeichen war die Falle!\n\nimport numpy as np\n\nx=np.linspace(-10,10,100)\ny=x**2-20\n\nwith open('data.txt', 'w') as file:\n    for x, y in zip(x, y):\n        file.write(f\"{x}, {y}\\n\")\n\nProblem 3\nWrite a Python function projectile_motion(v0, theta, dt) that simulates the projectile motion of an object launched at an initial velocity v0 (in m/s) and angle theta (in degrees). The function should return a tuple containing:\nThe maximum height reached by the object (in meters). The total time of flight (in seconds). The horizontal range (in meters).\nUse a time step dt (in seconds) for the simulation. Advance the time inside the function with a loop. Note that calling the function is not required for the task! Can be done only with the math module. \nWhat if one of the arguments is 0?\nAufgabenstellung klarer!\n\nimport math\n\ndef projectile_motion(v0, theta, dt):\n    if(v0 == 0 or theta == 0 or dt == 0): return (0,0,0)\n    \n    theta_rad = math.radians(theta)\n    \n    v0x = v0 * math.cos(theta_rad)\n    v0y = v0 * math.sin(theta_rad)\n    \n    x_points = []\n    y_points = []\n    \n    x = 0\n    y = 0\n    t = 0\n    \n    while y &gt;= 0:\n        x = v0x * t\n        y = v0y * t - 0.5 * 9.81 * t**2\n        x_points.append(x)\n        y_points.append(y)\n        t += dt\n    \n    max_height = max(y_points)\n    total_time = t - dt\n    horizontal_range = x_points[-1]\n    \n    return (max_height, total_time, horizontal_range)\n\n\nx=np.linspace(0,10,100)-5\ny=np.linspace(0,10,100)-5\n\n\nX,Y=np.meshgrid(x,y)\n\n\nr=np.sqrt(X**2+Y**2)\n\n\n\nimport matplotlib.pyplot as plt\n\n\nplt.contour(r)"
  },
  {
    "objectID": "lectures/lecture12/01-lecture12.html",
    "href": "lectures/lecture12/01-lecture12.html",
    "title": "Lecture 12",
    "section": "",
    "text": "Introduction to more advanced simulation techniques (e.g., finite difference methods).\nStructuring a Python project (modules, documentation, testing).\n\n\n\n\n\nSimulating wave propagation, reflection, and transmission in different media.\nVisualization: Animating wave motion and energy transfer.\n\n\n\n- Introduction to the final project, where students choose a physics problem to model and solve using Python.\n- Discussion of project expectations, timelines, and resources.\n- Homework: Start working on the final project by selecting a topic and outlining the approach.\n\n\n\n## Ideal Gas Simulation with Pressure, Gravity, and Collisions\n\nUse the sliders below to adjust the speed of the gas particles and the gravitational force acting on them. The pressure exerted by the particles on the container walls will be displayed.\n\n  Adjust Particle Speed:\n  \n\n\n  Adjust Gravity:\n  \n\nPressure: 0 Pa"
  },
  {
    "objectID": "lectures/lecture12/01-lecture12.html#advanced-waves-and-final-project-introduction",
    "href": "lectures/lecture12/01-lecture12.html#advanced-waves-and-final-project-introduction",
    "title": "Lecture 12",
    "section": "",
    "text": "Introduction to more advanced simulation techniques (e.g., finite difference methods).\nStructuring a Python project (modules, documentation, testing).\n\n\n\n\n\nSimulating wave propagation, reflection, and transmission in different media.\nVisualization: Animating wave motion and energy transfer.\n\n\n\n- Introduction to the final project, where students choose a physics problem to model and solve using Python.\n- Discussion of project expectations, timelines, and resources.\n- Homework: Start working on the final project by selecting a topic and outlining the approach.\n\n\n\n## Ideal Gas Simulation with Pressure, Gravity, and Collisions\n\nUse the sliders below to adjust the speed of the gas particles and the gravitational force acting on them. The pressure exerted by the particles on the container walls will be displayed.\n\n  Adjust Particle Speed:\n  \n\n\n  Adjust Gravity:\n  \n\nPressure: 0 Pa"
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "Jupyter Notebooks",
    "section": "",
    "text": "A Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.\n\n\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\nFull Screen\n\n\n\n\n\n\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-jupyter-notebook",
    "title": "Jupyter Notebooks",
    "section": "",
    "text": "A Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.\n\n\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\nFull Screen\n\n\n\n\n\n\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "Jupyter Notebooks",
    "section": "Using the Notebook Editor",
    "text": "Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\nEdit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\nCommand mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\nKeyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\nRunning code\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\nv = 23752636\nprint(v)\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "Jupyter Notebooks",
    "section": "Managing the kernel",
    "text": "Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "Jupyter Notebooks",
    "section": "Markdown in Notebooks",
    "text": "Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\nMarkdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\nHere is a blockquote:\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\nAnd Web links:\nJupyter’s website\n\n\nHeadings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\nEmbedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\nLaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\nImages\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\nVideos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.\n\nfrom IPython.display import YouTubeVideo\nYouTubeVideo('QlLx32juGzI',width=600)",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/3_datatypes.html",
    "href": "lectures/lecture01/3_datatypes.html",
    "title": "Data Types",
    "section": "",
    "text": "It’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe following few cells will give you a short introduction into each type."
  },
  {
    "objectID": "lectures/lecture01/3_datatypes.html#strings",
    "href": "lectures/lecture01/3_datatypes.html#strings",
    "title": "Data Types",
    "section": "Strings",
    "text": "Strings\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example."
  },
  {
    "objectID": "lectures/lecture01/3_datatypes.html#quiz-data-types-in-python",
    "href": "lectures/lecture01/3_datatypes.html#quiz-data-types-in-python",
    "title": "Data Types",
    "section": "Quiz: Data Types in Python",
    "text": "Quiz: Data Types in Python\nLet’s test your understanding of Python data types!\n\n\nWhat is the output of the following code?\na = [1, 2, 3]\nb = (1, 2, 3)\nprint(type(a), type(b))\n\n&lt;class 'list'&gt; &lt;class 'list'&gt;\n&lt;class 'list'&gt; &lt;class 'tuple'&gt;\n&lt;class 'tuple'&gt; &lt;class 'list'&gt;\n&lt;class 'tuple'&gt; &lt;class 'tuple'&gt;\n\nWhich of the following is mutable?\n\nList\nTuple\nString\nInteger\n\nWhat will be the output of this code?\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\nprint(my_dict['b'])\n\na\n2\nb\nKeyError\n\nHow do you create an empty set in Python?\n\n{}\n[]\nset()\n()\n\nWhat is the result of 3 + 4.0?\n\n7\n7.0\n‘7.0’\nTypeError\n\n\n\n\n\n\n\n\n\nClick to reveal answers\n\n\n\n\n\n\n&lt;class 'list'&gt; &lt;class 'tuple'&gt;\nList\n2\nset()\n7.0"
  },
  {
    "objectID": "lectures/lecture06/1_input_output.html",
    "href": "lectures/lecture06/1_input_output.html",
    "title": "Input and output",
    "section": "",
    "text": "To try out all of the functions of todays notebook, we will need to use the embedded JupyterLite notebook. To use the notebook, click ob File -&gt; Open from URL and paste the following link into the input field:\nhttps://raw.githubusercontent.com/fcichos/EMPP24/refs/heads/main/seminars/1_input_output.ipynb\nTo download the data files, click ob File -&gt; Open from URL and paste the following links into the input field:\nhttps://raw.githubusercontent.com/fcichos/EMPP24/refs/heads/main/seminars/MyData.txt\nhttps://raw.githubusercontent.com/fcichos/EMPP24/refs/heads/main/seminars/2018-04-11_sds011_sensor_12253.csv\nhttps://raw.githubusercontent.com/fcichos/EMPP24/refs/heads/main/seminars/2018-04-12_sds011_sensor_12253.csv\nYou should then have 3 data files and one notebook. You can then go into fullscreen mode.\nFull Screen",
    "crumbs": [
      "Python Basics",
      "Lecture 6",
      "Input Output"
    ]
  },
  {
    "objectID": "lectures/lecture06/1_curve_fitting.html",
    "href": "lectures/lecture06/1_curve_fitting.html",
    "title": "Curve fitting",
    "section": "",
    "text": "Let’s take a break from physics-related topics and explore another crucial area: curve fitting. We’ll focus on demonstrating how to apply the least-squares method to fit a quadratic function with three parameters to experimental data. It’s worth noting that this approach can be applied to more complex functions or even simpler linear models.\nBefore diving into the fitting process, it’s essential to consider how to best estimate your model parameters. In some cases, you may be able to derive explicit estimators for the parameters, which can simplify the fitting procedure. Therefore, it’s advisable to carefully consider your approach before beginning the actual fitting process.\nFor those who want to delve deeper into this subject, you might find it interesting to explore concepts like maximum likelihood estimation. This method offers an alternative approach to parameter estimation and can provide valuable insights in certain scenarios."
  },
  {
    "objectID": "lectures/lecture06/1_curve_fitting.html#idea",
    "href": "lectures/lecture06/1_curve_fitting.html#idea",
    "title": "Curve fitting",
    "section": "Idea",
    "text": "Idea\nIn experimental physics, we often collect data points to understand the underlying physical phenomena. This process involves fitting a mathematical model to the experimental data.\nThe data typically comes as a series of paired points:\n\n\n\nx-data\ny-data\n\n\n\n\n\\(x_{1}\\)\n\\(y_{1}\\)\n\n\n\\(x_{2}\\)\n\\(y_{2}\\)\n\n\n…\n…\n\n\n\\(x_{N}\\)\n\\(y_{N}\\)\n\n\n\nEach point \\(\\{x_i, y_i\\}\\) may represent the result of multiple independent measurements. For instance, \\(y_1\\) could be the mean of several measurements \\(y_{1,j}\\):\n\\[y_1 = \\frac{1}{N}\\sum_{j=1}^N y_{1,j}\\]\nWhen these measurements have an uncertainty \\(\\sigma\\) for individual readings, the sum of all measurements has a variance of \\(N\\sigma^2\\) and a standard deviation of \\(\\sqrt{N}\\sigma\\). Consequently, the mean value has an associated error (standard deviation) known as the Standard Error of the Mean (SEOM):\n\\[\\sigma_{SEOM} = \\frac{\\sigma}{\\sqrt{N}}\\]\nThis SEOM is crucial in physics measurements.\nIt’s also important to note the definition of variance:\n\\[\\sigma_1^2 = \\frac{1}{N} \\sum_{j=1}^N (y_{1,j} - y_1)^2\\]\nThis statistical framework forms the basis for analyzing experimental data and fitting mathematical models to understand the underlying physics."
  },
  {
    "objectID": "lectures/lecture06/1_curve_fitting.html#least-squares",
    "href": "lectures/lecture06/1_curve_fitting.html#least-squares",
    "title": "Curve fitting",
    "section": "Least squares",
    "text": "Least squares\nIn experimental physics, we often collect data points to understand the underlying physical phenomena. To make sense of this data, we fit a mathematical model to it. One common method for fitting data is the least squares method.\n\nWhy use least squares fitting?\nThe goal of least squares fitting is to find the set of parameters for our model that best describes the data. This is done by minimizing the differences (or residuals) between the observed data points and the model’s predictions.\n\n\nGaussian uncertainty and probability\nWhen we take measurements, there is always some uncertainty. Often, this uncertainty can be modeled using a Gaussian (normal) distribution. This distribution is characterized by its mean (average value) and standard deviation (a measure of the spread of the data).\nIf we describe our data with a model function, which delivers a function value \\(f(x_{i},a)\\) for a set of parameters \\(a\\) at the position \\(x_{i}\\), the Gaussian uncertainty dictates a probability of finding a data value \\(y_{i}\\):\n\\[\\begin{equation}\np_{y_{i}}=\\frac{1}{\\sqrt{2\\pi}\\sigma_{i}}\\exp\\left(-\\frac{(y_{i}-f(x_{i},a))^2}{2\\sigma_{i}^2}\\right)\n\\end{equation}\\]\nHere, \\(\\sigma_{i}\\) represents the uncertainty in the measurement \\(y_{i}\\).\n\n\nCombining probabilities for multiple data points\nTo understand how well our model fits all the data points, we need to consider the combined probability of observing all the data points. This is done by multiplying the individual probabilities:\n\\[\\begin{equation}\np(y_{1},\\ldots,y_{N})=\\prod_{i=1}^{N}\\frac{1}{\\sqrt{2\\pi}\\sigma_{i}}\\exp\\left(-\\frac{(y_{i}-f(x_{i},a))^2}{2\\sigma_{i}^2}\\right)\n\\end{equation}\\]\n\n\nMaximizing the joint probability\nThe best fit of the model to the data is achieved when this joint probability is maximized. To simplify the calculations, we take the logarithm of the joint probability:\n\\[\\begin{equation}\n\\ln(p(y_{1},\\ldots,y_{N}))=-\\frac{1}{2}\\sum_{i=1}^{N}\\left( \\frac{y_{i}-f(x_{i},a)}{\\sigma_{i}}\\right)^2 - \\sum_{i=1}^{N}\\ln\\left( \\sigma_{i}\\sqrt{2\\pi}\\right)\n\\end{equation}\\]\nThe first term on the right side (except the factor 1/2) is the least squared deviation, also known as \\(\\chi^{2}\\):\n\\[\\begin{equation}\n\\chi^{2} =\\sum_{i=1}^{N}\\left( \\frac{y_{i}-f(x_{i},a)}{\\sigma_{i}}\\right)^2\n\\end{equation}\\]\nThe second term is just a constant value given by the uncertainties of our experimental data."
  },
  {
    "objectID": "lectures/lecture06/1_curve_fitting.html#data",
    "href": "lectures/lecture06/1_curve_fitting.html#data",
    "title": "Curve fitting",
    "section": "Data",
    "text": "Data\nLet’s have a look at the meaning of this equation. Let’s assume we measure the trajectory of a ball that has been thrown at an angle \\(\\alpha\\) with an initial velocity \\(v_{0}\\). We have collected data points by measuring the height of the ball above the ground at equally spaced distances from the throwing person.\n\n\n\n\n    \n      \n      x\n      y\n      error\n    \n  \n\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n\n\nLoading ITables v2.2.2 from the internet...\n(need help?)\n\n\n\n\n\n\n\n\nThe table above shows the measured data points \\(y_{i}\\) at the position \\(x_{i}\\) with the associated uncertainties \\(\\sigma_{i}\\).\nWe can plot the data and expect, of course, a parabola. Therefore, we model our experimental data with a parabola like\n\\[\\begin{equation}\ny = ax^2 + bx + c\n\\end{equation}\\]\nwhere the parameter \\(a\\) must be negative since the parabola is inverted.\nI have created an interactive plot with an interact widget, as this allows you to play around with the parameters. The value of \\(\\chi^2\\) is also included in the legend, so you can get an impression of how good your fit of the data is.\n\nviewof aSlider = Inputs.range([-4, 0], { label: \"a\", step: 0.01, value: -1.7 });\nviewof bSlider = Inputs.range([-2, 2], { label: \"b\", step: 0.01, value: 1.3 });\nviewof cSlider = Inputs.range([-2, 2], { label: \"c\", step: 0.01, value: 1.0 });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered = transpose(data);\n// Create the plot\n\nxValues = Array.from({ length: 100 }, (_, i) =&gt; i / 100);\nparabolaData = xValues.map(x =&gt; ({ x, y: parabola(x, aSlider, bSlider, cSlider) }));\n\n\nparabola = (x, a, b, c) =&gt; a * x**2 + b * x + c\n\ncalculateChiSquared = (data, a, b, c) =&gt; {\n  let chisq = 0\n  let x= data.map(d =&gt; d.x)\n  let y= data.map(d =&gt; d.y)\n  let err= data.map(d =&gt; d.error)\n  for (let i = 0; i &lt; x.length; i++) {\n    let y_model = parabola(x[i], a, b, c)\n    chisq += ((y[i] - y_model) / err[i])**2\n  }\n  return chisq\n}\n\nchisq = calculateChiSquared(filtered, aSlider, bSlider, cSlider)\n\nPlot.plot({\n  marks: [\n    Plot.dot(filtered, { x: \"x\", y: \"y\" }),\n    Plot.ruleY(filtered, { x: \"x\", y1: d =&gt; d.y - d.error, y2: d =&gt; d.y + d.error }),\n    Plot.line(parabolaData, { x: \"x\", y: \"y\" }),\n    Plot.text([{ x: 0.8, y: 1.5, label: `χ²: ${chisq.toFixed(2)}` }], {\n          x: \"x\",\n          y: \"y\",\n          text: \"label\",\n          dy: -10, // Adjust vertical position if needed\n          fill: \"black\", // Set text color\n          fontSize: 16\n        }),\n    Plot.frame()\n  ],\n  x: {\n    label: \"X Axis\",\n    labelAnchor: \"center\",\n    labelOffset: 35,\n    grid: true,\n    tickFormat: \".2f\", // Format ticks to 2 decimal places\n    domain: [0, 1]\n  },\n  y: {\n    label: \"Y Axis\",\n    grid: true,\n    tickFormat: \".2f\", // Format ticks to 2 decimal places\n    labelAnchor: \"center\",  // Center the label on its axis\n    labelAngle: -90,\n    labelOffset: 60,\n    domain: [0, 2],\n  },\n  width: 400,\n  height: 400,\n  marginLeft: 100,\n  marginBottom: 40,\n  style: {\n    fontSize: \"14px\",          // This sets the base font size\n    \"axis.label\": {\n      fontSize: \"18px\",        // This sets the font size for axis labels\n      fontWeight: \"bold\"       // Optionally make it bold\n    },\n    \"axis.tick\": {\n      fontSize: \"14px\"         // This sets the font size for tick labels\n    }\n  },\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe have that troubling point at the right edge with a large uncertainty. However, since the value of \\(\\chi^2\\) divides the deviation by the uncertainty \\(\\sigma_{i}\\), the weight for this point overall in the \\(\\chi^2\\) is smaller than for the other points.\n\\[\\begin{equation}\n\\chi^{2}=\\sum_{i=1}^{N}\\left( \\frac{y_{i}-f(x_{i},a)}{\\sigma_{i}}\\right)^2\n\\end{equation}\\]\nYou may simply check the effect by changing the uncertainty of the last data points in the error array."
  },
  {
    "objectID": "lectures/lecture06/1_curve_fitting.html#least-square-fitting",
    "href": "lectures/lecture06/1_curve_fitting.html#least-square-fitting",
    "title": "Curve fitting",
    "section": "Least square fitting",
    "text": "Least square fitting\nTo find the best fit of the model to the experimental data, we use the least squares method. This method minimizes the sum of the squared differences between the observed data points and the model’s predictions.\nMathematically, we achieve this by minimizing the least squares, i.e., finding the parameters \\(a\\) that minimize the following expression:\n\\[\\begin{equation}\n\\frac{d\\chi^{2}}{da}=\\sum_{i=1}^{N}\\frac{1}{\\sigma_{i}^2}\\frac{df(x_{i},a)}{da}[y_{i}-f(x_{i},a)]=0\n\\end{equation}\\]\nThis kind of least squares minimization is done by fitting software using different types of algorithms.\n\nFitting with SciPy\nLet’s do some fitting using the SciPy library, which is a powerful tool for scientific computing in Python. We will use the curve_fit method from the optimize sub-module of SciPy.\nFirst, we need to define the model function we would like to fit to the data. In this case, we will use our parabola function:\n\n\n\n\n\n\nNext, we need to provide initial guesses for the parameters. These initial guesses help the fitting algorithm start the search for the optimal parameters:\n\n\n\n\n\n\nWe then call the curve_fit function to perform the fitting:\n\n\n\n\n\n\n\n\n\n\n\n\ncurve_fit Function\n\n\n\n\n\nThe curve_fit function is used to fit a model function to data. It finds the optimal parameters for the model function that minimize the sum of the squared residuals between the observed data and the model’s predictions.\n\nParameters\n\nparabola:\n\nThis is the model function that you want to fit to the data. In this case, parabola is a function that represents a quadratic equation of the form ( y = ax^2 + bx + c ).\n\nx_data:\n\nThis is the array of independent variable data points (the x-values).\n\ny_data:\n\nThis is the array of dependent variable data points (the y-values).\n\nsigma=err:\n\nThis parameter specifies the uncertainties (standard deviations) of the y-data points. The err array contains the uncertainties for each y-data point. These uncertainties are used to weight the residuals in the least squares optimization.\n\np0=init_guess:\n\nThis parameter provides the initial guesses for the parameters of the model function. The init_guess array contains the initial guesses for the parameters ( a ), ( b ), and ( c ). Providing good initial guesses can help the optimization algorithm converge more quickly and accurately.\n\nabsolute_sigma=True:\n\nThis parameter indicates whether the provided sigma values are absolute uncertainties. If absolute_sigma is set to True, the sigma values are treated as absolute uncertainties. If absolute_sigma is set to False, the sigma values are treated as relative uncertainties, and the covariance matrix of the parameters will be scaled accordingly.\n\n\n\n\nReturn Value\nThe curve_fit function returns two values:\n\npopt:\n\nAn array containing the optimal values for the parameters of the model function that minimize the sum of the squared residuals.\n\npcov:\n\nThe covariance matrix of the optimal parameters. The diagonal elements of this matrix provide the variances of the parameter estimates, and the off-diagonal elements provide the covariances between the parameter estimates.\n\n\n\n\n\n\nThe fit variable contains the results of the fitting process. It is composed of various results, which we can split into the fitted parameters and the covariance matrix:\n\n\n\n\n\n\nThe ans variable contains the fitted parameters fit_a, fit_b, and fit_c, while the cov variable contains the covariance matrix. Let’s have a look at the fit and the \\(\\chi^{2}\\) value first:\n\n\n\n\n\n\nWe can then plot the fitted curve along with the original data points and the \\(\\chi^{2}\\) value:\n\n\n\n\n\n\n\n\n\\(\\chi\\)-squared value\nThe value of \\(\\chi^2\\) gives you a measure of the quality of the fit. We can judge the quality by calculating the expectation value of \\(\\chi^2\\):\n\\[\\begin{equation}\n\\langle \\chi^{2}\\rangle =\\sum_{i=1}^{N} \\frac{\\langle (y_{i}-f(x_{i},a) )^2\\rangle }{\\sigma_{i}^2}=\\sum_{i=1}^{N} \\frac{\\sigma_{i}^2}{\\sigma_{i}^2}=N\n\\end{equation}\\]\nSo, the mean of the least squared deviation increases with the number of data points. Therefore:\n\n\\(\\chi^{2} \\gg N\\) means that the fit is bad.\n\\(\\chi^{2} &lt; N\\) means that the uncertainties are wrong.\n\nThe first case may occur if you don’t have a good fit to your data, for example, if you are using the wrong model. The second case typically occurs if you don’t have accurate estimates of the uncertainties and you assume all uncertainties to be constant.\nIt is really important to have a good estimate of the uncertainties and to include them in your fit. If you include the uncertainties in your fit, it is called a weighted fit. If you don’t include the uncertainties (meaning you keep them constant), it is called an unweighted fit.\nFor our fit above, we obtain a \\(\\chi^{2}\\) which is on the order of \\(N=10\\), which tells you that I have created the data with reasonable accuracy.\n\n\nResiduals\nAnother way to assess the quality of the fit is by looking at the residuals. Residuals are defined as the deviation of the data from the model for the best fit:\n\\[\\begin{equation}\nr_i = y_i - f(x_{i},a)\n\\end{equation}\\]\nThe residuals can also be expressed as the percentage of the deviation of the data from the fit:\n\\[\\begin{equation}\nr_i = 100 \\left( \\frac{y_i - f(x_{i},a)}{y_i} \\right)\n\\end{equation}\\]\n\n\nImportance of Residuals\nResiduals are important because they provide insight into how well the model fits the data. If the residuals show only statistical fluctuations around zero, then the fit and likely also the model are good. However, if there are systematic patterns in the residuals, it may indicate that the model is not adequately capturing the underlying relationship in the data.\n\n\nVisualizing Residuals\nLet’s visualize the residuals to better understand their distribution. We will plot the residuals as a function of the independent variable \\(x\\).\n\n\n\n\n\n\n\n\n\n\n\n\nCommon Patterns in Residuals\n\n\n\n\n\nRandom Fluctuations Around Zero:\n\nIf the residuals are randomly scattered around zero, it suggests that the model is a good fit for the data.\n\nSystematic Patterns:\n\nIf the residuals show a systematic pattern (e.g., a trend or periodicity), it may indicate that the model is not capturing some aspect of the data. This could suggest the need for a more complex model.\n\nIncreasing or Decreasing Trends:\n\nIf the residuals increase or decrease with \\(x\\), it may indicate heteroscedasticity (non-constant variance) or that a different functional form is needed."
  },
  {
    "objectID": "lectures/lecture06/1_curve_fitting.html#covariance-matrix",
    "href": "lectures/lecture06/1_curve_fitting.html#covariance-matrix",
    "title": "Curve fitting",
    "section": "Covariance Matrix",
    "text": "Covariance Matrix\nIn the previous sections, we discussed how to fit a model to experimental data and assess the quality of the fit using residuals. Now, let’s take a closer look at the uncertainties in the fit parameters and how they are related to each other. This is where the covariance matrix comes into play.\n\nPurpose of the Covariance Matrix\nThe covariance matrix provides important information about the uncertainties in the fit parameters and how these uncertainties are related to each other. It helps us understand the precision of the parameter estimates and whether the parameters are independent or correlated.\n\n\nUnderstanding Covariance\nCovariance is a measure of how much two random variables change together. If the covariance between two variables is positive, it means that they tend to increase or decrease together. If the covariance is negative, it means that one variable tends to increase when the other decreases. If the covariance is zero, it means that the variables are independent.\n\n\nCovariance Matrix in Curve Fitting\nWhen we fit a model to data, we obtain estimates for the parameters of the model. These estimates have uncertainties due to the measurement errors in the data. The covariance matrix quantifies these uncertainties and the relationships between them.\nFor a model with three parameters \\((a, b, c)\\), the covariance matrix is a \\(3 \\times 3\\) matrix that looks like this:\n\\[\\begin{equation}\n{\\rm cov}(p_{i}, p_{j}) =\n\\begin{bmatrix}\n\\sigma_{aa}^{2} & \\sigma_{ab}^{2} & \\sigma_{ac}^{2} \\\\\n\\sigma_{ba}^{2} & \\sigma_{bb}^{2} & \\sigma_{bc}^{2} \\\\\n\\sigma_{ca}^{2} & \\sigma_{cb}^{2} & \\sigma_{cc}^{2}\n\\end{bmatrix}\n\\end{equation}\\]\nThe diagonal elements provide the variances (squared uncertainties) of the fit parameters, while the off-diagonal elements describe the covariances between the parameters.\n\n\nExample\nLet’s calculate the covariance matrix for our fitted model and interpret the results.\n\n\n\n\n\n\n\n\nInterpreting the Covariance Matrix\nThe covariance matrix provides valuable information about the uncertainties in the fit parameters:\n\nDiagonal Elements: The diagonal elements represent the variances of the parameters. The square root of these values gives the standard deviations (uncertainties) of the parameters.\nOff-Diagonal Elements: The off-diagonal elements represent the covariances between the parameters. If these values are large, it indicates that the parameters are correlated.\n\n\n\nGenerating Synthetic Data\nTo better understand the covariance matrix, let’s generate synthetic data and fit the model to each dataset. This will help us visualize the uncertainties in the parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCorrelation Matrix\nTo better understand the relationships between the parameters, we can normalize the covariance matrix to obtain the correlation matrix. The correlation matrix has values between -1 and 1, where 1 indicates perfect positive correlation, -1 indicates perfect negative correlation, and 0 indicates no correlation.\n\n\n\n\n\n\n\n\nVisualizing the Covariance and Correlation\nLet’s visualize the covariance and correlation between the parameters using scatter plots.\n\n\n\n\n\n\nBy examining the covariance and correlation matrices, we can gain a deeper understanding of the uncertainties in the fit parameters and how they are related to each other.\n\n\nImproving the Model\nIf we find that the parameters are highly correlated, we might want to find a better model containing more independent parameters. For example, we can write down a different model:\n\\[\\begin{equation}\ny = a(x - b)^2 + c\n\\end{equation}\\]\nThis model also contains three parameters, but the parameter \\(b\\) directly refers to the maximum of our parabola, while the parameter \\(a\\) denotes its curvature.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe see from the covariance matrix that the new model has a smaller correlation of the parameters with each other.\n\n\n\n\n\n\nThis is also expressed by our correlation matrix.\n\n\n\n\n\n\nBy examining the covariance and correlation matrices, we can gain valuable insights into the uncertainties in the fit parameters and how to improve our model."
  },
  {
    "objectID": "lectures/lecture08/2_integration.html",
    "href": "lectures/lecture08/2_integration.html",
    "title": "Numerical Integration",
    "section": "",
    "text": "This lecture covers numerical integration methods, which are essential for computing definite integrals of functions. We’ll explore three different methods with increasing accuracy: the Box method, Trapezoid method, and Simpson’s method.",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "lectures/lecture08/2_integration.html#box-method-rectangle-method",
    "href": "lectures/lecture08/2_integration.html#box-method-rectangle-method",
    "title": "Numerical Integration",
    "section": "Box Method (Rectangle Method)",
    "text": "Box Method (Rectangle Method)\n\n\n\nBox Method Illustration\n\n\nThe Box method is the simplest approach for numerical integration. It approximates the function in each interval \\(\\Delta x\\) with a constant value taken at the left endpoint of the interval.\n\\[\\begin{equation}\n\\int_{a}^{b} f(x) dx \\approx \\sum_{i=1}^{N} f(x_{i}) \\Delta x\n\\end{equation}\\]",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "lectures/lecture08/2_integration.html#trapezoid-method",
    "href": "lectures/lecture08/2_integration.html#trapezoid-method",
    "title": "Numerical Integration",
    "section": "Trapezoid Method",
    "text": "Trapezoid Method\n\n\n\nTrapezoid Method Illustration\n\n\nThe Trapezoid method improves upon the Box method by approximating the function with linear segments between points.\n\\[\\begin{equation}\n\\int_{a}^{b} f(x) dx \\approx \\sum_{i=1}^{N} \\frac{f(x_i) + f(x_{i-1})}{2} \\Delta x\n\\end{equation}\\]",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "lectures/lecture08/2_integration.html#simpsons-method",
    "href": "lectures/lecture08/2_integration.html#simpsons-method",
    "title": "Numerical Integration",
    "section": "Simpson’s Method",
    "text": "Simpson’s Method\n\n\n\nSimpson’s Method Illustration\n\n\nSimpson’s method provides higher accuracy by approximating the function with parabolic segments.\n\\[\\begin{equation}\n\\int_{a}^{b} f(x) dx \\approx \\frac{\\Delta x}{3} \\sum_{i=1}^{(N-1)/2} \\left(f(x_{i-1}) + 4f(x_i) + f(x_{i+1})\\right)\n\\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\nSimpson’s Rule for Numerical Integration\n\n\n\n\n\nSimpson’s Rule is a method for numerical integration that approximates the definite integral of a function by using quadratic polynomials.\n\nFor an integral \\(\\int_a^b f(x)dx\\), Simpson’s Rule fits a quadratic function through three points:\n\n\\(f(a)\\)\n\\(f(\\frac{a+b}{2})\\)\n\\(f(b)\\)\n\nLet’s define:\n\n\\(h = \\frac{b-a}{2}\\)\n\\(x_0 = a\\)\n\\(x_1 = \\frac{a+b}{2}\\)\n\\(x_2 = b\\)\n\nThe quadratic approximation has the form: \\[P(x) = Ax^2 + Bx + C\\]\nThis polynomial must satisfy: \\[f(x_0) = Ax_0^2 + Bx_0 + C\\] \\[f(x_1) = Ax_1^2 + Bx_1 + C\\] \\[f(x_2) = Ax_2^2 + Bx_2 + C\\]\nUsing Lagrange interpolation: \\[P(x) = f(x_0)L_0(x) + f(x_1)L_1(x) + f(x_2)L_2(x)\\]\nwhere \\(L_0\\), \\(L_1\\), \\(L_2\\) are the Lagrange basis functions.\n\n\nFinal Formula\nThe integration of this polynomial leads to Simpson’s Rule:\n\\[\\int_a^b f(x)dx \\approx \\frac{h}{3}[f(a) + 4f(\\frac{a+b}{2}) + f(b)]\\]\n\n\nError Term\nThe error in Simpson’s Rule is proportional to:\n\\[-\\frac{h^5}{90}f^{(4)}(\\xi)\\]\nfor some \\(\\xi \\in [a,b]\\)\n\n\nComposite Simpson’s Rule\nFor better accuracy, we can divide the interval into \\(n\\) subintervals (where \\(n\\) is even):\n\\[\\int_a^b f(x)dx \\approx \\frac{h}{3}[f(x_0) + 4\\sum_{i=1}^{n/2}f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1}f(x_{2i}) + f(x_n)]\\]\nwhere \\(h = \\frac{b-a}{n}\\)\nThe method is particularly effective for integrating functions that can be well-approximated by quadratic polynomials over small intervals.",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "lectures/lecture08/2_integration.html#comparison-of-methods",
    "href": "lectures/lecture08/2_integration.html#comparison-of-methods",
    "title": "Numerical Integration",
    "section": "Comparison of Methods",
    "text": "Comparison of Methods\nLet’s compare the accuracy of all three methods:",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "lectures/lecture08/2_integration.html#error-analysis",
    "href": "lectures/lecture08/2_integration.html#error-analysis",
    "title": "Numerical Integration",
    "section": "Error Analysis",
    "text": "Error Analysis\nThe three methods have different convergence rates:\n\nBox Method: Error ∝ \\(\\Delta x\\) (linear convergence)\nTrapezoid Method: Error ∝ \\(\\Delta x^2\\) (quadratic convergence)\nSimpson’s Method: Error ∝ \\(\\Delta x^4\\) (fourth-order convergence)\n\nThis explains why Simpson’s method typically achieves higher accuracy with fewer points. For example, doubling the number of points in Simpson’s method reduces the error by a factor of 16",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "lectures/lecture09/01-lecture09.html",
    "href": "lectures/lecture09/01-lecture09.html",
    "title": "Lecture 9",
    "section": "",
    "text": "Basic file handling for reading and writing data (e.g., stress-strain data).\nCurve fitting using numpy or scipy to analyze experimental data.\n\n\n\n\n\nSimulating the deformation of a solid under load (e.g., Hooke’s law for springs).\nPlotting stress-strain curves and fitting them to experimental data.\nHomework: Extend the simulation to include plastic deformation or fracture."
  },
  {
    "objectID": "lectures/lecture09/01-lecture09.html#deformation-of-solids",
    "href": "lectures/lecture09/01-lecture09.html#deformation-of-solids",
    "title": "Lecture 9",
    "section": "",
    "text": "Basic file handling for reading and writing data (e.g., stress-strain data).\nCurve fitting using numpy or scipy to analyze experimental data.\n\n\n\n\n\nSimulating the deformation of a solid under load (e.g., Hooke’s law for springs).\nPlotting stress-strain curves and fitting them to experimental data.\nHomework: Extend the simulation to include plastic deformation or fracture."
  },
  {
    "objectID": "lectures/lecture07/1_curve_fitting.html",
    "href": "lectures/lecture07/1_curve_fitting.html",
    "title": "Curve fitting",
    "section": "",
    "text": "Let’s take a break from physics-related topics and explore another crucial area: curve fitting. We’ll focus on demonstrating how to apply the least-squares method to fit a quadratic function with three parameters to experimental data. It’s worth noting that this approach can be applied to more complex functions or even simpler linear models.\nBefore diving into the fitting process, it’s essential to consider how to best estimate your model parameters. In some cases, you may be able to derive explicit estimators for the parameters, which can simplify the fitting procedure. Therefore, it’s advisable to carefully consider your approach before beginning the actual fitting process.\nFor those who want to delve deeper into this subject, you might find it interesting to explore concepts like maximum likelihood estimation. This method offers an alternative approach to parameter estimation and can provide valuable insights in certain scenarios.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Curve Fitting"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_curve_fitting.html#idea",
    "href": "lectures/lecture07/1_curve_fitting.html#idea",
    "title": "Curve fitting",
    "section": "Idea",
    "text": "Idea\nIn experimental physics, we often collect data points to understand the underlying physical phenomena. This process involves fitting a mathematical model to the experimental data.\nThe data typically comes as a series of paired points:\n\n\n\nx-data\ny-data\n\n\n\n\n\\(x_{1}\\)\n\\(y_{1}\\)\n\n\n\\(x_{2}\\)\n\\(y_{2}\\)\n\n\n…\n…\n\n\n\\(x_{N}\\)\n\\(y_{N}\\)\n\n\n\nEach point \\(\\{x_i, y_i\\}\\) may represent the result of multiple independent measurements. For instance, \\(y_1\\) could be the mean of several measurements \\(y_{1,j}\\):\n\\[y_1 = \\frac{1}{N}\\sum_{j=1}^N y_{1,j}\\]\nWhen these measurements have an uncertainty \\(\\sigma\\) for individual readings, the sum of all measurements has a variance of \\(N\\sigma^2\\) and a standard deviation of \\(\\sqrt{N}\\sigma\\). Consequently, the mean value has an associated error (standard deviation) known as the Standard Error of the Mean (SEOM):\n\\[\\sigma_{SEOM} = \\frac{\\sigma}{\\sqrt{N}}\\]\nThis SEOM is crucial in physics measurements.\nIt’s also important to note the definition of variance:\n\\[\\sigma_1^2 = \\frac{1}{N} \\sum_{j=1}^N (y_{1,j} - y_1)^2\\]\nThis statistical framework forms the basis for analyzing experimental data and fitting mathematical models to understand the underlying physics.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Curve Fitting"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_curve_fitting.html#least-squares",
    "href": "lectures/lecture07/1_curve_fitting.html#least-squares",
    "title": "Curve fitting",
    "section": "Least squares",
    "text": "Least squares\nIn experimental physics, we often collect data points to understand the underlying physical phenomena. To make sense of this data, we fit a mathematical model to it. One common method for fitting data is the least squares method.\n\nWhy use least squares fitting?\nThe goal of least squares fitting is to find the set of parameters for our model that best describes the data. This is done by minimizing the differences (or residuals) between the observed data points and the model’s predictions.\n\n\nGaussian uncertainty and probability\nWhen we take measurements, there is always some uncertainty. Often, this uncertainty can be modeled using a Gaussian (normal) distribution. This distribution is characterized by its mean (average value) and standard deviation (a measure of the spread of the data).\nIf we describe our data with a model function, which delivers a function value \\(f(x_{i},a)\\) for a set of parameters \\(a\\) at the position \\(x_{i}\\), the Gaussian uncertainty dictates a probability of finding a data value \\(y_{i}\\):\n\\[\\begin{equation}\np_{y_{i}}=\\frac{1}{\\sqrt{2\\pi}\\sigma_{i}}\\exp\\left(-\\frac{(y_{i}-f(x_{i},a))^2}{2\\sigma_{i}^2}\\right)\n\\end{equation}\\]\nHere, \\(\\sigma_{i}\\) represents the uncertainty in the measurement \\(y_{i}\\).\n\n\nCombining probabilities for multiple data points\nTo understand how well our model fits all the data points, we need to consider the combined probability of observing all the data points. This is done by multiplying the individual probabilities:\n\\[\\begin{equation}\np(y_{1},\\ldots,y_{N})=\\prod_{i=1}^{N}\\frac{1}{\\sqrt{2\\pi}\\sigma_{i}}\\exp\\left(-\\frac{(y_{i}-f(x_{i},a))^2}{2\\sigma_{i}^2}\\right)\n\\end{equation}\\]\n\n\nMaximizing the joint probability\nThe best fit of the model to the data is achieved when this joint probability is maximized. To simplify the calculations, we take the logarithm of the joint probability:\n\\[\\begin{equation}\n\\ln(p(y_{1},\\ldots,y_{N}))=-\\frac{1}{2}\\sum_{i=1}^{N}\\left( \\frac{y_{i}-f(x_{i},a)}{\\sigma_{i}}\\right)^2 - \\sum_{i=1}^{N}\\ln\\left( \\sigma_{i}\\sqrt{2\\pi}\\right)\n\\end{equation}\\]\nThe first term on the right side (except the factor 1/2) is the least squared deviation, also known as \\(\\chi^{2}\\):\n\\[\\begin{equation}\n\\chi^{2} =\\sum_{i=1}^{N}\\left( \\frac{y_{i}-f(x_{i},a)}{\\sigma_{i}}\\right)^2\n\\end{equation}\\]\nThe second term is just a constant value given by the uncertainties of our experimental data.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Curve Fitting"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_curve_fitting.html#data",
    "href": "lectures/lecture07/1_curve_fitting.html#data",
    "title": "Curve fitting",
    "section": "Data",
    "text": "Data\nLet’s have a look at the meaning of this equation. Let’s assume we measure the trajectory of a ball that has been thrown at an angle \\(\\alpha\\) with an initial velocity \\(v_{0}\\). We have collected data points by measuring the height of the ball above the ground at equally spaced distances from the throwing person.\n\n\n\n\n    \n      \n      x\n      y\n      error\n    \n  \n\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n\n\nLoading ITables v2.2.2 from the internet...\n(need help?)\n\n\n\n\n\n\n\n\nThe table above shows the measured data points \\(y_{i}\\) at the position \\(x_{i}\\) with the associated uncertainties \\(\\sigma_{i}\\).\nWe can plot the data and expect, of course, a parabola. Therefore, we model our experimental data with a parabola like\n\\[\\begin{equation}\ny = ax^2 + bx + c\n\\end{equation}\\]\nwhere the parameter \\(a\\) must be negative since the parabola is inverted.\nI have created an interactive plot with an interact widget, as this allows you to play around with the parameters. The value of \\(\\chi^2\\) is also included in the legend, so you can get an impression of how good your fit of the data is.\n\nviewof aSlider = Inputs.range([-4, 0], { label: \"a\", step: 0.01, value: -1.7 });\nviewof bSlider = Inputs.range([-2, 2], { label: \"b\", step: 0.01, value: 1.3 });\nviewof cSlider = Inputs.range([-2, 2], { label: \"c\", step: 0.01, value: 1.0 });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered = transpose(data);\n// Create the plot\n\nxValues = Array.from({ length: 100 }, (_, i) =&gt; i / 100);\nparabolaData = xValues.map(x =&gt; ({ x, y: parabola(x, aSlider, bSlider, cSlider) }));\n\n\nparabola = (x, a, b, c) =&gt; a * x**2 + b * x + c\n\ncalculateChiSquared = (data, a, b, c) =&gt; {\n  let chisq = 0\n  let x= data.map(d =&gt; d.x)\n  let y= data.map(d =&gt; d.y)\n  let err= data.map(d =&gt; d.error)\n  for (let i = 0; i &lt; x.length; i++) {\n    let y_model = parabola(x[i], a, b, c)\n    chisq += ((y[i] - y_model) / err[i])**2\n  }\n  return chisq\n}\n\nchisq = calculateChiSquared(filtered, aSlider, bSlider, cSlider)\n\nPlot.plot({\n  marks: [\n    Plot.dot(filtered, { x: \"x\", y: \"y\" }),\n    Plot.ruleY(filtered, { x: \"x\", y1: d =&gt; d.y - d.error, y2: d =&gt; d.y + d.error }),\n    Plot.line(parabolaData, { x: \"x\", y: \"y\" }),\n    Plot.text([{ x: 0.8, y: 1.5, label: `χ²: ${chisq.toFixed(2)}` }], {\n          x: \"x\",\n          y: \"y\",\n          text: \"label\",\n          dy: -10, // Adjust vertical position if needed\n          fill: \"black\", // Set text color\n          fontSize: 16\n        }),\n    Plot.frame()\n  ],\n  x: {\n    label: \"X Axis\",\n    labelAnchor: \"center\",\n    labelOffset: 35,\n    grid: true,\n    tickFormat: \".2f\", // Format ticks to 2 decimal places\n    domain: [0, 1]\n  },\n  y: {\n    label: \"Y Axis\",\n    grid: true,\n    tickFormat: \".2f\", // Format ticks to 2 decimal places\n    labelAnchor: \"center\",  // Center the label on its axis\n    labelAngle: -90,\n    labelOffset: 60,\n    domain: [0, 2],\n  },\n  width: 400,\n  height: 400,\n  marginLeft: 100,\n  marginBottom: 40,\n  style: {\n    fontSize: \"14px\",          // This sets the base font size\n    \"axis.label\": {\n      fontSize: \"18px\",        // This sets the font size for axis labels\n      fontWeight: \"bold\"       // Optionally make it bold\n    },\n    \"axis.tick\": {\n      fontSize: \"14px\"         // This sets the font size for tick labels\n    }\n  },\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe have that troubling point at the right edge with a large uncertainty. However, since the value of \\(\\chi^2\\) divides the deviation by the uncertainty \\(\\sigma_{i}\\), the weight for this point overall in the \\(\\chi^2\\) is smaller than for the other points.\n\\[\\begin{equation}\n\\chi^{2}=\\sum_{i=1}^{N}\\left( \\frac{y_{i}-f(x_{i},a)}{\\sigma_{i}}\\right)^2\n\\end{equation}\\]\nYou may simply check the effect by changing the uncertainty of the last data points in the error array.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Curve Fitting"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_curve_fitting.html#least-square-fitting",
    "href": "lectures/lecture07/1_curve_fitting.html#least-square-fitting",
    "title": "Curve fitting",
    "section": "Least square fitting",
    "text": "Least square fitting\nTo find the best fit of the model to the experimental data, we use the least squares method. This method minimizes the sum of the squared differences between the observed data points and the model’s predictions.\nMathematically, we achieve this by minimizing the least squares, i.e., finding the parameters \\(a\\) that minimize the following expression:\n\\[\\begin{equation}\n\\frac{d\\chi^{2}}{da}=\\sum_{i=1}^{N}\\frac{1}{\\sigma_{i}^2}\\frac{df(x_{i},a)}{da}[y_{i}-f(x_{i},a)]=0\n\\end{equation}\\]\nThis kind of least squares minimization is done by fitting software using different types of algorithms.\n\nFitting with SciPy\nLet’s do some fitting using the SciPy library, which is a powerful tool for scientific computing in Python. We will use the curve_fit method from the optimize sub-module of SciPy.\nFirst, we need to define the model function we would like to fit to the data. In this case, we will use our parabola function:\n\n\n\n\n\n\nNext, we need to provide initial guesses for the parameters. These initial guesses help the fitting algorithm start the search for the optimal parameters:\n\n\n\n\n\n\nWe then call the curve_fit function to perform the fitting:\n\n\n\n\n\n\n\n\n\n\n\n\ncurve_fit Function\n\n\n\n\n\nThe curve_fit function is used to fit a model function to data. It finds the optimal parameters for the model function that minimize the sum of the squared residuals between the observed data and the model’s predictions.\n\nParameters\n\nparabola:\n\nThis is the model function that you want to fit to the data. In this case, parabola is a function that represents a quadratic equation of the form ( y = ax^2 + bx + c ).\n\nx_data:\n\nThis is the array of independent variable data points (the x-values).\n\ny_data:\n\nThis is the array of dependent variable data points (the y-values).\n\nsigma=err:\n\nThis parameter specifies the uncertainties (standard deviations) of the y-data points. The err array contains the uncertainties for each y-data point. These uncertainties are used to weight the residuals in the least squares optimization.\n\np0=init_guess:\n\nThis parameter provides the initial guesses for the parameters of the model function. The init_guess array contains the initial guesses for the parameters ( a ), ( b ), and ( c ). Providing good initial guesses can help the optimization algorithm converge more quickly and accurately.\n\nabsolute_sigma=True:\n\nThis parameter indicates whether the provided sigma values are absolute uncertainties. If absolute_sigma is set to True, the sigma values are treated as absolute uncertainties. If absolute_sigma is set to False, the sigma values are treated as relative uncertainties, and the covariance matrix of the parameters will be scaled accordingly.\n\n\n\n\nReturn Value\nThe curve_fit function returns two values:\n\npopt:\n\nAn array containing the optimal values for the parameters of the model function that minimize the sum of the squared residuals.\n\npcov:\n\nThe covariance matrix of the optimal parameters. The diagonal elements of this matrix provide the variances of the parameter estimates, and the off-diagonal elements provide the covariances between the parameter estimates.\n\n\n\n\n\n\nThe fit variable contains the results of the fitting process. It is composed of various results, which we can split into the fitted parameters and the covariance matrix:\n\n\n\n\n\n\nThe ans variable contains the fitted parameters fit_a, fit_b, and fit_c, while the cov variable contains the covariance matrix. Let’s have a look at the fit and the \\(\\chi^{2}\\) value first:\n\n\n\n\n\n\nWe can then plot the fitted curve along with the original data points and the \\(\\chi^{2}\\) value:\n\n\n\n\n\n\n\n\n\\(\\chi\\)-squared value\nThe value of \\(\\chi^2\\) gives you a measure of the quality of the fit. We can judge the quality by calculating the expectation value of \\(\\chi^2\\):\n\\[\\begin{equation}\n\\langle \\chi^{2}\\rangle =\\sum_{i=1}^{N} \\frac{\\langle (y_{i}-f(x_{i},a) )^2\\rangle }{\\sigma_{i}^2}=\\sum_{i=1}^{N} \\frac{\\sigma_{i}^2}{\\sigma_{i}^2}=N\n\\end{equation}\\]\nSo, the mean of the least squared deviation increases with the number of data points. Therefore:\n\n\\(\\chi^{2} \\gg N\\) means that the fit is bad.\n\\(\\chi^{2} &lt; N\\) means that the uncertainties are wrong.\n\nThe first case may occur if you don’t have a good fit to your data, for example, if you are using the wrong model. The second case typically occurs if you don’t have accurate estimates of the uncertainties and you assume all uncertainties to be constant.\nIt is really important to have a good estimate of the uncertainties and to include them in your fit. If you include the uncertainties in your fit, it is called a weighted fit. If you don’t include the uncertainties (meaning you keep them constant), it is called an unweighted fit.\nFor our fit above, we obtain a \\(\\chi^{2}\\) which is on the order of \\(N=10\\), which tells you that I have created the data with reasonable accuracy.\n\n\nResiduals\nAnother way to assess the quality of the fit is by looking at the residuals. Residuals are defined as the deviation of the data from the model for the best fit:\n\\[\\begin{equation}\nr_i = y_i - f(x_{i},a)\n\\end{equation}\\]\nThe residuals can also be expressed as the percentage of the deviation of the data from the fit:\n\\[\\begin{equation}\nr_i = 100 \\left( \\frac{y_i - f(x_{i},a)}{y_i} \\right)\n\\end{equation}\\]\n\n\nImportance of Residuals\nResiduals are important because they provide insight into how well the model fits the data. If the residuals show only statistical fluctuations around zero, then the fit and likely also the model are good. However, if there are systematic patterns in the residuals, it may indicate that the model is not adequately capturing the underlying relationship in the data.\n\n\nVisualizing Residuals\nLet’s visualize the residuals to better understand their distribution. We will plot the residuals as a function of the independent variable \\(x\\).\n\n\n\n\n\n\n\n\n\n\n\n\nCommon Patterns in Residuals\n\n\n\n\n\nRandom Fluctuations Around Zero:\n\nIf the residuals are randomly scattered around zero, it suggests that the model is a good fit for the data.\n\nSystematic Patterns:\n\nIf the residuals show a systematic pattern (e.g., a trend or periodicity), it may indicate that the model is not capturing some aspect of the data. This could suggest the need for a more complex model.\n\nIncreasing or Decreasing Trends:\n\nIf the residuals increase or decrease with \\(x\\), it may indicate heteroscedasticity (non-constant variance) or that a different functional form is needed.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Curve Fitting"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_curve_fitting.html#covariance-matrix",
    "href": "lectures/lecture07/1_curve_fitting.html#covariance-matrix",
    "title": "Curve fitting",
    "section": "Covariance Matrix",
    "text": "Covariance Matrix\nIn the previous sections, we discussed how to fit a model to experimental data and assess the quality of the fit using residuals. Now, let’s take a closer look at the uncertainties in the fit parameters and how they are related to each other. This is where the covariance matrix comes into play.\n\nPurpose of the Covariance Matrix\nThe covariance matrix provides important information about the uncertainties in the fit parameters and how these uncertainties are related to each other. It helps us understand the precision of the parameter estimates and whether the parameters are independent or correlated.\n\n\nUnderstanding Covariance\nCovariance is a measure of how much two random variables change together. If the covariance between two variables is positive, it means that they tend to increase or decrease together. If the covariance is negative, it means that one variable tends to increase when the other decreases. If the covariance is zero, it means that the variables are independent.\n\n\nCovariance Matrix in Curve Fitting\nWhen we fit a model to data, we obtain estimates for the parameters of the model. These estimates have uncertainties due to the measurement errors in the data. The covariance matrix quantifies these uncertainties and the relationships between them.\nFor a model with three parameters \\((a, b, c)\\), the covariance matrix is a \\(3 \\times 3\\) matrix that looks like this:\n\\[\\begin{equation}\n{\\rm cov}(p_{i}, p_{j}) =\n\\begin{bmatrix}\n\\sigma_{aa}^{2} & \\sigma_{ab}^{2} & \\sigma_{ac}^{2} \\\\\n\\sigma_{ba}^{2} & \\sigma_{bb}^{2} & \\sigma_{bc}^{2} \\\\\n\\sigma_{ca}^{2} & \\sigma_{cb}^{2} & \\sigma_{cc}^{2}\n\\end{bmatrix}\n\\end{equation}\\]\nThe diagonal elements provide the variances (squared uncertainties) of the fit parameters, while the off-diagonal elements describe the covariances between the parameters.\n\n\nExample\nLet’s calculate the covariance matrix for our fitted model and interpret the results.\n\n\n\n\n\n\n\n\nInterpreting the Covariance Matrix\nThe covariance matrix provides valuable information about the uncertainties in the fit parameters:\n\nDiagonal Elements: The diagonal elements represent the variances of the parameters. The square root of these values gives the standard deviations (uncertainties) of the parameters.\nOff-Diagonal Elements: The off-diagonal elements represent the covariances between the parameters. If these values are large, it indicates that the parameters are correlated.\n\n\n\nGenerating Synthetic Data\nTo better understand the covariance matrix, let’s generate synthetic data and fit the model to each dataset. This will help us visualize the uncertainties in the parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCorrelation Matrix\nTo better understand the relationships between the parameters, we can normalize the covariance matrix to obtain the correlation matrix. The correlation matrix has values between -1 and 1, where 1 indicates perfect positive correlation, -1 indicates perfect negative correlation, and 0 indicates no correlation.\n\n\n\n\n\n\n\n\nVisualizing the Covariance and Correlation\nLet’s visualize the covariance and correlation between the parameters using scatter plots.\n\n\n\n\n\n\nBy examining the covariance and correlation matrices, we can gain a deeper understanding of the uncertainties in the fit parameters and how they are related to each other.\n\n\nImproving the Model\nIf we find that the parameters are highly correlated, we might want to find a better model containing more independent parameters. For example, we can write down a different model:\n\\[\\begin{equation}\ny = a(x - b)^2 + c\n\\end{equation}\\]\nThis model also contains three parameters, but the parameter \\(b\\) directly refers to the maximum of our parabola, while the parameter \\(a\\) denotes its curvature.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe see from the covariance matrix that the new model has a smaller correlation of the parameters with each other.\n\n\n\n\n\n\nThis is also expressed by our correlation matrix.\n\n\n\n\n\n\nBy examining the covariance and correlation matrices, we can gain valuable insights into the uncertainties in the fit parameters and how to improve our model.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Curve Fitting"
    ]
  },
  {
    "objectID": "lectures/lecture11/01-lecture11.html",
    "href": "lectures/lecture11/01-lecture11.html",
    "title": "Lecture 11",
    "section": "",
    "text": "Solving coupled differential equations for oscillatory systems (e.g., damped harmonic oscillators).\nUsing Fourier analysis to study waveforms.\n\n\n\n\n\nSimulating simple harmonic motion and damped oscillations.\nVisualizing the motion and analyzing the frequency components of the oscillation.\nHomework: Extend the simulation to include coupled oscillators or waves on a string.\n\n\n//| echo: false\n  d3 = require(\"d3@7\")\n\n\n\n\n\n\n\n//| echo: false\n\n  // Define the Vicsek model simulation\n  {\n\n\n  function vicsekModel(width, height, particleCount, noise) {\n    const particles = d3.range(particleCount).map(() =&gt; ({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      angle: Math.random() * 2 * Math.PI\n    }));\n\n    function step(currentRadius) {\n      particles.forEach(particle =&gt; {\n        // Find neighbors within radius\n        const neighbors = particles.filter(p =&gt;\n          (p !== particle) &&\n          (Math.hypot(p.x - particle.x, p.y - particle.y) &lt;= radius)\n        );\n\n        // Calculate average direction of neighbors\n        let avgAngle = particle.angle;\n        if (neighbors.length &gt; 0) {\n          avgAngle = d3.mean(neighbors, d =&gt; d.angle);\n        }\n\n        // Update particle angle with noise\n        particle.angle = avgAngle + (Math.random() - 0.5) * noise;\n\n        // Move particle\n        particle.x += speed*Math.cos(particle.angle);\n        particle.y += speed*Math.sin(particle.angle);\n\n        // Wrap around boundaries\n        particle.x = (particle.x + width) % width;\n        particle.y = (particle.y + height) % height;\n      });\n    }\n\n    return {\n      particles,\n      step\n    };\n  }\n\n  // Set up the visualization\n  const width = 600;\n  const height = 600;\n  const particleCount = 400;\n  const noise = 2;\n  let speed = 5;\n  let radius = 20;\n\n  // Create container div\n  const container = d3.create(\"div\");\n\n  // Create slider\n  const slider = container.append(\"input\")\n    .attr(\"type\", \"range\")\n    .attr(\"min\", 1)\n    .attr(\"max\", 50)\n    .attr(\"value\", radius)\n    .style(\"width\", \"50%\")\n    .on(\"input\", function() {\n      radius = +this.value;\n      d3.select(\"#radius-value\").text(radius);\n    });\n\n    const slider1 = container.append(\"input\")\n      .attr(\"type\", \"range\")\n      .attr(\"min\", 1)\n      .attr(\"max\", 10)\n      .attr(\"value\", speed)\n      .style(\"width\", \"50%\")\n      .on(\"input\", function() {\n        speed = +this.value;\n        d3.select(\"#speed-value\").text(speed);\n      });\n\n  // Display current radius value\n  container.append(\"div\")\n    .text(\"Radius: \")\n    .append(\"span\")\n    .attr(\"id\", \"radius-value\")\n    .text(radius);\n\n  // Create SVG\n  const svg = container.append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .style(\"background\", \"#f0f0f0\");\n\n  const model = vicsekModel(width, height, particleCount, noise);\n\n  const particles = svg.selectAll(\"circle\")\n    .data(model.particles)\n    .join(\"circle\")\n    .attr(\"r\", 2)\n    .attr(\"fill\", \"blue\");\n\n  // Animation function\n  function animate() {\n    model.step(radius);\n    particles\n      .attr(\"cx\", d =&gt; d.x)\n      .attr(\"cy\", d =&gt; d.y);\n    requestAnimationFrame(animate);\n  }\n\n  // Start the animation\n  animate();\n\n  // Return the container div\n  return container.node();}"
  },
  {
    "objectID": "lectures/lecture11/01-lecture11.html#oscillations-and-waves",
    "href": "lectures/lecture11/01-lecture11.html#oscillations-and-waves",
    "title": "Lecture 11",
    "section": "",
    "text": "Solving coupled differential equations for oscillatory systems (e.g., damped harmonic oscillators).\nUsing Fourier analysis to study waveforms.\n\n\n\n\n\nSimulating simple harmonic motion and damped oscillations.\nVisualizing the motion and analyzing the frequency components of the oscillation.\nHomework: Extend the simulation to include coupled oscillators or waves on a string.\n\n\n//| echo: false\n  d3 = require(\"d3@7\")\n\n\n\n\n\n\n\n//| echo: false\n\n  // Define the Vicsek model simulation\n  {\n\n\n  function vicsekModel(width, height, particleCount, noise) {\n    const particles = d3.range(particleCount).map(() =&gt; ({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      angle: Math.random() * 2 * Math.PI\n    }));\n\n    function step(currentRadius) {\n      particles.forEach(particle =&gt; {\n        // Find neighbors within radius\n        const neighbors = particles.filter(p =&gt;\n          (p !== particle) &&\n          (Math.hypot(p.x - particle.x, p.y - particle.y) &lt;= radius)\n        );\n\n        // Calculate average direction of neighbors\n        let avgAngle = particle.angle;\n        if (neighbors.length &gt; 0) {\n          avgAngle = d3.mean(neighbors, d =&gt; d.angle);\n        }\n\n        // Update particle angle with noise\n        particle.angle = avgAngle + (Math.random() - 0.5) * noise;\n\n        // Move particle\n        particle.x += speed*Math.cos(particle.angle);\n        particle.y += speed*Math.sin(particle.angle);\n\n        // Wrap around boundaries\n        particle.x = (particle.x + width) % width;\n        particle.y = (particle.y + height) % height;\n      });\n    }\n\n    return {\n      particles,\n      step\n    };\n  }\n\n  // Set up the visualization\n  const width = 600;\n  const height = 600;\n  const particleCount = 400;\n  const noise = 2;\n  let speed = 5;\n  let radius = 20;\n\n  // Create container div\n  const container = d3.create(\"div\");\n\n  // Create slider\n  const slider = container.append(\"input\")\n    .attr(\"type\", \"range\")\n    .attr(\"min\", 1)\n    .attr(\"max\", 50)\n    .attr(\"value\", radius)\n    .style(\"width\", \"50%\")\n    .on(\"input\", function() {\n      radius = +this.value;\n      d3.select(\"#radius-value\").text(radius);\n    });\n\n    const slider1 = container.append(\"input\")\n      .attr(\"type\", \"range\")\n      .attr(\"min\", 1)\n      .attr(\"max\", 10)\n      .attr(\"value\", speed)\n      .style(\"width\", \"50%\")\n      .on(\"input\", function() {\n        speed = +this.value;\n        d3.select(\"#speed-value\").text(speed);\n      });\n\n  // Display current radius value\n  container.append(\"div\")\n    .text(\"Radius: \")\n    .append(\"span\")\n    .attr(\"id\", \"radius-value\")\n    .text(radius);\n\n  // Create SVG\n  const svg = container.append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .style(\"background\", \"#f0f0f0\");\n\n  const model = vicsekModel(width, height, particleCount, noise);\n\n  const particles = svg.selectAll(\"circle\")\n    .data(model.particles)\n    .join(\"circle\")\n    .attr(\"r\", 2)\n    .attr(\"fill\", \"blue\");\n\n  // Animation function\n  function animate() {\n    model.step(radius);\n    particles\n      .attr(\"cx\", d =&gt; d.x)\n      .attr(\"cy\", d =&gt; d.y);\n    requestAnimationFrame(animate);\n  }\n\n  // Start the animation\n  animate();\n\n  // Return the container div\n  return container.node();}"
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "Modules",
    "section": "",
    "text": "Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python module it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\n\n\n\n\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\n\n\n\n\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems.\n\nNamespaces\n\n\n\n\n\n\nNamespaces\n\n\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the import math as mymath pattern.\n\n\n\n\n\n\n\n\nYou may also only import specific functions of a module.\n\n\n\n\n\n\n\n\nDirectory of a module\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\n\n\n\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n\nAdvanced topics\n\n\n\n\n\n\nCreate Your Own Modules\n\n\n\n\n\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here’s how you can create and use your own module:\n\nCreating a Module\nTo create a module, you just need to save your Python code in a file with a .py extension. For example, let’s create a module named mymodule.py with the following content:\n# mymodule.py\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\nUsing Your Module\nOnce you have created your module, you can import it into other Python scripts using the import statement. Here’s an example of how to use the mymodule we just created:\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n\n\nImporting Specific Functions\nYou can also import specific functions from a module using the from ... import ... syntax:\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n\n\nModule Search Path\nWhen you import a module, Python searches for the module in the following locations: 1. The directory containing the input script (or the current directory if no script is specified). 2. The directories listed in the PYTHONPATH environment variable. 3. The default directory where Python is installed.\nYou can view the module search path by printing the sys.path variable:\nimport sys\nprint(sys.path)\n\n\nCreating Packages\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named __init__.py, which can be empty. Here’s an example of how to create a package:\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\nYou can then import modules from the package using the dot notation:\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n\nNamespaces in Packages\nYou can also create sub-packages by adding more directories with __init__.py files. This allows you to create a hierarchical structure for your modules:\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\nYou can then import submodules using the full package name:\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())",
    "crumbs": [
      "Python Basics",
      "Lecture 3",
      "Modules"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "Python Overview",
    "section": "",
    "text": "Functions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 3",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#functions",
    "href": "lectures/lecture02/01-lecture02.html#functions",
    "title": "Python Overview",
    "section": "",
    "text": "Functions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 3",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#loops",
    "href": "lectures/lecture02/01-lecture02.html#loops",
    "title": "Python Overview",
    "section": "Loops",
    "text": "Loops\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 3",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#conditional-statements",
    "href": "lectures/lecture02/01-lecture02.html#conditional-statements",
    "title": "Python Overview",
    "section": "Conditional Statements",
    "text": "Conditional Statements\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 3",
      "Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html",
    "href": "lectures/lecture02/3_datatypes.html",
    "title": "Data Types in Python",
    "section": "",
    "text": "It’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe following few cells will give you a short introduction into each type.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#strings",
    "href": "lectures/lecture02/3_datatypes.html#strings",
    "title": "Data Types in Python",
    "section": "Strings",
    "text": "Strings\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#lists",
    "href": "lectures/lecture02/3_datatypes.html#lists",
    "title": "Data Types in Python",
    "section": "Lists",
    "text": "Lists\nLists have a variety of uses. They are useful, for example, in various bookkeeping tasks that arise in computer programming. Like arrays, they are sometimes used to store data. However, lists do not have the specialized properties and tools that make arrays so powerful for scientific computing. So in general, we prefer arrays to lists for working with scientific data. For other tasks, lists work just fine and can even be preferable to arrays.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndividual elements in a list can be accessed by the variable name and the number (index) of the list element put in square brackets. Note that the index for the elements start at 0 for the first element (left).\n\n\n\n\n\n\nIndices in Python\n\n\n\nThe first element of a list or array is accessed by the index 0. If the array has N elements, the last entries index is N-1.\n\n\n\n\n\n\n\n\nElements may be also accessed from the back by nagative indices. b[-1] denotes the last element in the list and b[-2], the element before the last.\n\n\n\n\n\n\n\n\n\n\n\n\nThe length of a list can be obtained by the len command if you need the number of elements in the list for your calculations.\n\n\n\n\n\n\nThere are powerful ways to iterate through a list and also through arrays in form of iterator. This is called list comprehension. We will talk about them later in more detail. Here is an example, which shows the powerful options you have in Python.\n\n\n\n\n\n\nIndividual elements in a list can be replaced by assigning a new value to them\n\n\n\n\n\n\n\n\n\n\n\n\nLists can be concatanated by the + operator\n\n\n\n\n\n\nA very useful feature for lists in python is the slicing of lists. Slicing means, that we access only a range of elements in the list, i.e. element 3 to 7. This is done by inserting the starting and the ending element number separated by a colon (:) in the square brackets. The index numbers can be positive or negative again.\n\n\n\n\n\n\nInserting a second colon behind the ending element index together with a thrid number allows even to select only ever second or third element from a list.\n\n\n\n\n\n\nIt is sometimes also useful to reverse a list. This can be easily done with the reverse command.\n\n\n\n\n\n\nLists may be created in different ways. An empty list can be created by assigning emtpy square brackets to a variable name. You can append elements to the list with the help of the append command which has to be added to the variable name as shown below. This way of adding a particular function, which is part of a certain variable class is part of object oriented programming.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA list of numbers can be easily created by the range() command.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLists (and also tuples below) can be multidimensional as well, i.e. for an image. The individual elements may then be addressed by supplying two indices in two square brackets.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#tuples",
    "href": "lectures/lecture02/3_datatypes.html#tuples",
    "title": "Data Types in Python",
    "section": "Tuples",
    "text": "Tuples\nTuples are also list, but immutable. That means, if a tuple has been once defined, it cannot be changed. Try to change an element to see the result.\n\n\n\n\n\n\nTuples may be unpacked, e.g. its values may be assigned to normal variables in the following way",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#dictionaries",
    "href": "lectures/lecture02/3_datatypes.html#dictionaries",
    "title": "Data Types in Python",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries are like lists, but the elements of dictionaries are accessed in a different way than for lists. The elements of lists and arrays are numbered consecutively, and to access an element of a list or an array, you simply refer to the number corresponding to its position in the sequence. The elements of dictionaries are accessed by “keys”, which can be either strings or (arbitrary) integers (in no particular order). Dictionaries are an important part of core Python. However, we do not make much use of them in this introduction to scientific Python, so our discussion of them is limited.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#sets",
    "href": "lectures/lecture02/3_datatypes.html#sets",
    "title": "Data Types in Python",
    "section": "Sets",
    "text": "Sets\nSets are like lists but have immutable unique entries, which means the elements can not be changed once defined. An emtpy set is created by the set() method.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou may add elements to a set with the add method:\nYou may also remove objects with the discard method:\n\n\n\n\n\n\nYou may also apply a variety of operation to sets checking their intersection, union or difference.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/3_datatypes.html#quiz-data-types-in-python",
    "href": "lectures/lecture02/3_datatypes.html#quiz-data-types-in-python",
    "title": "Data Types in Python",
    "section": "Quiz: Data Types in Python",
    "text": "Quiz: Data Types in Python\nLet’s test your understanding of Python data types!\n\n\nWhat is the output of the following code?\na = [1, 2, 3]\nb = (1, 2, 3)\nprint(type(a), type(b))\n\n&lt;class 'list'&gt; &lt;class 'list'&gt;\n&lt;class 'list'&gt; &lt;class 'tuple'&gt;\n&lt;class 'tuple'&gt; &lt;class 'list'&gt;\n&lt;class 'tuple'&gt; &lt;class 'tuple'&gt;\n\nWhich of the following is mutable?\n\nList\nTuple\nString\nInteger\n\nWhat will be the output of this code?\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\nprint(my_dict['b'])\n\na\n2\nb\nKeyError\n\nHow do you create an empty set in Python?\n\n{}\n[]\nset()\n()\n\nWhat is the result of 3 + 4.0?\n\n7\n7.0\n‘7.0’\nTypeError\n\n\n\n\n\n\n\n\n\nClick to reveal answers\n\n\n\n\n\n\n&lt;class 'list'&gt; &lt;class 'tuple'&gt;\nList\n2\nset()\n7.0",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Datatypes"
    ]
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html",
    "href": "lectures/lecture02/04-summary02.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Matplotlib Plotting Cheat Sheet\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(width, height))\n\n\n\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\nplt.legend(['Label'], loc='best')\n\n\n\nplt.scatter(x, y, marker='o')\n\n\n\nplt.hist(data, bins=10, density=True)\n\n\n\nplt.plot(x, y1, 'b-', label='Line 1')\nplt.scatter(x, y2, color='r', label='Scatter')\nplt.legend()\n\n\n\nplt.savefig('filename.pdf')\n\n\n\nplt.errorbar(x, y, yerr=yerror, fmt='ro', ecolor='black')\n\n\n\nplt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)\n\n\n\nmasked_data = np.ma.masked_where(condition, data)\n\n\n\nplt.semilogx(x, y)  # Log scale on x-axis\nplt.semilogy(x, y)  # Log scale on y-axis\nplt.loglog(x, y)    # Log scale on both axes\n\n\n\nplt.subplot(rows, cols, plot_number)\n\n\n\nplt.contour(X, Y, Z, levels)\nplt.contourf(X, Y, Z, levels)  # Filled contour plot\n\n\n\nplt.imshow(data, extent=[xmin, xmax, ymin, ymax], cmap='colormap')\n\n\n\nfrom mpl_toolkits import mplot3d\nax = plt.axes(projection='3d')\nax.plot3D(x, y, z)\nax.scatter3D(x, y, z)\nax.plot_surface(X, Y, Z)\n\n\n\nplt.rcParams.update({'font.size': 12, 'lines.linewidth': 2})\nplt.tight_layout()\nRemember to always call plt.show() to display your plots!"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#matplotlib-plotting-cheat-sheet",
    "href": "lectures/lecture02/04-summary02.html#matplotlib-plotting-cheat-sheet",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Matplotlib Plotting Cheat Sheet\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(width, height))\n\n\n\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\nplt.legend(['Label'], loc='best')\n\n\n\nplt.scatter(x, y, marker='o')\n\n\n\nplt.hist(data, bins=10, density=True)\n\n\n\nplt.plot(x, y1, 'b-', label='Line 1')\nplt.scatter(x, y2, color='r', label='Scatter')\nplt.legend()\n\n\n\nplt.savefig('filename.pdf')\n\n\n\nplt.errorbar(x, y, yerr=yerror, fmt='ro', ecolor='black')\n\n\n\nplt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)\n\n\n\nmasked_data = np.ma.masked_where(condition, data)\n\n\n\nplt.semilogx(x, y)  # Log scale on x-axis\nplt.semilogy(x, y)  # Log scale on y-axis\nplt.loglog(x, y)    # Log scale on both axes\n\n\n\nplt.subplot(rows, cols, plot_number)\n\n\n\nplt.contour(X, Y, Z, levels)\nplt.contourf(X, Y, Z, levels)  # Filled contour plot\n\n\n\nplt.imshow(data, extent=[xmin, xmax, ymin, ymax], cmap='colormap')\n\n\n\nfrom mpl_toolkits import mplot3d\nax = plt.axes(projection='3d')\nax.plot3D(x, y, z)\nax.scatter3D(x, y, z)\nax.plot_surface(X, Y, Z)\n\n\n\nplt.rcParams.update({'font.size': 12, 'lines.linewidth': 2})\nplt.tight_layout()\nRemember to always call plt.show() to display your plots!"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#basic-setup",
    "href": "lectures/lecture02/04-summary02.html#basic-setup",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(width, height))"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#line-plots",
    "href": "lectures/lecture02/04-summary02.html#line-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.plot(x, y, 'bo-')  # Blue line with circle markers\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\nplt.legend(['Label'], loc='best')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#scatter-plots",
    "href": "lectures/lecture02/04-summary02.html#scatter-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.scatter(x, y, marker='o')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#histograms",
    "href": "lectures/lecture02/04-summary02.html#histograms",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.hist(data, bins=10, density=True)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#combined-plots",
    "href": "lectures/lecture02/04-summary02.html#combined-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.plot(x, y1, 'b-', label='Line 1')\nplt.scatter(x, y2, color='r', label='Scatter')\nplt.legend()"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#saving-figures",
    "href": "lectures/lecture02/04-summary02.html#saving-figures",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.savefig('filename.pdf')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#error-bars",
    "href": "lectures/lecture02/04-summary02.html#error-bars",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.errorbar(x, y, yerr=yerror, fmt='ro', ecolor='black')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#setting-plot-limits",
    "href": "lectures/lecture02/04-summary02.html#setting-plot-limits",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#masked-arrays",
    "href": "lectures/lecture02/04-summary02.html#masked-arrays",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "masked_data = np.ma.masked_where(condition, data)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#logarithmic-plots",
    "href": "lectures/lecture02/04-summary02.html#logarithmic-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.semilogx(x, y)  # Log scale on x-axis\nplt.semilogy(x, y)  # Log scale on y-axis\nplt.loglog(x, y)    # Log scale on both axes"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#multiple-subplots",
    "href": "lectures/lecture02/04-summary02.html#multiple-subplots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.subplot(rows, cols, plot_number)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#contour-plots",
    "href": "lectures/lecture02/04-summary02.html#contour-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.contour(X, Y, Z, levels)\nplt.contourf(X, Y, Z, levels)  # Filled contour plot"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#image-plots",
    "href": "lectures/lecture02/04-summary02.html#image-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.imshow(data, extent=[xmin, xmax, ymin, ymax], cmap='colormap')"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#d-plots",
    "href": "lectures/lecture02/04-summary02.html#d-plots",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "from mpl_toolkits import mplot3d\nax = plt.axes(projection='3d')\nax.plot3D(x, y, z)\nax.scatter3D(x, y, z)\nax.plot_surface(X, Y, Z)"
  },
  {
    "objectID": "lectures/lecture02/04-summary02.html#customization",
    "href": "lectures/lecture02/04-summary02.html#customization",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "plt.rcParams.update({'font.size': 12, 'lines.linewidth': 2})\nplt.tight_layout()\nRemember to always call plt.show() to display your plots!"
  },
  {
    "objectID": "lectures/lecture03/1_numpy.html",
    "href": "lectures/lecture03/1_numpy.html",
    "title": "NumPy Module",
    "section": "",
    "text": "Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object and tools for working with these arrays. The NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a NumPy array are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type.",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Numpy Module"
    ]
  },
  {
    "objectID": "lectures/lecture03/1_numpy.html#creating-numpy-arrays",
    "href": "lectures/lecture03/1_numpy.html#creating-numpy-arrays",
    "title": "NumPy Module",
    "section": "Creating Numpy Arrays",
    "text": "Creating Numpy Arrays\nThere are a number of ways to initialize new numpy arrays, for example from\n\na Python list or tuples\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section\n\n\nFrom lists\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing array-generating functions\nFor larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinspace and logspace\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50.\n\n\n\n\n\n\nlogspace is doing equivelent things with logaritmic spacing. Other types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\n\n\nmgrid\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiag\ndiag generates a diagonal matrix with the list supplied to it. The values can be also offset from the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeros and ones\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1.",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Numpy Module"
    ]
  },
  {
    "objectID": "lectures/lecture03/1_numpy.html#manipulating-numpy-arrays",
    "href": "lectures/lecture03/1_numpy.html#manipulating-numpy-arrays",
    "title": "NumPy Module",
    "section": "Manipulating NumPy arrays",
    "text": "Manipulating NumPy arrays\n\nSlicing\nSlicing is the name for extracting part of an array by the syntax M[lower:upper:step]\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by\n\\[\\begin{equation}\nv_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n\\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReshaping\nArrays can be reshaped into any form, which contains the same number of elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdding a new dimension: newaxis\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStacking and repeating arrays\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones. Please try the individual functions yourself in your notebook. We wont discuss them in detail.\n\nTile and repeat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConcatenate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHstack and vstack",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Numpy Module"
    ]
  },
  {
    "objectID": "lectures/lecture03/1_numpy.html#applying-mathematical-functions",
    "href": "lectures/lecture03/1_numpy.html#applying-mathematical-functions",
    "title": "NumPy Module",
    "section": "Applying mathematical functions",
    "text": "Applying mathematical functions\nAll kinds of mathematica operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below.\n\nOperation involving one array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperations involving multiple arrays\nVector operations enable efficient element-wise calculations where corresponding elements at matching positions are processed simultaneously. Instead of handling elements one by one, these operations work on entire arrays at once, making them particularly fast. When multiplying two vectors using these operations, the result is not a single number (as in a dot product) but rather a new array where each element is the product of the corresponding elements from the input vectors. This element-wise multiplication is just one example of vector operations, which can include addition, subtraction, and other mathematical functions.",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Numpy Module"
    ]
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html",
    "href": "lectures/lecture04/2_brownian_motion copy.html",
    "title": "Brownian Motion",
    "section": "",
    "text": "File as PDF\nWe will use our newly gained knowledge about classes for the simulation of Brownian motion. This actually perfectly fits to the object oriented programming topic, as each Brownian particle (or colloid) can be seen as an object instanciated from the same class, but perhaps with different properties. Some particles might be larger and some smaller for example. We know already some part of that, as we have covered it in earlier lectures."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#physics",
    "href": "lectures/lecture04/2_brownian_motion copy.html#physics",
    "title": "Brownian Motion",
    "section": "Physics",
    "text": "Physics\nThe Brownian motion of a colloidal particle (called solute) results from the collisions with the surrounding solvent molecules. Due to these collisions, the particle has in equilibrium a mean kinetic energy defined by the temperature. With this kinetic energy it would travel a mean distance \\(l\\) before it takes another random direction and go another step length \\(l\\). This mean distance the particle travels is very short in liquids. It is on the other of picometers. It has been shown by Lindenberg and Lévy that a sequence of many such infinitesimal small random steps leads to a total effect, which can be approximated by a normal distribution. This important theorem is called the central limit theorem.\nFor our Brownian motion the sequence of tiny steps leads after a time \\(t\\) to the following probability distribution to find the particle at a position \\(x\\) if it initially started at \\(x=0\\):\n\\[\\begin{equation}\np(x,\\Delta t)=\\frac{1}{\\sqrt{4\\pi D \\Delta t}}e^{-\\frac{x^2}{4D \\Delta t}}\n\\end{equation}\\]\nwhere \\(D\\) is the diffusion coefficient. Thus each step of our Brownian motion simulation for a timestep of \\(\\Delta t\\) is taken from a Gaussian distribution with a varaince of \\(\\sigma^2=2D \\Delta t\\).\nFor our simulation that means that we can draw numbers from a normal distribution with np.random.normal with the standard deviation \\(\\sigma=\\sqrt{2D \\Delta t}\\) as a parameter. This has to be done for the x-coordinate and the y-coordinate.\nThe code for our Brownian motion therefore is\nsigma=np.sqrt(2*D*dt)\ndx,dy=[(np.random.normal(0.0, sigma),np.random.normal(0.0, sigma)]\nx=x+dx\ny=y+dy\nwhich gives a whole 2d trajectory. With the help of this, we would like to write a colloidal particle class. So lets make a plan how this could work out."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#class-planning",
    "href": "lectures/lecture04/2_brownian_motion copy.html#class-planning",
    "title": "Brownian Motion",
    "section": "Class Planning",
    "text": "Class Planning\n\nPhysics project Colloidal particle class\nWe will define a class for a colloidal particle, which we may use later for our projects as well. This makes sense, as we can have different colloidal particles of different radius for example, which do start to carry out Brownian motion from different positions. A colloidal particle is and object, which has properties very much in the same way as classes intend that. The whole definition requires some planning, especially on what the class should keep track of and what the object.\nThe particle class shall keep track of\n* the total number of colloidal particles\n* the value of k_B T/(6 pi eta) = 2.2e-19\nThe class shall provide the class specific methods\n* how_many() which returns the total number of colloids\n* __str__ which returns a string with radius and position of the particle\n\n\nPhysics interlude: Colloidal particle class\nEach object shall then contain the following properties\n* the particle radius, R\n* a list of all x position, x\n* a list of all y position, y\n* the index of the colloid, index\n* the diffusion coefficient given by k_B T/(6 pi eta R), D\nThe object shall provide the following methods\n* sim_trajectory() simulate a whole trajectory at once\n* update(dt) do one step of Brownian motion with a time step dt as argument, return the current position\n* get_trajectory() return the trajectory as a pandas DataFrame with the columns x and y\n* get_D() return the diffusion coefficient\n\n\n\n\n\n\n\n\nNote:\nNote that the function sim_trajectory is actually calling the function update of the same object to generate the whole trajectory at once."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#simulating",
    "href": "lectures/lecture04/2_brownian_motion copy.html#simulating",
    "title": "Brownian Motion",
    "section": "Simulating",
    "text": "Simulating\nWith the help of this Colloid class, we would like to carry out simulations of Brownian motion of multiple particles. The simulations shall\n\ntake n=200 particles\nhave N=200 trajectory points each\nstart all at 0,0\nparticle objects should be stored in a list p_list"
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#plotting-the-trajectories",
    "href": "lectures/lecture04/2_brownian_motion copy.html#plotting-the-trajectories",
    "title": "Brownian Motion",
    "section": "Plotting the trajectories",
    "text": "Plotting the trajectories\nThe next step is to plot all the trajectories."
  },
  {
    "objectID": "lectures/lecture04/2_brownian_motion copy.html#characterizing-the-brownian-motion",
    "href": "lectures/lecture04/2_brownian_motion copy.html#characterizing-the-brownian-motion",
    "title": "Brownian Motion",
    "section": "Characterizing the Brownian motion",
    "text": "Characterizing the Brownian motion\nNow that we have a number of trajectories, we can analyze the motion of our Brownian particles.\n\nCalculate the particle speed\nOne way is to calculate its speed by measuring how far it traveled within a certain time \\(n\\, dt\\), where \\(dt\\) is the timestep of out simulation. We can do that as\n\\[\\begin{equation}\nv(n dt) = \\frac{&lt;\\sqrt{(x_{i+n}-x_{i})^2+(y_{i+n}-y_{i})^2}&gt;}{n\\,dt}\n\\end{equation}\\]\nThe angular brackets on the top take care of the fact that we can measure the distance traveled within a certain time \\(n\\, dt\\) several times along a trajectory.\n\n\n\nmsd\n\n\nThese values can be used to calculate a mean speed. Note that there is not an equal amount of data pairs for all separations available. For \\(n=1\\) there are 5 distances available. For \\(n=5\\), however, only 1. This changes the statistical accuracy of the mean.\n\n\n\n\n\n\nThe result of this analysis shows, that each particle has an apparent speed which seems to increase with decreasing time of observation or which decreases with increasing time. This would mean that there is some friction at work, which slows down the particle in time, but this is apparently not true. Also an infinite speed at zero time appears to be unphysical. The correct answer is just that the speed is no good measure to characterize the motion of a Brownian particle.\n\n\nCalculate the particle mean squared displacement\nA better way to characterize the motion of a Brownian particle is the mean squared displacement, as we have already mentioned it in previous lectures. We may compare our simulation now to the theoretical prediction, which is\n\\[\\begin{equation}\n\\langle \\Delta r^{2}(t)\\rangle=2 d D t\n\\end{equation}\\]\nwhere \\(d\\) is the dimension of the random walk, which is \\(d=2\\) in our case.\n\n\n\n\n\n\nThe results show that the mean squared displacement of the individual particles follows on average the theoretical predictions of a linear growth in time. That means, we are able to read the diffusion coefficient from the slope of the MSD of the individual particles if recorded in a simulation or an experiment.\nYet, each individual MSD is deviating strongly from the theoretical prediction especially at large times. This is due to the fact mentioned earlier that our simulation (or experimental) data only has a limited number of data points, while the theoretical prediction is made for the limit of infinite data points.\n\nWarning: Analysis of MSD data\nSingle particle tracking, either in the experiment or in numerical simulations can therefore only deliver an estimate of the diffusion coefficient and care should be taken when using the whole MSD to obtain the diffusion coefficient. One typically uses only a short fraction of the whole MSD data at short times."
  },
  {
    "objectID": "lectures/lecture04/2_particle_in_a_box.html",
    "href": "lectures/lecture04/2_particle_in_a_box.html",
    "title": "Particle in a box",
    "section": "",
    "text": "Let’s apply the whole thing to the problem of a particle in a box. This means, we look at a quantum mechanical object in a potential well.\nThe problem is sketched below.\nWe need to define this rectangular box with zero potential energy inside the box and finite potential energy outside. Since the quantum mechanical object is a wave, we expect that only certain standing waves of particular wavelength can exist inside the box. These waves are connected to certain probability densities of finding the particle at certain positions and specific energy values. These are the energy levels, which are often characteristic of the quantum realm."
  },
  {
    "objectID": "lectures/lecture04/2_particle_in_a_box.html#definition-of-the-problem",
    "href": "lectures/lecture04/2_particle_in_a_box.html#definition-of-the-problem",
    "title": "Particle in a box",
    "section": "Definition of the problem",
    "text": "Definition of the problem\nBefore we start, we need to define some quantities:\n\nwe will study a box of d=1 nm in width in a domain of L=5 nm\nwe will use N=1001 points for our \\(x_{i}\\)\nour potential energy shall have a barrier height of 1 eV\nthe potential energy inside the box will be zero\n\n\n\n\n\n\n\n\nPotential energy\nWe first define the diagonal potential energy matrix.\n\n\n\n\n\n\n\n\nKinetic energy\nNext are the derivatives of the kinetic energy matrix.\n\n\n\n\n\n\nAn finally the total Hamilton operator matrix.\n\n\n\n\n\n\n\n\nSolution\nThe last step is to solve the system of coupled equations usering the eigsh method of the scipy module. We can already anticipate that we get multiple solution, e.g. multiple wavelength that fit inside the box. So there must be a certain number of eigenvalues. The method eigsh allows to specify the number of eigenvalues and eigenfunctions \\(n\\) we would like to calculate.\n\n\n\n\n\n\n\n\nPlotting\n\n\n\n\n\n\nThe diagram shows the corresponding energy states (the eigenvalues of the solution) and the value \\(|\\Psi|^2\\), which gives the probability to find the particle inside the box. The latter shows, that in contrast to what we expect from classical theory, where we would expect the particle to be with equal probability found at all positions inside the box, we get in quantum mechanics only certain positions at which we would find the particle. Also, the higher the energy state, the more equally is the particle distributed over the box. For a finite box depth, however, we get only a finite number of energy states in which the particle is bound. A second interesting observation here is that the particle has a finite probability to enter the potential barrier. Especially for the higher energy states, the wavefunction decays exponentially into the barrier. This is similar to the evanescent wave we studied during the last lecture.\n\n\nEnergies of bound states\nIn the case of the particle in a box only certain energies are allowed. The energies which correspond to these distributions are increasing nonlinearly with its index. Below we plot the energy as a function of the index of the energy value. This index is called quantum number as we can enumerate the solutions in quantum mechanics. The graph shows that the energy of the bound states increases with the square of the quantum number, i.e. \\(E_{n}\\propto n^2\\)."
  },
  {
    "objectID": "lectures/lecture04/2_particle_in_a_box.html#where-to-go-from-here",
    "href": "lectures/lecture04/2_particle_in_a_box.html#where-to-go-from-here",
    "title": "Particle in a box",
    "section": "Where to go from here?",
    "text": "Where to go from here?\nYou may try at this point to create two closely spaced potential wells, e.g. two of 1 nm width with a distance of 0.1 nm or with a distance of 2 nm. You should see that for large distances of the wells the energy values in the individual wells are the same, while for the smaller distance they split up into two due to the interaction.\n\n\n\nDouble Well"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html",
    "href": "seminars/seminar01/MDSimulation.html",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#lenard-jones-potential",
    "href": "seminars/seminar01/MDSimulation.html#lenard-jones-potential",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Lenard-Jones Potential",
    "text": "Lenard-Jones Potential\n\ndef lennard_jones(r, epsilon=1, sigma=1):\n    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n\nr = np.linspace(0.8, 3, 1000)\nV = lennard_jones(r)\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(r, V, 'b-', linewidth=2)\nplt.grid(True)\nplt.xlabel('r/σ')\nplt.ylabel('V/ε')\nplt.title('Lennard-Jones Potential')\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.ylim(-1.5, 3)\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#taylor-expansion",
    "href": "seminars/seminar01/MDSimulation.html#taylor-expansion",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Taylor Expansion",
    "text": "Taylor Expansion\n\nx = np.linspace(-2*np.pi, 2*np.pi, 1000)\ny = np.sin(x)\ny_taylor = x - 1/6*x**3\ny_taylor1 = x - 1/6*x**3+x**5/120\n\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\nplt.plot(x, y_taylor, 'r--', label='O(5)', linewidth=2)\nplt.plot(x, y_taylor1, 'g--', label='O(7)', linewidth=2)\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.xlim(-2,2)\nplt.ylim(-1.3,1.3)\nplt.title('Taylor Expansion of sin(x)')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#velocity-verlet",
    "href": "seminars/seminar01/MDSimulation.html#velocity-verlet",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Velocity Verlet",
    "text": "Velocity Verlet\n\ng = 9.81  # m/s^2\ndt = 0.01  # time step\nt_max = 2.0  # total simulation time\nsteps = int(t_max/dt)\n\n# Initial conditions\ny0 = 20.0  # initial height\nv0 = 0.0   # initial velocity\n\n\n# Arrays to store results\nt = np.zeros(steps)\ny = np.zeros(steps)\nv = np.zeros(steps)\na = np.zeros(steps)\n\n# Initial values\ny[0] = y0\nv[0] = v0\na[0] = -g\n\n# Velocity Verlet integration\nfor i in range(1, steps):\n    t[i] = i * dt\n    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n    a_new = -g                                          # new acceleration (assuming constant gravity)\n    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt  # update velocity\n    a[i] = a_new  # store new acceleration\n\nplt.figure(figsize=get_size(8, 6), dpi=150)\nplt.plot(t, y)\nplt.xlabel('Time (s)')\nplt.ylabel('Height (m)')\nplt.title('Free Fall Motion')\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#class-for-an-atom",
    "href": "seminars/seminar01/MDSimulation.html#class-for-an-atom",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Class for an Atom",
    "text": "Class for an Atom"
  },
  {
    "objectID": "seminars/Assignment 3.html",
    "href": "seminars/Assignment 3.html",
    "title": "Assignment 3",
    "section": "",
    "text": "Problem 1\nDefine a class with the name particle with a constructor that initializes the property D with twice the value supplied as an argument to the constructor. \n\nclass particle:\n    def __init__(self,R):\n        self.D=2*R\n\nProblem 2\nWrite a class particle that has a class variable id. Implement a constructor that assigns a unique id property to each instance from the class id, increasing by 1 each time an instance (object) is created. The first created object id should be 1.\n\nclass particle:\n    id = 0\n    def __init__(self):\n        particle.id+=1\n        self.id = particle.id\n    \n    def __del__(self):\n        particle.id-=1\n\nProblem 3\nWrite a class particle that is constructed with two parameters that are stored in the properties R and type_t of the object (R goes first). The type_t property should be of type string and be either “circle” or “square”.\nWrite a class method area that calculates the area of the object from the parameter R depending on the property type_t. The result of the area calculation should be stored in the property A, which should be 0 initially.\nCreate an object c which is a circle and compute its area. Create an object s which is a square without computing its area. The R parameter of these objects can be an arbitrary positive number.\nYou have two answer attempts without penalty.\n\nfrom math import pi\n\nclass particle:\n    def __init__(self, R, type_t):\n        self.R = R\n        self.type_t = type_t\n        self.A = 0\n        \n    def area(self):\n        if self.type_t == \"square\":\n            self.A = self.R**2\n        elif self.type_t == \"circle\":\n            self.A = pi*self.R**2\n        else:\n            self.A = 0\n            \nc=particle(3,\"circle\")\nc.area()\ns=particle(3,\"square\")\n\n\nc.A\n\n28.274333882308138"
  },
  {
    "objectID": "seminars/seminar04/Report/Figures/Figure2/Figure2.html",
    "href": "seminars/seminar04/Report/Figures/Figure2/Figure2.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "import matplotlib as mpl\nimport matplotlib.font_manager as font_manager\nfrom IPython.core.display import HTML\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom directory_tree import display_tree\n\n\nplt.rcParams.update({'font.size': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 11,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',}) \n\n%config InlineBackend.figure_format = 'retina'\n\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))\n\n\n# Generate fake experimental data\nx = np.linspace(0, 10, 100)\ny = np.sin(x) + np.random.normal(0, 0.2, size=100)\n\n# Set up the fancy plot\nfig, ax = plt.subplots(figsize=get_size(8, 6),dpi=150)\nax.plot(x, y, color='blue', linewidth=2, label='EXP',alpha=0.5)\n\n# Add some fancy elements to the plot\nax.fill_between(x, y, color='lightgray')\nax.scatter(x, y, color='blue', s=30, label='DATA ',alpha=0.5)\n\nax.set_xlabel('Time')\nax.set_ylabel('Measurement')\n\nax.legend(loc='lower right')\n\nax.tick_params(axis='both', which='major')\n\nax.grid(color='gray', linestyle='--', linewidth=0.5)\n\nax.annotate('Interesting\\nPoint', xy=(4.8, 0), xytext=(4.8, 0.7),\n            arrowprops=dict(facecolor='black', arrowstyle='-&gt;'),\n            fontsize=10, ha='center')\nplt.savefig(\"../figure2.pdf\",bbox_inches = 'tight')\nplt.show()"
  },
  {
    "objectID": "seminars/seminar04/25_publication_ready_figures.html",
    "href": "seminars/seminar04/25_publication_ready_figures.html",
    "title": "Zusatz: Erstellung veröffentlichungsreifer Diagramme",
    "section": "",
    "text": "Optimale Plotgrößen für wissenschaftliche Arbeiten\nIn diesem Leitfaden zeige ich Ihnen, wie Sie Plots in einer standardisierten, publikationstauglichen Größe erstellen können. Die Hinweise sind sowohl für Jupyter-Notebooks als auch für wissenschaftliche Arbeiten wie Semesterarbeiten geeignet.\nBeim Export von Plots als PDF-Dateien werden Vektorgrafiken erzeugt, die sich nachträglich verlustfrei skalieren lassen. Dies ermöglicht zwar eine flexible Anpassung an ein- oder zweispaltige Layoutformate, kann aber zu Inkonsistenzen führen: Unterschiedliche Skalierungsfaktoren resultieren oft in verschiedenen Größen von Achsenbeschriftungen und Markierungen, was das Gesamtbild der Arbeit beeinträchtigt.\nDie bessere Strategie ist es, von Anfang an einheitliche Plotgrößen zu verwenden: - Definieren Sie Standards für ein- und zweispaltige Abbildungen - Legen Sie einheitliche Größen für Achsenbeschriftungen und Markierungen fest - Erstellen Sie alle Plots direkt in der finalen Größe\nIm Folgenden stelle ich praktische Techniken vor, mit denen Sie direkt aus Jupyter-Notebooks publikationsreife Plots erstellen und speichern können."
  },
  {
    "objectID": "seminars/seminar04/25_publication_ready_figures.html#erstellen-eines-diagramms-mit-einer-bestimmten-größe-des-begrenzungsrahmens",
    "href": "seminars/seminar04/25_publication_ready_figures.html#erstellen-eines-diagramms-mit-einer-bestimmten-größe-des-begrenzungsrahmens",
    "title": "Zusatz: Erstellung veröffentlichungsreifer Diagramme",
    "section": "Erstellen eines Diagramms mit einer bestimmten Größe des Begrenzungsrahmens",
    "text": "Erstellen eines Diagramms mit einer bestimmten Größe des Begrenzungsrahmens\nWenn Sie einen Plot in matplotlib erstellen, können Sie eine Größe mit dem Parameter figsize festlegen, z.B.\nplt.figure(figsize=(3,2))\nfür eine Abbildung mit einer Breite von 3 inches bzw. 7,62 cm und einer Höhe von 2 inches (5,08 cm). Wenn Sie diesen Parameter nicht verwenden oder sogar den Befehl plt.figure() nicht nutzen, verwendet matplotlib die Standardgröße, die häufig 8 inches mal 6 inches beträgt. Diese Standardgröße ist viel zu groß, da die Abbildung dann fast eine ganze A4-Seite breit wäre. Eine angemessene Größe für einen Plot in einer einzelnen Spalte eines zweispaltigen Dokuments wären die oben genannten 3 inches mal 2 inches, da die gesamte Seitenbreite 21 cm minus einem Rand von etwa 3 cm auf jeder Seite eine Spaltenbreite von ungefähr (21-6)/2=7,5 cm ergibt.\nDer in Figure 1 gezeigte Plot wurde mit den folgenden Befehlen erstellt\nplt.figure(figsize=(3,2), dpi=150)\nx=np.linspace(0,np.pi*4,200)\nplt.plot(x,np.sin(x),color='k')\nplt.xlabel(r\"angle $\\theta$ in [rad]\")\nplt.ylabel(r\"$\\sin(\\theta)$\")\nplt.savefig(\"figure_example.pdf\",\n    bbox_inches = 'tight')\nplt.show()\nDie daraus resultierende PDF-Datei enthält eine Grafik mit einem Begrenzungsrahmen, der genau 3 Zoll mal 2 Zoll groß ist. Wenn Sie das Diagramm in ein beliebiges Zeichenprogramm wie Adobe Illustrator, Affinity Designer oder sogar in eine Textverarbeitungssoftware wie Word oder Pages einfügen, hat der Begrenzungsrahmen dieses Diagramms genau diese Größe, und Sie können weitere Diagramme anordnen, um eine ganze Abbildung zu erstellen, ohne die Skalierung ändern zu müssen. Wenn Sie das Diagramm in einem zweispaltigen LaTeX-Manuskript verwenden, kann es ohne Skalierung verwendet werden, d.h. durch includegraphics{Figure 1.pdf} wird es in der entsprechenden Größe über eine Spalte angezeigt.\nEs gibt noch ein paar weitere Dinge zu beachten.\n\nWährend der Begrenzungsrahmen dieser Abbildung diese Größe hat, ist der Achsenrahmen kleiner, und oft bleibt auf der linken/unteren Seite ein gewisser Leerraum zwischen den Achsenbeschriftungen und dem Rand des Begrenzungsrahmens. Das hängt sehr stark von Ihrem spezifischen Diagramm ab. Wie Sie eine Abbildung mit einer festen Achsenrahmengröße erstellen, wird im zweiten Abschnitt behandelt.\nDie Schriftgröße auf der Achse beträgt jetzt 10 oder 11 Punkte, was der Schriftgröße der meisten Dokumente entspricht, die Sie mit dieser Abbildung erstellen. Ich habe die folgenden plt.rcParams verwendet: ‘axes.labelsize’: 11, ‘xtick.labelsize’ : 10, ‘ytick.labelsize’ : 10 für die gezeigte Darstellung.\nSie werden auch feststellen, dass die Arbeit mit dieser Abbildungsgröße in einem Jupyter-Notebook nicht gut ist. Das hat damit zu tun, wie Jupyter die Ausgabe in eine PNG-Datei übersetzt, die inline angezeigt wird. Eine Möglichkeit, den Plot im Jupyter-Notebook zu vergrößern, aber die PDF-Größe beizubehalten, besteht darin, den Parameter dpi im Befehl plt.figure(figsize=(3,2), dpi=150) zu erhöhen. Normalerweise ist er auf dpi=75 eingestellt, was jetzt viel zu klein ist. Eine Einstellung von dpi=150 scheint ein vernünftiger Kompromiss zwischen Bildschirm- und Druckgröße zu sein. Wenn Sie völlig unabhängig sein wollen\nDer Befehl plt.savefig verwendet einen zusätzlichen bbox_inches = 'tight' Parameter, der sicherstellt, dass die Boundingbox auch wirklich alle Komponenten des Plots genau umschließt.\n\n\nimport matplotlib as mpl\nimport matplotlib.font_manager as font_manager\nfrom IPython.core.display import HTML\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom directory_tree import display_tree\n\n\nplt.rcParams.update({'font.size': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 11,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',\n                     'figure.dpi': 150})\n\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))\n\n\nplt.figure(figsize=get_size(7,6))\nx=np.linspace(0,np.pi*4,200)\nplt.plot(x,np.sin(x),color='k')\nplt.xlabel(r\"angle $\\theta$ in [rad]\")\nplt.ylabel(r\"$\\sin(\\theta)$\")\nplt.tight_layout()\nplt.savefig(\"figure_example3.pdf\", bbox_inches='tight')\nplt.show()\n\n\n\n\n\n\n\n\nWenn Sie dieses Bild in eine beliebige Software laden, erhalten Sie ein Bild mit einer Größe, die der eingestellten Breite entspricht.\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "seminars/seminar04/25_publication_ready_figures.html#erstellen-eines-diagramms-mit-einer-bestimmten-achsenrahmengröße",
    "href": "seminars/seminar04/25_publication_ready_figures.html#erstellen-eines-diagramms-mit-einer-bestimmten-achsenrahmengröße",
    "title": "Zusatz: Erstellung veröffentlichungsreifer Diagramme",
    "section": "Erstellen eines Diagramms mit einer bestimmten Achsenrahmengröße",
    "text": "Erstellen eines Diagramms mit einer bestimmten Achsenrahmengröße\nDer Achsenrahmen ist die Box des Rahmens, der die Achsen bereitstellt. Beim Erstellen einer Figur mit dem Befehl plt.figure() wird der Achsenrahmen von matplotlib so berechnet, dass er innerhalb der durch figsize angegebenen Boundingbox liegt, so dass alle Achsenbeschriftungen ebenfalls hineinpassen. Der Achsenrahmen ist daher kleiner als die angegebene Bounding Box und hängt oft von den Achsenbeschriftungen und weiteren Dingen ab. Wenn Sie einen Plot mit einer festen Größe des Achsenrahmens erstellen wollen, ist es sinnvoll, eine Funktion in Ihrem Code unterzubringen, die die Größe des Achsenrahmens festlegt. Diese Funktion könnte lauten\ndef set_size(w,h, ax=None):\n    \"\"\" w, h: width, height in inches \"\"\"\n    if not ax: ax=plt.gca()\n    l = ax.figure.subplotpars.left\n    r = ax.figure.subplotpars.right\n    t = ax.figure.subplotpars.top\n    b = ax.figure.subplotpars.bottom\n    figw = float(w)/(r-l)\n    figh = float(h)/(t-b)\n    ax.figure.set_size_inches(figw, figh)\nwobei Sie die gewünschte Breite und Höhe (in Zoll) der aktuellen Achse ax angeben müssen. Die Funktion gibt nichts zurück, sondern legt direkt die Größe fest.\n\ndef set_size(w,h, ax=None):\n    \"\"\" w, h: width, height in inches \"\"\"\n    if not ax: ax=plt.gca()\n    l = ax.figure.subplotpars.left\n    r = ax.figure.subplotpars.right\n    t = ax.figure.subplotpars.top\n    b = ax.figure.subplotpars.bottom\n    figw = float(w)/(r-l)\n    figh = float(h)/(t-b)\n    ax.figure.set_size_inches(figw, figh)\n\nfig=plt.figure(dpi=150)\nax=plt.axes()\nax.plot(x,np.sin(x),color='k')\nax.set_xlabel(r\"angle $\\theta$ in [rad]\")\nax.set_ylabel(r\"$\\sin(\\theta)$\")\nset_size(3,2)\nplt.savefig(\"figure_example2.pdf\",bbox_inches = 'tight')\nplt.show()\n\n\n\n\n\n\n\n\nWenn Sie diese Abbildung in ein Grafikprogramm oder eine Textverarbeitungssoftware laden, sollte das Abbildungsfeld eine Größe von 7,62 cm mal 5,08 cm haben, ohne dass eine Neuskalierung erfolgt:"
  },
  {
    "objectID": "seminars/seminar04/25_publication_ready_figures.html#auswahl-der-schriftarten",
    "href": "seminars/seminar04/25_publication_ready_figures.html#auswahl-der-schriftarten",
    "title": "Zusatz: Erstellung veröffentlichungsreifer Diagramme",
    "section": "Auswahl der Schriftarten",
    "text": "Auswahl der Schriftarten\nMatplotlib kann auf eine Reihe von verschiedenen Schriftarten zugreifen. Es kann schwierig sein, die passende Schriftart für den Formelstil Ihres Dokuments oder Ihrer Publikation zu finden. Eine Liste der Schriftarten, die Matplotlib zur Verfügung stehen, kann mit dem folgenden Codeschnipsel abgerufen werden, den ich hier gefunden habe.\n\nfrom IPython.display import HTML, display\n\ndef make_html(fontname):\n    return \"&lt;p&gt;{font}: &lt;span style='font-family:{font}; font-size: 24px;'&gt;{font}&lt;/p&gt;\".format(font=fontname)\n\ncode = \"\\n\".join([make_html(font) for font in sorted(set([f.name for f in font_manager.fontManager.ttflist]))])\n\ndisplay(HTML(\"&lt;div style='column-count: 2;'&gt;{}&lt;/div&gt;\".format(code)))\n\n.Aqua Kana: .Aqua Kana\n.CJK Symbols Fallback HK: .CJK Symbols Fallback HK\n.Keyboard: .Keyboard\n.New York: .New York\n.SF Arabic: .SF Arabic\n.SF Arabic Rounded: .SF Arabic Rounded\n.SF Armenian: .SF Armenian\n.SF Armenian Rounded: .SF Armenian Rounded\n.SF Camera: .SF Camera\n.SF Compact: .SF Compact\n.SF Compact Rounded: .SF Compact Rounded\n.SF Georgian: .SF Georgian\n.SF Georgian Rounded: .SF Georgian Rounded\n.SF Hebrew: .SF Hebrew\n.SF Hebrew Rounded: .SF Hebrew Rounded\n.SF NS Mono: .SF NS Mono\n.SF NS Rounded: .SF NS Rounded\n.SF Soft Numeric: .SF Soft Numeric\n.ThonburiUI: .ThonburiUI\nAcademy Engraved LET: Academy Engraved LET\nAgency FB: Agency FB\nAl Bayan: Al Bayan\nAl Nile: Al Nile\nAl Tarikh: Al Tarikh\nAmerican Typewriter: American Typewriter\nAndale Mono: Andale Mono\nApple Braille: Apple Braille\nApple Chancery: Apple Chancery\nApple SD Gothic Neo: Apple SD Gothic Neo\nApple Symbols: Apple Symbols\nAppleGothic: AppleGothic\nAppleMyungjo: AppleMyungjo\nArial: Arial\nArial Black: Arial Black\nArial Hebrew: Arial Hebrew\nArial Narrow: Arial Narrow\nArial Rounded MT Bold: Arial Rounded MT Bold\nArial Unicode MS: Arial Unicode MS\nArtifakt Element: Artifakt Element\nAthelas: Athelas\nAvenir: Avenir\nAvenir Next: Avenir Next\nAvenir Next Condensed: Avenir Next Condensed\nAyuthaya: Ayuthaya\nBaghdad: Baghdad\nBangla MN: Bangla MN\nBangla Sangam MN: Bangla Sangam MN\nBaskerville: Baskerville\nBeirut: Beirut\nBig Caslon: Big Caslon\nBodoni 72: Bodoni 72\nBodoni 72 Oldstyle: Bodoni 72 Oldstyle\nBodoni 72 Smallcaps: Bodoni 72 Smallcaps\nBodoni Ornaments: Bodoni Ornaments\nBradley Hand: Bradley Hand\nBrush Script MT: Brush Script MT\nChalkboard: Chalkboard\nChalkboard SE: Chalkboard SE\nChalkduster: Chalkduster\nCharter: Charter\nCochin: Cochin\nComic Sans MS: Comic Sans MS\nCopperplate: Copperplate\nCorsiva Hebrew: Corsiva Hebrew\nCourier: Courier\nCourier New: Courier New\nDIN Alternate: DIN Alternate\nDIN Condensed: DIN Condensed\nDamascus: Damascus\nDecoType Naskh: DecoType Naskh\nDejaVu Sans: DejaVu Sans\nDejaVu Sans Display: DejaVu Sans Display\nDejaVu Sans Mono: DejaVu Sans Mono\nDejaVu Serif: DejaVu Serif\nDejaVu Serif Display: DejaVu Serif Display\nDevanagari MT: Devanagari MT\nDevanagari Sangam MN: Devanagari Sangam MN\nDidot: Didot\nDiwan Kufi: Diwan Kufi\nDiwan Thuluth: Diwan Thuluth\nEuphemia UCAS: Euphemia UCAS\nFarah: Farah\nFarisi: Farisi\nFutura: Futura\nGalvji: Galvji\nGeeza Pro: Geeza Pro\nGeneva: Geneva\nGeorgia: Georgia\nGill Sans: Gill Sans\nGujarati MT: Gujarati MT\nGujarati Sangam MN: Gujarati Sangam MN\nGurmukhi MN: Gurmukhi MN\nGurmukhi MT: Gurmukhi MT\nGurmukhi Sangam MN: Gurmukhi Sangam MN\nHeiti TC: Heiti TC\nHelvetica: Helvetica\nHelvetica Neue: Helvetica Neue\nHerculanum: Herculanum\nHiragino Maru Gothic Pro: Hiragino Maru Gothic Pro\nHiragino Mincho ProN: Hiragino Mincho ProN\nHiragino Sans: Hiragino Sans\nHiragino Sans GB: Hiragino Sans GB\nHoefler Text: Hoefler Text\nITF Devanagari: ITF Devanagari\nImpact: Impact\nInaiMathi: InaiMathi\nIowan Old Style: Iowan Old Style\nKailasa: Kailasa\nKannada MN: Kannada MN\nKannada Sangam MN: Kannada Sangam MN\nKefa: Kefa\nKhmer MN: Khmer MN\nKhmer Sangam MN: Khmer Sangam MN\nKohinoor Bangla: Kohinoor Bangla\nKohinoor Devanagari: Kohinoor Devanagari\nKohinoor Gujarati: Kohinoor Gujarati\nKohinoor Telugu: Kohinoor Telugu\nKokonor: Kokonor\nKrungthep: Krungthep\nKufiStandardGK: KufiStandardGK\nLao MN: Lao MN\nLao Sangam MN: Lao Sangam MN\nLucida Grande: Lucida Grande\nLuminari: Luminari\nMalayalam MN: Malayalam MN\nMalayalam Sangam MN: Malayalam Sangam MN\nMarion: Marion\nMarker Felt: Marker Felt\nMenlo: Menlo\nMicrosoft Sans Serif: Microsoft Sans Serif\nMishafi: Mishafi\nMishafi Gold: Mishafi Gold\nMonaco: Monaco\nMshtakan: Mshtakan\nMukta Mahee: Mukta Mahee\nMuna: Muna\nMyanmar MN: Myanmar MN\nMyanmar Sangam MN: Myanmar Sangam MN\nNadeem: Nadeem\nNew Peninim MT: New Peninim MT\nNoteworthy: Noteworthy\nNoto Nastaliq Urdu: Noto Nastaliq Urdu\nNoto Sans Adlam: Noto Sans Adlam\nNoto Sans Armenian: Noto Sans Armenian\nNoto Sans Avestan: Noto Sans Avestan\nNoto Sans Bamum: Noto Sans Bamum\nNoto Sans Bassa Vah: Noto Sans Bassa Vah\nNoto Sans Batak: Noto Sans Batak\nNoto Sans Bhaiksuki: Noto Sans Bhaiksuki\nNoto Sans Brahmi: Noto Sans Brahmi\nNoto Sans Buginese: Noto Sans Buginese\nNoto Sans Buhid: Noto Sans Buhid\nNoto Sans Canadian Aboriginal: Noto Sans Canadian Aboriginal\nNoto Sans Carian: Noto Sans Carian\nNoto Sans Caucasian Albanian: Noto Sans Caucasian Albanian\nNoto Sans Chakma: Noto Sans Chakma\nNoto Sans Cham: Noto Sans Cham\nNoto Sans Coptic: Noto Sans Coptic\nNoto Sans Cuneiform: Noto Sans Cuneiform\nNoto Sans Cypriot: Noto Sans Cypriot\nNoto Sans Duployan: Noto Sans Duployan\nNoto Sans Egyptian Hieroglyphs: Noto Sans Egyptian Hieroglyphs\nNoto Sans Elbasan: Noto Sans Elbasan\nNoto Sans Glagolitic: Noto Sans Glagolitic\nNoto Sans Gothic: Noto Sans Gothic\nNoto Sans Gunjala Gondi: Noto Sans Gunjala Gondi\nNoto Sans Hanifi Rohingya: Noto Sans Hanifi Rohingya\nNoto Sans Hanunoo: Noto Sans Hanunoo\nNoto Sans Hatran: Noto Sans Hatran\nNoto Sans Imperial Aramaic: Noto Sans Imperial Aramaic\nNoto Sans Inscriptional Pahlavi: Noto Sans Inscriptional Pahlavi\nNoto Sans Inscriptional Parthian: Noto Sans Inscriptional Parthian\nNoto Sans Javanese: Noto Sans Javanese\nNoto Sans Kaithi: Noto Sans Kaithi\nNoto Sans Kannada: Noto Sans Kannada\nNoto Sans Kayah Li: Noto Sans Kayah Li\nNoto Sans Kharoshthi: Noto Sans Kharoshthi\nNoto Sans Khojki: Noto Sans Khojki\nNoto Sans Khudawadi: Noto Sans Khudawadi\nNoto Sans Lepcha: Noto Sans Lepcha\nNoto Sans Limbu: Noto Sans Limbu\nNoto Sans Linear A: Noto Sans Linear A\nNoto Sans Linear B: Noto Sans Linear B\nNoto Sans Lisu: Noto Sans Lisu\nNoto Sans Lycian: Noto Sans Lycian\nNoto Sans Lydian: Noto Sans Lydian\nNoto Sans Mahajani: Noto Sans Mahajani\nNoto Sans Mandaic: Noto Sans Mandaic\nNoto Sans Manichaean: Noto Sans Manichaean\nNoto Sans Marchen: Noto Sans Marchen\nNoto Sans Masaram Gondi: Noto Sans Masaram Gondi\nNoto Sans Meetei Mayek: Noto Sans Meetei Mayek\nNoto Sans Mende Kikakui: Noto Sans Mende Kikakui\nNoto Sans Meroitic: Noto Sans Meroitic\nNoto Sans Miao: Noto Sans Miao\nNoto Sans Modi: Noto Sans Modi\nNoto Sans Mongolian: Noto Sans Mongolian\nNoto Sans Mro: Noto Sans Mro\nNoto Sans Multani: Noto Sans Multani\nNoto Sans Myanmar: Noto Sans Myanmar\nNoto Sans NKo: Noto Sans NKo\nNoto Sans Nabataean: Noto Sans Nabataean\nNoto Sans New Tai Lue: Noto Sans New Tai Lue\nNoto Sans Newa: Noto Sans Newa\nNoto Sans Ol Chiki: Noto Sans Ol Chiki\nNoto Sans Old Hungarian: Noto Sans Old Hungarian\nNoto Sans Old Italic: Noto Sans Old Italic\nNoto Sans Old North Arabian: Noto Sans Old North Arabian\nNoto Sans Old Permic: Noto Sans Old Permic\nNoto Sans Old Persian: Noto Sans Old Persian\nNoto Sans Old South Arabian: Noto Sans Old South Arabian\nNoto Sans Old Turkic: Noto Sans Old Turkic\nNoto Sans Oriya: Noto Sans Oriya\nNoto Sans Osage: Noto Sans Osage\nNoto Sans Osmanya: Noto Sans Osmanya\nNoto Sans Pahawh Hmong: Noto Sans Pahawh Hmong\nNoto Sans Palmyrene: Noto Sans Palmyrene\nNoto Sans Pau Cin Hau: Noto Sans Pau Cin Hau\nNoto Sans PhagsPa: Noto Sans PhagsPa\nNoto Sans Phoenician: Noto Sans Phoenician\nNoto Sans Psalter Pahlavi: Noto Sans Psalter Pahlavi\nNoto Sans Rejang: Noto Sans Rejang\nNoto Sans Samaritan: Noto Sans Samaritan\nNoto Sans Saurashtra: Noto Sans Saurashtra\nNoto Sans Sharada: Noto Sans Sharada\nNoto Sans Siddham: Noto Sans Siddham\nNoto Sans Sora Sompeng: Noto Sans Sora Sompeng\nNoto Sans Sundanese: Noto Sans Sundanese\nNoto Sans Syloti Nagri: Noto Sans Syloti Nagri\nNoto Sans Syriac: Noto Sans Syriac\nNoto Sans Tagalog: Noto Sans Tagalog\nNoto Sans Tagbanwa: Noto Sans Tagbanwa\nNoto Sans Tai Le: Noto Sans Tai Le\nNoto Sans Tai Tham: Noto Sans Tai Tham\nNoto Sans Tai Viet: Noto Sans Tai Viet\nNoto Sans Takri: Noto Sans Takri\nNoto Sans Thaana: Noto Sans Thaana\nNoto Sans Tifinagh: Noto Sans Tifinagh\nNoto Sans Tirhuta: Noto Sans Tirhuta\nNoto Sans Ugaritic: Noto Sans Ugaritic\nNoto Sans Vai: Noto Sans Vai\nNoto Sans Wancho: Noto Sans Wancho\nNoto Sans Warang Citi: Noto Sans Warang Citi\nNoto Sans Yi: Noto Sans Yi\nNoto Serif Ahom: Noto Serif Ahom\nNoto Serif Balinese: Noto Serif Balinese\nNoto Serif Hmong Nyiakeng: Noto Serif Hmong Nyiakeng\nNoto Serif Myanmar: Noto Serif Myanmar\nNoto Serif Yezidi: Noto Serif Yezidi\nOptima: Optima\nOriya MN: Oriya MN\nOriya Sangam MN: Oriya Sangam MN\nPT Mono: PT Mono\nPT Sans: PT Sans\nPT Serif: PT Serif\nPT Serif Caption: PT Serif Caption\nPalatino: Palatino\nPapyrus: Papyrus\nParty LET: Party LET\nPhosphate: Phosphate\nPlantagenet Cherokee: Plantagenet Cherokee\nRaanana: Raanana\nRockwell: Rockwell\nSF Grandezza: SF Grandezza\nSTIX Two Math: STIX Two Math\nSTIX Two Text: STIX Two Text\nSTIXGeneral: STIXGeneral\nSTIXIntegralsD: STIXIntegralsD\nSTIXIntegralsSm: STIXIntegralsSm\nSTIXIntegralsUp: STIXIntegralsUp\nSTIXIntegralsUpD: STIXIntegralsUpD\nSTIXIntegralsUpSm: STIXIntegralsUpSm\nSTIXNonUnicode: STIXNonUnicode\nSTIXSizeFiveSym: STIXSizeFiveSym\nSTIXSizeFourSym: STIXSizeFourSym\nSTIXSizeOneSym: STIXSizeOneSym\nSTIXSizeThreeSym: STIXSizeThreeSym\nSTIXSizeTwoSym: STIXSizeTwoSym\nSTIXVariants: STIXVariants\nSana: Sana\nSathu: Sathu\nSavoye LET: Savoye LET\nSeravek: Seravek\nShree Devanagari 714: Shree Devanagari 714\nSignPainter: SignPainter\nSilom: Silom\nSinhala MN: Sinhala MN\nSinhala Sangam MN: Sinhala Sangam MN\nSkia: Skia\nSnell Roundhand: Snell Roundhand\nSongti SC: Songti SC\nSukhumvit Set: Sukhumvit Set\nSuperclarendon: Superclarendon\nSymbol: Symbol\nSystem Font: System Font\nTahoma: Tahoma\nTamil MN: Tamil MN\nTamil Sangam MN: Tamil Sangam MN\nTelugu MN: Telugu MN\nTelugu Sangam MN: Telugu Sangam MN\nThonburi: Thonburi\nTimes: Times\nTimes New Roman: Times New Roman\nTrattatello: Trattatello\nTrebuchet MS: Trebuchet MS\nVerdana: Verdana\nWaseem: Waseem\nWebdings: Webdings\nWingdings: Wingdings\nWingdings 2: Wingdings 2\nWingdings 3: Wingdings 3\nZapf Dingbats: Zapf Dingbats\nZapfino: Zapfino\ncmb10: cmb10\ncmex10: cmex10\ncmmi10: cmmi10\ncmr10: cmr10\ncmss10: cmss10\ncmsy10: cmsy10\ncmtt10: cmtt10\n\n\nFalls Sie Ihr Dokument in LaTeX schreiben, könnten die cmXXXX-Schriften für Sie von Interesse sein, da sie den in LaTeX-Dokumenten verwendeten Schriften entsprechen. Hier ist ein Beispiel:\n\ncmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf')\nplt.rcParams.update({'font.size': 12,\n                     'axes.titlesize': 12,\n                     'axes.labelsize': 12,\n                     'axes.labelpad': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',\n                     'font.family' : 'serif',\n                     'font.serif' : cmfont.get_name(),\n                     \"axes.formatter.use_mathtext\": True,\n                     'text.usetex': True,\n                     'mathtext.fontset' : 'cm'\n                    })\n\n\nx=np.linspace(0,np.pi,100)\n\n\nplt.figure(figsize=get_size(6,5),dpi=150)\nplt.plot(x,np.sin(x))\nplt.xlabel(r\"velocity $v$\")\nplt.ylabel(r\"position $r$\")\nplt.show()"
  },
  {
    "objectID": "seminars/seminar04/25_publication_ready_figures.html#ein-dokument-vorbereiten",
    "href": "seminars/seminar04/25_publication_ready_figures.html#ein-dokument-vorbereiten",
    "title": "Zusatz: Erstellung veröffentlichungsreifer Diagramme",
    "section": "Ein Dokument vorbereiten",
    "text": "Ein Dokument vorbereiten\nWenn man ein Dokument (Bachelorarbeit z.B.) erstellt, ist es nützlich, seine Daten und Texte geschickt zur organisieren, um sich Arbeit zu ersparen. Hier ist ein Beipiel,\n\ndisplay_tree(\"Report\")\n\nReport/\n├── Figures/\n│   ├── Figure1/\n│   │   └── Figure1.ipynb\n│   ├── figure1.pdf\n│   ├── Figure2/\n│   │   └── Figure2.ipynb\n│   └── figure2.pdf\n└── Text/\n    ├── article.aux\n    ├── article.fdb_latexmk\n    ├── article.fls\n    ├── article.log\n    ├── article.pdf\n    ├── article.synctex.gz\n    ├── article.tex\n    ├── content/\n    │   ├── 01_introduction.tex\n    │   ├── 02_theory.tex\n    │   ├── 03_results.tex\n    │   └── 04_conclusions.tex\n    ├── paper.aux\n    ├── paper.bbl\n    ├── paper.blg\n    ├── paper.fdb_latexmk\n    ├── paper.fls\n    ├── paper.log\n    ├── paper.pdf\n    ├── paper.synctex.gz\n    ├── paper.tex\n    └── paperNotes.bib\n\n\n/var/folders/6n/52yj404d5ld29901s85pd6sh0000gn/T/ipykernel_81143/929351223.py:1: DeprecationWarning:\n\nThe `display_tree` Function is Deprecated and will be Removed in a Future Release. Please use `DirectoryTree` Instead. End of Life Date is \"31st December 2024\"."
  },
  {
    "objectID": "seminars/seminar03/MD Simulation.html",
    "href": "seminars/seminar03/MD Simulation.html",
    "title": "MD Simulation",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))"
  },
  {
    "objectID": "seminars/seminar03/MD Simulation.html#atom-class",
    "href": "seminars/seminar03/MD Simulation.html#atom-class",
    "title": "MD Simulation",
    "section": "Atom Class",
    "text": "Atom Class\n\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n\n\nclass ForceField:\n    def __init__(self):\n        self.parameters = {\n            'C': {'epsilon': 1.0, 'sigma': 3.4},\n            'H': {'epsilon': 1, 'sigma': 1},\n            'O': {'epsilon': 0.8, 'sigma': 3.0},\n        }\n        self.box_size = None  # Will be set when initializing the simulation\n\n    def get_pair_parameters(self, type1, type2):\n        # Apply mixing rules when needed\n        eps1 = self.parameters[type1]['epsilon']\n        eps2 = self.parameters[type2]['epsilon']\n        sig1 = self.parameters[type1]['sigma']\n        sig2 = self.parameters[type2]['sigma']\n\n        # Lorentz-Berthelot mixing rules\n        epsilon = np.sqrt(eps1 * eps2)\n        sigma = (sig1 + sig2) / 2\n\n        return epsilon, sigma\n\n    def minimum_image_distance(self, pos1, pos2):\n        \"\"\"Calculate minimum image distance between two positions\"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention\n        delta = delta - self.box_size * np.round(delta / self.box_size)\n        return delta\n\n    def calculate_lj_force(self, atom1, atom2):\n        epsilon, sigma = self.get_pair_parameters(atom1.type, atom2.type)\n        r = self.minimum_image_distance(atom1.position, atom2.position)\n        r_mag = np.linalg.norm(r)\n\n        # Add cutoff distance for stability\n        if r_mag &gt; 2.5*sigma:\n            return np.zeros(2)\n\n        force_mag = 24 * epsilon * (\n            2 * (sigma/r_mag)**13\n            - (sigma/r_mag)**7\n        )\n        force = force_mag * r/r_mag\n        return force\n\n\nclass MDSimulation:\n    def __init__(self, atoms, forcefield, timestep, box_size):\n        self.atoms = atoms\n        self.forcefield = forcefield\n        self.forcefield.box_size = box_size  # Set box size in forcefield\n        self.timestep = timestep\n        self.box_size = np.array(box_size)\n        self.initial_energy = None\n        self.energy_history = []\n\n    def minimum_image_distance(self, pos1, pos2):\n        \"\"\"Calculate minimum image distance between two positions\"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention\n        delta = delta - self.box_size * np.round(delta / self.box_size)\n        return delta\n\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\n    def update_positions_and_velocities(self):\n        # First step: Update positions using current forces\n        for atom in self.atoms:\n            atom.update_position(self.timestep)\n            # Apply periodic boundary conditions\n            atom.apply_periodic_boundaries(self.box_size)\n\n        # Store current forces for velocity update\n        old_forces = {atom.id: atom.force.copy() for atom in self.atoms}\n\n        # Recalculate forces with new positions\n        self.calculate_forces()\n\n        # Second step: Update velocities using average of old and new forces\n        for atom in self.atoms:\n            atom.update_velocity(self.timestep, atom.force)\n\n\ndef create_grid_atoms(num_atoms, box_size, mass=1.0, random_offset=0.1):\n    box_size = np.array(box_size)\n\n    # Calculate grid dimensions\n    n = int(np.ceil(np.sqrt(num_atoms)))\n    spacing = np.min(box_size) / n\n\n    atoms = []\n    for i in range(num_atoms):\n        # Calculate grid position\n        row = i // n\n        col = i % n\n\n        # Base position\n        pos = np.array([col * spacing + spacing/2,\n                       row * spacing + spacing/2])\n\n        # Add random offset\n        pos += (np.random.rand(2) - 0.5) * spacing * random_offset\n\n        # Create atom\n        atoms.append(Atom(i, 'H', pos, mass=mass))\n\n    return atoms"
  },
  {
    "objectID": "seminars/seminar02/md2.html",
    "href": "seminars/seminar02/md2.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "In the previous document, we learned about the key components of a molecular dynamics simulation: - The Lennard-Jones potential describing forces between atoms - The Velocity Verlet algorithm for updating positions and velocities\nNow we’ll implement these concepts in code. To organize our simulation, we’ll have to think about some issues:\n\n\nIn the previous example, we have assumed that the particle is in free fall. That means eventually it would bounce against the floor. In a real simulation, we need to consider boundary conditions as well. For example, if the particle hits the ground we could implement a simple reflection rule. This is called reflecting boundary conditions and would introduce some additional effects to the simulation. On the other side, one could make the system “kind of” infinitely large by introducing periodic boundary conditions. This means that if a particle leaves the simulation box on one side, it re-enters on the opposite side. This is a common approach in molecular dynamics simulations.\n\n\n\nPerdiodic Boundary Conditions\n\n\n\n\n\n\n\n\nThe Minimum Image Convention in Molecular Dynamics\n\n\n\n\n\nWhen we simulate particles in a box with periodic boundary conditions (meaning particles that leave on one side reappear on the opposite side), we need to calculate the forces between them correctly. Imagine two particles near opposite edges of the box: one at position x=1 and another at x=9 in a box of length 10. Without the minimum image convention, we would calculate their distance as 8 units (9-1). However, due to the periodic boundaries, these particles could actually interact across the boundary, with a shorter distance of just 2 units! The minimum image convention automatically finds this shortest distance, ensuring that we calculate the forces between particles correctly. It’s like taking a shortcut across the periodic boundary instead of walking the longer path through the box.\n\n\n\n\n\n\nThe question we have to think about now is how to implement these formulas in a numerical simulation. The goal is to simulate the motion of many atoms in a box. Each atom is different and has its own position, velocity, and force. Consequently we need to store these quantities for each atom, though the structure in which we store them is the same for each atom. All atoms with their properties actually belong to the same class of objects. We can therefore use a very suitable concept of object-oriented programming, the class.\nA class in object-oriented programming is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods). The class is a template for objects, and an object is an instance of a class. The class defines the properties and behavior common to all objects of the class. The objects are the instances of the class that contain the actual data.\nThink of the Atom class as a container for everything we need to know about a single atom:\n\nIts position (where is it?)\nIts velocity (how fast is it moving?)\nThe forces acting on it (what’s pushing or pulling it?)\nIts type (is it hydrogen, oxygen, etc.?)\nIts mass (how heavy is it?)\n\n\n\n\nWe also have a set of forces, that is acting between the atoms. These forces are calculated based on the positions of the atoms. The force fields are all the same for the atoms only the parameters are different. We can represent the force field as a class as well. We will first implement the Lennard-Jones potential in the class. Later we will implement more complex force fields. We will realize that we will later have to introduce different parameters for the Lenard Jones potential for different atom types. We will store these parameters in a dictionary. This dictionary will be part of the force field class and actually represent the Force Field.\nIf atoms are of the same type, they will have the same parameters. However, if they are of different types we will have to mix the parameters. This is done by the mixing rules. We will implement the Lorentz-Berthelot mixing rules. These rules are used to calculate the parameters for the interaction between two different atom types.\n\n\nFor two different atoms (A and B), the Lennard-Jones parameters \\(\\sigma\\) and \\(\\epsilon\\) are calculated using:\n\nArithmetic mean for \\(\\sigma\\) (Lorentz rule):\n\\[\\sigma_{AB} = \\frac{\\sigma_A + \\sigma_B}{2}\\]\nGeometric mean for \\(\\epsilon\\) (Berthelot rule):\n\\[\\epsilon_{AB} = \\sqrt{\\epsilon_A \\epsilon_B}\\]\n\nThese parameters are then used in the Lennard-Jones potential:\n\\[V_{LJ}(r) = 4\\epsilon_{AB}\\left[\\left(\\frac{\\sigma_{AB}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{AB}}{r}\\right)^6\\right]\\]\n\n\n\n\nIn the previous example, we have started with a particle at rest. In a real simulation, we would like to start with a certain temperature. This means that the particles have a certain velocity distribution. We can introduce this by assigning random velocities to the particles. The velocities should be drawn from a Maxwell-Boltzmann distribution. This is a distribution that describes the velocity distribution of particles in at a certain temperature. The distribution is given by:\n\\[\nf_v\\left(v_x\\right)=\\sqrt{\\frac{m}{2 \\pi k_B T}} \\exp \\left[\\frac{-m v_x^2}{2 k_B T}\\right]\n\\]\nwhere \\(m\\) is the mass of the particle, \\(k_B\\) is Boltzmann’s constant, and \\(T\\) is the temperature. \\(v_x\\) is the velocity in the x-direction. The velocities in the y and z directions are drawn in the same way. The temperature of the system is related to the kinetic energy of the particles.\n\n\n\n\n\n\nMaxwell-Boltzmann Velocities in 3D\n\n\n\n\n\nThe probability distribution for the velocity magnitude in 3D is:\n\\[f(v) = 4\\pi v^2 \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\exp\\left(-\\frac{mv^2}{2k_BT}\\right)\\]\n\nMean velocity magnitude:\n\\[\\langle v \\rangle = \\sqrt{\\frac{8k_BT}{\\pi m}}\\]\nMost probable velocity (peak of distribution):\n\\[v_{mp} = \\sqrt{\\frac{2k_BT}{m}}\\]\nRoot mean square velocity:\n\\[v_{rms} = \\sqrt{\\frac{3k_BT}{m}}\\]\n\nThese velocities can also be expressed in terms of the kinetic energy of the particles. The average kinetic energy per particle is:\n\\[\\langle E_{kin} \\rangle = \\frac{3}{2}k_BT\\]\nThen we can express the velocities as:\n\nMean velocity magnitude:\n\\[\\langle v \\rangle = \\sqrt{\\frac{8\\langle E_{kin} \\rangle}{3\\pi m}}\\]\nMost probable velocity:\n\\[v_{mp} = \\sqrt{\\frac{4\\langle E_{kin} \\rangle}{3m}}\\]\nRoot mean square velocity:\n\\[v_{rms} = \\sqrt{\\frac{2\\langle E_{kin} \\rangle}{m}}\\]\n\n\n\n\n\n\nCode\n# Constants\nkb = 1.380649e-23  # Boltzmann constant in J/K\nm_H = 1.6735575e-27  # Mass of hydrogen atom in kg\nT = 300  # Temperature in K\n\n# Velocity range for plotting\nv = np.linspace(-10000, 10000, 1000)  # m/s\nv_mag = np.linspace(0, 10000, 1000)  # m/s\n\n# Maxwell-Boltzmann distribution for x-component\ndef MB_1D(v, m, T):\n    return np.sqrt(m/(2*np.pi*kb*T)) * np.exp(-m*v**2/(2*kb*T))\n\n# Maxwell-Boltzmann distribution for velocity magnitude in 2D\ndef MB_2D_mag(v, m, T):\n    return v * m/(kb*T) * np.exp(-m*v**2/(2*kb*T))\n\n# Create figure\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(16, 8))\n\n# Plot x-component distribution\nax1.plot(v, MB_1D(v, m_H, T))\nax1.set_xlabel('Velocity [m/s]')\nax1.set_ylabel('Probability density')\n\n# Plot magnitude distribution\nax2.plot(v_mag, MB_2D_mag(v_mag, m_H, T))\nax2.set_xlabel('Velocity magnitude [m/s]')\nax2.set_ylabel('Probability density')\nax2.axvline(np.sqrt(kb*T/m_H), color='r', linestyle='--', label='Most probable velocity')\nax2.axvline(np.sqrt(2)*np.sqrt(kb*T/m_H), color='g', linestyle='--', label='Mean velocity')\n\nplt.tight_layout()\nplt.show()\n\n# Print most probable velocity\nv_mp_1D = 0  # Most probable velocity for 1D is zero\nv_mp_2D = np.sqrt(kb*T/m_H)  # Most probable velocity magnitude in 2D\nprint(f\"Most probable velocity magnitude in 2D: {v_mp_2D:.1f} m/s\")\nprint(f\"Mean velocity magnitude in 2D: {np.sqrt(2)*v_mp_2D:.1f} m/s\")\n\n\n\n\n\n\n\n\n\nMost probable velocity magnitude in 2D: 1573.2 m/s\nMean velocity magnitude in 2D: 2224.8 m/s\n\n\nThe temperature T in a 2D system is related to the kinetic energy by:\n\\[T = \\frac{2K}{N_f k_B}\\]\nwhere:\n\nK is the total kinetic energy: \\(K = \\sum_i \\frac{1}{2}m_i v_i^2\\)\n\\(N_f\\) is the number of degrees of freedom (2N in 2D, where N is number of particles)\n\\(k_B\\) is Boltzmann’s constant (often set to 1 in reduced units)\n\nTo scale to a target temperature \\(T_{target}\\), we multiply velocities by \\(\\sqrt{\\frac{T_{target}}{T_{current}}}\\)\n\n\n\nFinally, we need a class that controls the simulation. This class will contain the main loop of the simulation, where the integration algorithm is called in each time step. It will also contain the methods to calculate the forces between the atoms.\n\n\n\nBefore we implement all classes, we will first visualize the particles moving in a 2D box. We will use the matplotlib library to create an animation of the particles moving in the box. We will also implement periodic boundary conditions, so that particles that leave the box on one side re-enter on the opposite side.\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\n\nn_side =2\n\n1x = np.linspace(0.05, 0.95, n_side)\ny = np.linspace(0.05, 0.95, n_side)\n2xx, yy = np.meshgrid(x, y)\n3particles = np.vstack([xx.ravel(), yy.ravel()]).T\n\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\n\nradius = 0.0177\nfig, ax = plt.subplots(figsize=(9,9))\n\nn_steps = 200\n\n4for _ in range(n_steps):\n5    clear_output(wait=True)\n\n    # Update particle positions based on their velocities\n    particles += velocities\n    # Apply periodic boundary conditions in x direction (wrap around at 0 and 1)\n    particles[:, 0] = particles[:, 0] % 1\n    # Apply periodic boundary conditions in y direction (wrap around at 0 and 1)\n    particles[:, 1] = particles[:, 1] % 1\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    # distances &lt; 2*radius gives a boolean matrix where True means collision\n    # np.triu takes only the upper triangle to avoid counting collisions twice\n    collisions = np.triu(distances &lt; 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Exchange velocities between colliding particles (elastic collision)\n6        velocities[i], velocities[j] = velocities[j], velocities[i].copy()\n\n        # Calculate how much particles overlap\n        overlap = 2*radius - distances[i, j]\n\n        # Calculate unit vector pointing from j to i\n        direction = particles[i] - particles[j]\n        direction /= np.linalg.norm(direction)\n\n        # Move particles apart to prevent overlap\n        particles[i] += 0.5 * overlap * direction\n        particles[j] -= 0.5 * overlap * direction\n\n    ax.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.axis(\"off\")\n\n    display(fig)\n    plt.pause(0.01)\n\n    # Clear the current plot to prepare for next frame\n    ax.clear()\n\n1\n\nCreate a 1D array of x and y-coordinates for the particles.\n\n2\n\nCreate a meshgrid of x and y-coordinates.\n\n3\n\nFlatten the meshgrid to get a 2D array of particle positions.\n\n4\n\nSimulation loop\n\n5\n\nClear the output to display the animation in a single cell.\n\n6\n\nHandle collisions between particles by exchanging velocities and moving particles apart to prevent overlap. The exchange of velocities in your code works because of the conservation of momentum and energy:\n\n\n\nFor two particles of equal mass m in a head-on elastic collision: Before collision:\n\nMomentum: \\(p = mv_1 + mv_2\\)\nEnergy: \\(E = \\frac{1}{2}mv_1^2 + \\frac{1}{2}mv_2^2\\)\n\nAfter collision (with velocity exchange): - Momentum: \\(p = mv_2 + mv_1\\) (same as before!) - Energy: \\(E = \\frac{1}{2}mv_2^2 + \\frac{1}{2}mv_1^2\\) (same as before!)",
    "crumbs": [
      "Seminars",
      "Seminar02",
      "MD Simulation Part 2"
    ]
  },
  {
    "objectID": "seminars/seminar02/md2.html#from-theory-to-code",
    "href": "seminars/seminar02/md2.html#from-theory-to-code",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "In the previous document, we learned about the key components of a molecular dynamics simulation: - The Lennard-Jones potential describing forces between atoms - The Velocity Verlet algorithm for updating positions and velocities\nNow we’ll implement these concepts in code. To organize our simulation, we’ll have to think about some issues:\n\n\nIn the previous example, we have assumed that the particle is in free fall. That means eventually it would bounce against the floor. In a real simulation, we need to consider boundary conditions as well. For example, if the particle hits the ground we could implement a simple reflection rule. This is called reflecting boundary conditions and would introduce some additional effects to the simulation. On the other side, one could make the system “kind of” infinitely large by introducing periodic boundary conditions. This means that if a particle leaves the simulation box on one side, it re-enters on the opposite side. This is a common approach in molecular dynamics simulations.\n\n\n\nPerdiodic Boundary Conditions\n\n\n\n\n\n\n\n\nThe Minimum Image Convention in Molecular Dynamics\n\n\n\n\n\nWhen we simulate particles in a box with periodic boundary conditions (meaning particles that leave on one side reappear on the opposite side), we need to calculate the forces between them correctly. Imagine two particles near opposite edges of the box: one at position x=1 and another at x=9 in a box of length 10. Without the minimum image convention, we would calculate their distance as 8 units (9-1). However, due to the periodic boundaries, these particles could actually interact across the boundary, with a shorter distance of just 2 units! The minimum image convention automatically finds this shortest distance, ensuring that we calculate the forces between particles correctly. It’s like taking a shortcut across the periodic boundary instead of walking the longer path through the box.\n\n\n\n\n\n\nThe question we have to think about now is how to implement these formulas in a numerical simulation. The goal is to simulate the motion of many atoms in a box. Each atom is different and has its own position, velocity, and force. Consequently we need to store these quantities for each atom, though the structure in which we store them is the same for each atom. All atoms with their properties actually belong to the same class of objects. We can therefore use a very suitable concept of object-oriented programming, the class.\nA class in object-oriented programming is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods). The class is a template for objects, and an object is an instance of a class. The class defines the properties and behavior common to all objects of the class. The objects are the instances of the class that contain the actual data.\nThink of the Atom class as a container for everything we need to know about a single atom:\n\nIts position (where is it?)\nIts velocity (how fast is it moving?)\nThe forces acting on it (what’s pushing or pulling it?)\nIts type (is it hydrogen, oxygen, etc.?)\nIts mass (how heavy is it?)\n\n\n\n\nWe also have a set of forces, that is acting between the atoms. These forces are calculated based on the positions of the atoms. The force fields are all the same for the atoms only the parameters are different. We can represent the force field as a class as well. We will first implement the Lennard-Jones potential in the class. Later we will implement more complex force fields. We will realize that we will later have to introduce different parameters for the Lenard Jones potential for different atom types. We will store these parameters in a dictionary. This dictionary will be part of the force field class and actually represent the Force Field.\nIf atoms are of the same type, they will have the same parameters. However, if they are of different types we will have to mix the parameters. This is done by the mixing rules. We will implement the Lorentz-Berthelot mixing rules. These rules are used to calculate the parameters for the interaction between two different atom types.\n\n\nFor two different atoms (A and B), the Lennard-Jones parameters \\(\\sigma\\) and \\(\\epsilon\\) are calculated using:\n\nArithmetic mean for \\(\\sigma\\) (Lorentz rule):\n\\[\\sigma_{AB} = \\frac{\\sigma_A + \\sigma_B}{2}\\]\nGeometric mean for \\(\\epsilon\\) (Berthelot rule):\n\\[\\epsilon_{AB} = \\sqrt{\\epsilon_A \\epsilon_B}\\]\n\nThese parameters are then used in the Lennard-Jones potential:\n\\[V_{LJ}(r) = 4\\epsilon_{AB}\\left[\\left(\\frac{\\sigma_{AB}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{AB}}{r}\\right)^6\\right]\\]\n\n\n\n\nIn the previous example, we have started with a particle at rest. In a real simulation, we would like to start with a certain temperature. This means that the particles have a certain velocity distribution. We can introduce this by assigning random velocities to the particles. The velocities should be drawn from a Maxwell-Boltzmann distribution. This is a distribution that describes the velocity distribution of particles in at a certain temperature. The distribution is given by:\n\\[\nf_v\\left(v_x\\right)=\\sqrt{\\frac{m}{2 \\pi k_B T}} \\exp \\left[\\frac{-m v_x^2}{2 k_B T}\\right]\n\\]\nwhere \\(m\\) is the mass of the particle, \\(k_B\\) is Boltzmann’s constant, and \\(T\\) is the temperature. \\(v_x\\) is the velocity in the x-direction. The velocities in the y and z directions are drawn in the same way. The temperature of the system is related to the kinetic energy of the particles.\n\n\n\n\n\n\nMaxwell-Boltzmann Velocities in 3D\n\n\n\n\n\nThe probability distribution for the velocity magnitude in 3D is:\n\\[f(v) = 4\\pi v^2 \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\exp\\left(-\\frac{mv^2}{2k_BT}\\right)\\]\n\nMean velocity magnitude:\n\\[\\langle v \\rangle = \\sqrt{\\frac{8k_BT}{\\pi m}}\\]\nMost probable velocity (peak of distribution):\n\\[v_{mp} = \\sqrt{\\frac{2k_BT}{m}}\\]\nRoot mean square velocity:\n\\[v_{rms} = \\sqrt{\\frac{3k_BT}{m}}\\]\n\nThese velocities can also be expressed in terms of the kinetic energy of the particles. The average kinetic energy per particle is:\n\\[\\langle E_{kin} \\rangle = \\frac{3}{2}k_BT\\]\nThen we can express the velocities as:\n\nMean velocity magnitude:\n\\[\\langle v \\rangle = \\sqrt{\\frac{8\\langle E_{kin} \\rangle}{3\\pi m}}\\]\nMost probable velocity:\n\\[v_{mp} = \\sqrt{\\frac{4\\langle E_{kin} \\rangle}{3m}}\\]\nRoot mean square velocity:\n\\[v_{rms} = \\sqrt{\\frac{2\\langle E_{kin} \\rangle}{m}}\\]\n\n\n\n\n\n\nCode\n# Constants\nkb = 1.380649e-23  # Boltzmann constant in J/K\nm_H = 1.6735575e-27  # Mass of hydrogen atom in kg\nT = 300  # Temperature in K\n\n# Velocity range for plotting\nv = np.linspace(-10000, 10000, 1000)  # m/s\nv_mag = np.linspace(0, 10000, 1000)  # m/s\n\n# Maxwell-Boltzmann distribution for x-component\ndef MB_1D(v, m, T):\n    return np.sqrt(m/(2*np.pi*kb*T)) * np.exp(-m*v**2/(2*kb*T))\n\n# Maxwell-Boltzmann distribution for velocity magnitude in 2D\ndef MB_2D_mag(v, m, T):\n    return v * m/(kb*T) * np.exp(-m*v**2/(2*kb*T))\n\n# Create figure\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(16, 8))\n\n# Plot x-component distribution\nax1.plot(v, MB_1D(v, m_H, T))\nax1.set_xlabel('Velocity [m/s]')\nax1.set_ylabel('Probability density')\n\n# Plot magnitude distribution\nax2.plot(v_mag, MB_2D_mag(v_mag, m_H, T))\nax2.set_xlabel('Velocity magnitude [m/s]')\nax2.set_ylabel('Probability density')\nax2.axvline(np.sqrt(kb*T/m_H), color='r', linestyle='--', label='Most probable velocity')\nax2.axvline(np.sqrt(2)*np.sqrt(kb*T/m_H), color='g', linestyle='--', label='Mean velocity')\n\nplt.tight_layout()\nplt.show()\n\n# Print most probable velocity\nv_mp_1D = 0  # Most probable velocity for 1D is zero\nv_mp_2D = np.sqrt(kb*T/m_H)  # Most probable velocity magnitude in 2D\nprint(f\"Most probable velocity magnitude in 2D: {v_mp_2D:.1f} m/s\")\nprint(f\"Mean velocity magnitude in 2D: {np.sqrt(2)*v_mp_2D:.1f} m/s\")\n\n\n\n\n\n\n\n\n\nMost probable velocity magnitude in 2D: 1573.2 m/s\nMean velocity magnitude in 2D: 2224.8 m/s\n\n\nThe temperature T in a 2D system is related to the kinetic energy by:\n\\[T = \\frac{2K}{N_f k_B}\\]\nwhere:\n\nK is the total kinetic energy: \\(K = \\sum_i \\frac{1}{2}m_i v_i^2\\)\n\\(N_f\\) is the number of degrees of freedom (2N in 2D, where N is number of particles)\n\\(k_B\\) is Boltzmann’s constant (often set to 1 in reduced units)\n\nTo scale to a target temperature \\(T_{target}\\), we multiply velocities by \\(\\sqrt{\\frac{T_{target}}{T_{current}}}\\)\n\n\n\nFinally, we need a class that controls the simulation. This class will contain the main loop of the simulation, where the integration algorithm is called in each time step. It will also contain the methods to calculate the forces between the atoms.\n\n\n\nBefore we implement all classes, we will first visualize the particles moving in a 2D box. We will use the matplotlib library to create an animation of the particles moving in the box. We will also implement periodic boundary conditions, so that particles that leave the box on one side re-enter on the opposite side.\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\n\nn_side =2\n\n1x = np.linspace(0.05, 0.95, n_side)\ny = np.linspace(0.05, 0.95, n_side)\n2xx, yy = np.meshgrid(x, y)\n3particles = np.vstack([xx.ravel(), yy.ravel()]).T\n\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\n\nradius = 0.0177\nfig, ax = plt.subplots(figsize=(9,9))\n\nn_steps = 200\n\n4for _ in range(n_steps):\n5    clear_output(wait=True)\n\n    # Update particle positions based on their velocities\n    particles += velocities\n    # Apply periodic boundary conditions in x direction (wrap around at 0 and 1)\n    particles[:, 0] = particles[:, 0] % 1\n    # Apply periodic boundary conditions in y direction (wrap around at 0 and 1)\n    particles[:, 1] = particles[:, 1] % 1\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    # distances &lt; 2*radius gives a boolean matrix where True means collision\n    # np.triu takes only the upper triangle to avoid counting collisions twice\n    collisions = np.triu(distances &lt; 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Exchange velocities between colliding particles (elastic collision)\n6        velocities[i], velocities[j] = velocities[j], velocities[i].copy()\n\n        # Calculate how much particles overlap\n        overlap = 2*radius - distances[i, j]\n\n        # Calculate unit vector pointing from j to i\n        direction = particles[i] - particles[j]\n        direction /= np.linalg.norm(direction)\n\n        # Move particles apart to prevent overlap\n        particles[i] += 0.5 * overlap * direction\n        particles[j] -= 0.5 * overlap * direction\n\n    ax.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.axis(\"off\")\n\n    display(fig)\n    plt.pause(0.01)\n\n    # Clear the current plot to prepare for next frame\n    ax.clear()\n\n1\n\nCreate a 1D array of x and y-coordinates for the particles.\n\n2\n\nCreate a meshgrid of x and y-coordinates.\n\n3\n\nFlatten the meshgrid to get a 2D array of particle positions.\n\n4\n\nSimulation loop\n\n5\n\nClear the output to display the animation in a single cell.\n\n6\n\nHandle collisions between particles by exchanging velocities and moving particles apart to prevent overlap. The exchange of velocities in your code works because of the conservation of momentum and energy:\n\n\n\nFor two particles of equal mass m in a head-on elastic collision: Before collision:\n\nMomentum: \\(p = mv_1 + mv_2\\)\nEnergy: \\(E = \\frac{1}{2}mv_1^2 + \\frac{1}{2}mv_2^2\\)\n\nAfter collision (with velocity exchange): - Momentum: \\(p = mv_2 + mv_1\\) (same as before!) - Energy: \\(E = \\frac{1}{2}mv_2^2 + \\frac{1}{2}mv_1^2\\) (same as before!)",
    "crumbs": [
      "Seminars",
      "Seminar02",
      "MD Simulation Part 2"
    ]
  },
  {
    "objectID": "seminars/seminar05/md5.html",
    "href": "seminars/seminar05/md5.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Previously we wrote our simulation with classes for the atoms, the force-field and the MD simulation.Now we want to implement the velocity initialization. We will use the Maxwell-Boltzmann distribution to generate random velocities for the particles in our system. This ensures that our system starts in a state of thermal equilibrium, reflecting the physical reality of molecular motion.\nThe Maxwell-Boltzmann distribution stands as a cornerstone principle in molecular dynamics (MD) simulations, providing us with a statistical description of particle velocities in a system at thermal equilibrium. This distribution emerged from the kinetic theory of gases and proves invaluable in understanding how molecules move and interact at various temperatures.\n\n\nAt its heart, the Maxwell-Boltzmann distribution tells us the probability of finding a particle moving at a particular velocity in a system at thermal equilibrium. The mathematical expression for this probability density \\(f(v)\\) is:\n\\[f(v) = \\sqrt{\\left(\\frac{m}{2\\pi k_B T}\\right)^3} 4\\pi v^2 \\exp\\left(-\\frac{mv^2}{2k_B T}\\right)\\]\nHere, \\(m\\) represents the particle mass, \\(k_B\\) is Boltzmann’s constant, \\(T\\) denotes the temperature in Kelvin, and \\(v\\) is the velocity magnitude. We can also write down the Maxwell-Boltzmann distribution in terms of the velocity components \\(v_x\\), \\(v_y\\), and \\(v_z\\). For each of these components, the distribution is given by\n\\[\nf(v_x) = \\sqrt{\\frac{m}{2\\pi k_B T}} \\exp\\left(-\\frac{m v_x^2}{2 k_B T}\\right)\n\\]\nThe Maxwell-Boltzmann distribution has the following properties\nThe mean velocity of the particles is of course zero as the system as a whole does not move. The mean magnitude of the velocity can be calculated from\n\\[\n\\bar{v}=\\int_0^{\\infty} v p(v) \\mathrm{d} v\n\\]\nwhich results in\n\\[\n\\bar{v}=\\sqrt{\\frac{8 k_{\\mathrm{B}} T}{\\pi m}}\n\\]\nWhat is also important is the mean squared velocity which can be calculated by\n\\[\n\\overline{v^2}=\\int_0^{\\infty} v^2 p(v) d v\n\\]\nsince this will provide the mean kinetic energy of the particles. This results in\n\\[\n\\overline{v^2}=\\frac{3 k_{\\mathrm{B}} T}{m}\n\\]\nThis is consisten with a kinetic energy of \\(1/2 k_{\\mathrm{B}} T\\) per degree of freedom.\nSince we use in MD simulations with Lennard-Jones atoms reduced units, we can also express the Maxwell-Boltzmann distribution in reduced units. The reduced temperature is defined as \\(T^{*}=k_{\\mathrm{B}} T / \\varepsilon\\) and the reduced velocity as \\(v^{*}=v / \\sqrt{\\varepsilon / m}\\). The reduced Maxwell-Boltzmann distribution is then\n\\[\nf(v^{*}) = \\sqrt{\\left(\\frac{1}{2\\pi T^{*}}\\right)^3} 4\\pi v^{*2} \\exp\\left(-\\frac{v^{2}}{2T^{*}}\\right)\n\\]\nOur goal is to generate random velocities for particles in our MD simulations that follow this distribution. This ensures that our system starts in a state of thermal equilibrium, reflecting the physical reality of molecular motion.\n\n\n\n\nviewof reducedTemp = Inputs.range([0.1, 5], {\n  step: 0.1,\n  value: 1.0,\n  label: \"Reduced Temperature (T*)\"\n})\n\n// Generate distribution data in reduced units\nfunction generateReducedData() {\n  const data = [];\n  // Generate points for reduced velocities from 0 to 5\n  for (let v = 0; v &lt;= 5; v += 0.05) {\n    const term1 = Math.sqrt((1 / (2 * Math.PI * reducedTemp)) ** 3);\n    const term2 = 4 * Math.PI * v * v;\n    const term3 = Math.exp((-v * v) / (2 * reducedTemp));\n    data.push({\n      velocity: v,\n      probability: term1 * term2 * term3\n    });\n  }\n  return data;\n}\n\nPlot.plot({\n  width: 400,\n  height: 400,\n  margin: 50,\n  grid: true,\n  style: {\n    fontSize: 16\n  },\n  x: {\n    label: \"Reduced Velocity (v*)\",\n    domain: [0, 5],\n  },\n  y: {\n    label: \"Probability Density\",\n  },\n  marks: [\n    Plot.line(generateReducedData(), {\n      x: \"velocity\",\n      y: \"probability\",\n      stroke: \"blue\"\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe interactive plot above demonstrates how the Maxwell-Boltzmann distribution changes with temperature and molecular mass. Try adjusting the sliders to see how:\n\nIncreasing temperature broadens the distribution and shifts the peak to higher velocities\nIncreasing molecular mass narrows the distribution and shifts the peak to lower velocities\n\n\n\n\nWhen we begin an MD simulation, one of our first tasks is to assign initial velocities to all particles in our system. The Maxwell-Boltzmann distribution guides this process, ensuring that our initial configuration reflects physical reality. We typically generate random velocities following this distribution while ensuring that the total momentum of the system remains zero – a condition that prevents our system from drifting as a whole.\n\n\n\nHere’s how we can implement velocity initialization following the Maxwell-Boltzmann distribution:\ndef initialize_velocities(atoms, temperature, seed=None):\n    if seed is not None:\n        np.random.seed(seed)\n\n    N = len(atoms)\n    dim = 2\n\n\n    velocities = np.random.normal(0, np.sqrt(temperature), size=(N, dim))\n\n\n    total_momentum = np.sum([atom.mass * velocities[i] for i, atom in enumerate(atoms)], axis=0)\n    total_mass = np.sum([atom.mass for atom in atoms])\n    cm_velocity = total_momentum / total_mass\n\n    for i, atom in enumerate(atoms):\n        atom.velocity = velocities[i] - cm_velocity\n\n    set_temperature(atoms, temperature)\n\n    return atoms\nIn molecular dynamics simulations, it is crucial to control the temperature of the system to ensure that it reflects the desired physical conditions. The temperature of a system in MD simulations is directly related to the kinetic energy of the particles. If the initial velocities of the particles do not correspond to the target temperature, the system will not accurately represent the intended thermodynamic state.\nScaling the velocities of the particles is a common technique to adjust the temperature of the system. By scaling the velocities, we can ensure that the kinetic energy—and hence the temperature—matches the target value. This process is essential for initializing the system correctly and for maintaining the desired temperature during the simulation.\nThe provided code scales the velocities of the atoms to achieve the target temperature. Here’s a step-by-step explanation of the code:\n\ndef set_temperature(atoms, target_temperature):\n    N = len(atoms)      # number of atoms\n    Nf = 2 * N         # degrees of freedom in 2D\n\n    # Calculate current kinetic energy\n    current_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\n    current_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n\n    # Calculate scaling factor\n    scale_factor = np.sqrt(target_temperature / current_temperature)\n\n    # Scale velocities\n    for atom in atoms:\n        atom.velocity *= scale_factor\n\nThis code snippet sets the temperature of the system to the target temperature by scaling the velocities of the atoms. Here’s a breakdown of the key steps:\n\nNumber of Atoms and Degrees of Freedom:\nN = len(atoms)      # number of atoms\nNf = 2 * N         # degrees of freedom in 2D\n\nN is the number of atoms in the system.\nNf is the number of degrees of freedom. In a 2D system, each atom has 2 degrees of freedom (one for each spatial dimension), so Nf = 2 * N.\n\nCalculate Current Kinetic Energy:\ncurrent_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\ncurrent_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n\nThe current kinetic energy (current_ke) is calculated by summing the kinetic energy of each atom. The kinetic energy of an atom is given by ( m v^2 ), where m is the mass and v is the velocity.\nThe current temperature (current_temperature) is then calculated using the relation ( T = ). Here, the Boltzmann constant ( k_B ) is assumed to be 1 in reduced units.\n\nCalculate Scaling Factor:\nscale_factor = np.sqrt(target_temperature / current_temperature)\n\nThe scaling factor is calculated as the square root of the ratio of the target temperature to the current temperature. This factor will be used to scale the velocities of the atoms.\n\nScale Velocities:\nfor atom in atoms:\n    atom.velocity *= scale_factor\n\nThe velocities of all atoms are scaled by the calculated scaling factor. This adjustment ensures that the kinetic energy—and thus the temperature—of the system matches the target temperature.",
    "crumbs": [
      "Seminars",
      "Seminar05",
      "MD Simulation Part 5"
    ]
  },
  {
    "objectID": "seminars/seminar05/md5.html#temperature-and-velocity-initialization",
    "href": "seminars/seminar05/md5.html#temperature-and-velocity-initialization",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Previously we wrote our simulation with classes for the atoms, the force-field and the MD simulation.Now we want to implement the velocity initialization. We will use the Maxwell-Boltzmann distribution to generate random velocities for the particles in our system. This ensures that our system starts in a state of thermal equilibrium, reflecting the physical reality of molecular motion.\nThe Maxwell-Boltzmann distribution stands as a cornerstone principle in molecular dynamics (MD) simulations, providing us with a statistical description of particle velocities in a system at thermal equilibrium. This distribution emerged from the kinetic theory of gases and proves invaluable in understanding how molecules move and interact at various temperatures.\n\n\nAt its heart, the Maxwell-Boltzmann distribution tells us the probability of finding a particle moving at a particular velocity in a system at thermal equilibrium. The mathematical expression for this probability density \\(f(v)\\) is:\n\\[f(v) = \\sqrt{\\left(\\frac{m}{2\\pi k_B T}\\right)^3} 4\\pi v^2 \\exp\\left(-\\frac{mv^2}{2k_B T}\\right)\\]\nHere, \\(m\\) represents the particle mass, \\(k_B\\) is Boltzmann’s constant, \\(T\\) denotes the temperature in Kelvin, and \\(v\\) is the velocity magnitude. We can also write down the Maxwell-Boltzmann distribution in terms of the velocity components \\(v_x\\), \\(v_y\\), and \\(v_z\\). For each of these components, the distribution is given by\n\\[\nf(v_x) = \\sqrt{\\frac{m}{2\\pi k_B T}} \\exp\\left(-\\frac{m v_x^2}{2 k_B T}\\right)\n\\]\nThe Maxwell-Boltzmann distribution has the following properties\nThe mean velocity of the particles is of course zero as the system as a whole does not move. The mean magnitude of the velocity can be calculated from\n\\[\n\\bar{v}=\\int_0^{\\infty} v p(v) \\mathrm{d} v\n\\]\nwhich results in\n\\[\n\\bar{v}=\\sqrt{\\frac{8 k_{\\mathrm{B}} T}{\\pi m}}\n\\]\nWhat is also important is the mean squared velocity which can be calculated by\n\\[\n\\overline{v^2}=\\int_0^{\\infty} v^2 p(v) d v\n\\]\nsince this will provide the mean kinetic energy of the particles. This results in\n\\[\n\\overline{v^2}=\\frac{3 k_{\\mathrm{B}} T}{m}\n\\]\nThis is consisten with a kinetic energy of \\(1/2 k_{\\mathrm{B}} T\\) per degree of freedom.\nSince we use in MD simulations with Lennard-Jones atoms reduced units, we can also express the Maxwell-Boltzmann distribution in reduced units. The reduced temperature is defined as \\(T^{*}=k_{\\mathrm{B}} T / \\varepsilon\\) and the reduced velocity as \\(v^{*}=v / \\sqrt{\\varepsilon / m}\\). The reduced Maxwell-Boltzmann distribution is then\n\\[\nf(v^{*}) = \\sqrt{\\left(\\frac{1}{2\\pi T^{*}}\\right)^3} 4\\pi v^{*2} \\exp\\left(-\\frac{v^{2}}{2T^{*}}\\right)\n\\]\nOur goal is to generate random velocities for particles in our MD simulations that follow this distribution. This ensures that our system starts in a state of thermal equilibrium, reflecting the physical reality of molecular motion.\n\n\n\n\nviewof reducedTemp = Inputs.range([0.1, 5], {\n  step: 0.1,\n  value: 1.0,\n  label: \"Reduced Temperature (T*)\"\n})\n\n// Generate distribution data in reduced units\nfunction generateReducedData() {\n  const data = [];\n  // Generate points for reduced velocities from 0 to 5\n  for (let v = 0; v &lt;= 5; v += 0.05) {\n    const term1 = Math.sqrt((1 / (2 * Math.PI * reducedTemp)) ** 3);\n    const term2 = 4 * Math.PI * v * v;\n    const term3 = Math.exp((-v * v) / (2 * reducedTemp));\n    data.push({\n      velocity: v,\n      probability: term1 * term2 * term3\n    });\n  }\n  return data;\n}\n\nPlot.plot({\n  width: 400,\n  height: 400,\n  margin: 50,\n  grid: true,\n  style: {\n    fontSize: 16\n  },\n  x: {\n    label: \"Reduced Velocity (v*)\",\n    domain: [0, 5],\n  },\n  y: {\n    label: \"Probability Density\",\n  },\n  marks: [\n    Plot.line(generateReducedData(), {\n      x: \"velocity\",\n      y: \"probability\",\n      stroke: \"blue\"\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe interactive plot above demonstrates how the Maxwell-Boltzmann distribution changes with temperature and molecular mass. Try adjusting the sliders to see how:\n\nIncreasing temperature broadens the distribution and shifts the peak to higher velocities\nIncreasing molecular mass narrows the distribution and shifts the peak to lower velocities\n\n\n\n\nWhen we begin an MD simulation, one of our first tasks is to assign initial velocities to all particles in our system. The Maxwell-Boltzmann distribution guides this process, ensuring that our initial configuration reflects physical reality. We typically generate random velocities following this distribution while ensuring that the total momentum of the system remains zero – a condition that prevents our system from drifting as a whole.\n\n\n\nHere’s how we can implement velocity initialization following the Maxwell-Boltzmann distribution:\ndef initialize_velocities(atoms, temperature, seed=None):\n    if seed is not None:\n        np.random.seed(seed)\n\n    N = len(atoms)\n    dim = 2\n\n\n    velocities = np.random.normal(0, np.sqrt(temperature), size=(N, dim))\n\n\n    total_momentum = np.sum([atom.mass * velocities[i] for i, atom in enumerate(atoms)], axis=0)\n    total_mass = np.sum([atom.mass for atom in atoms])\n    cm_velocity = total_momentum / total_mass\n\n    for i, atom in enumerate(atoms):\n        atom.velocity = velocities[i] - cm_velocity\n\n    set_temperature(atoms, temperature)\n\n    return atoms\nIn molecular dynamics simulations, it is crucial to control the temperature of the system to ensure that it reflects the desired physical conditions. The temperature of a system in MD simulations is directly related to the kinetic energy of the particles. If the initial velocities of the particles do not correspond to the target temperature, the system will not accurately represent the intended thermodynamic state.\nScaling the velocities of the particles is a common technique to adjust the temperature of the system. By scaling the velocities, we can ensure that the kinetic energy—and hence the temperature—matches the target value. This process is essential for initializing the system correctly and for maintaining the desired temperature during the simulation.\nThe provided code scales the velocities of the atoms to achieve the target temperature. Here’s a step-by-step explanation of the code:\n\ndef set_temperature(atoms, target_temperature):\n    N = len(atoms)      # number of atoms\n    Nf = 2 * N         # degrees of freedom in 2D\n\n    # Calculate current kinetic energy\n    current_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\n    current_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n\n    # Calculate scaling factor\n    scale_factor = np.sqrt(target_temperature / current_temperature)\n\n    # Scale velocities\n    for atom in atoms:\n        atom.velocity *= scale_factor\n\nThis code snippet sets the temperature of the system to the target temperature by scaling the velocities of the atoms. Here’s a breakdown of the key steps:\n\nNumber of Atoms and Degrees of Freedom:\nN = len(atoms)      # number of atoms\nNf = 2 * N         # degrees of freedom in 2D\n\nN is the number of atoms in the system.\nNf is the number of degrees of freedom. In a 2D system, each atom has 2 degrees of freedom (one for each spatial dimension), so Nf = 2 * N.\n\nCalculate Current Kinetic Energy:\ncurrent_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\ncurrent_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n\nThe current kinetic energy (current_ke) is calculated by summing the kinetic energy of each atom. The kinetic energy of an atom is given by ( m v^2 ), where m is the mass and v is the velocity.\nThe current temperature (current_temperature) is then calculated using the relation ( T = ). Here, the Boltzmann constant ( k_B ) is assumed to be 1 in reduced units.\n\nCalculate Scaling Factor:\nscale_factor = np.sqrt(target_temperature / current_temperature)\n\nThe scaling factor is calculated as the square root of the ratio of the target temperature to the current temperature. This factor will be used to scale the velocities of the atoms.\n\nScale Velocities:\nfor atom in atoms:\n    atom.velocity *= scale_factor\n\nThe velocities of all atoms are scaled by the calculated scaling factor. This adjustment ensures that the kinetic energy—and thus the temperature—of the system matches the target temperature.",
    "crumbs": [
      "Seminars",
      "Seminar05",
      "MD Simulation Part 5"
    ]
  },
  {
    "objectID": "seminars/seminar05/md5.html#simulation-setup-and-initialization",
    "href": "seminars/seminar05/md5.html#simulation-setup-and-initialization",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "Simulation Setup and Initialization",
    "text": "Simulation Setup and Initialization\nThis now completes our initial code for the MD simulation and we can put it all together to run a simulation.\nbox_size = np.array([50.0, 50.0])  # Box dimensions\nnum_atoms = 200\n\nT=5\ndt = 0.01\n\n# Create atoms and set initial velocities\natoms = create_grid_atoms(num_atoms, box_size, type=\"H\",mass=1.0, random_offset=0.1)\natoms = initialize_velocities(atoms, temperature=T)\n\n\n# Create force field\nff = ForceField()\n\n\n# Create simulation with periodic boundaries\nsim = MDSimulation(atoms, ff, dt, box_size)\n\nfig, ax = plt.subplots(1,1,figsize=(6,6))\n\nfor step in range(1000):\n    clear_output(wait=True)\n    set_temperature(atoms, target_temperature=T)\n    sim.update_positions_and_velocities()\n\n    positions = [atom.position for atom in sim.atoms]\n    x_coords = [pos[0] for pos in positions]\n    y_coords = [pos[1] for pos in positions]\n\n    circle=patches.Circle((x_coords[0],y_coords[0]),ff.parameters[atoms[0].type][\"sigma\"],edgecolor=\"white\",fill=False)\n    ax.add_patch(circle)\n    ax.scatter(x_coords, y_coords,color=\"red\")\n    ax.set_xlim(0, box_size[0])\n    ax.set_ylim(0, box_size[1])\n    ax.axis(\"off\")\n\n    display(fig)\n\n    ax.clear()",
    "crumbs": [
      "Seminars",
      "Seminar05",
      "MD Simulation Part 5"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "course-info/schedule.html",
    "href": "course-info/schedule.html",
    "title": "Zeitplan für den Kurs",
    "section": "",
    "text": "Der Kurs wird wöchentlich mit dem Zeitplan der Vorlesungen aktualisiert. Erwarten Sie also jeden\nDienstag ab 15. Oktober 2024, jeweils um 11:15\neine neue Vorlesung und eine neue Aufgabe ab 13:00.\nErfahrungsgemäß werden die besten Ergebnisse erzielt, wenn Sie bei den Vorlesungen im Hörsaal anwesend sind. Das gesamte Material wird jedoch auch online zur Verfügung stehen, sodass Sie jederzeit darauf zugreifen können, um zu lernen, wann immer es Ihnen passt."
  },
  {
    "objectID": "course-info/resources.html",
    "href": "course-info/resources.html",
    "title": "Quellen",
    "section": "",
    "text": "Vor allen anderen Sachen ist es für diesen Kurs wichtig, dass Sie während der Vorlesung einen Internetzugang haben. Wir werden viele Beispiele und Übungen durchführen, die auf Online-Ressourcen verweisen.\nInnerhalb der Universität können die Eduroam-Netzwerke verwendet werden. Die notwendigen Profildaten können Sie hier finden.\nWeiterhin gibt es eine Menge weiterer gut strukturierter Ressourcen zu Python im Netz. Nachfolgend finden Sie nur eine sehr kleine Auswahl.",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#hypothesis-annotation-tool",
    "href": "course-info/resources.html#hypothesis-annotation-tool",
    "title": "Quellen",
    "section": "Hypothesis Annotation Tool",
    "text": "Hypothesis Annotation Tool\n\nInvite to the Hypothesis annotation tool",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#molecular-nanophotonics-group",
    "href": "course-info/resources.html#molecular-nanophotonics-group",
    "title": "Quellen",
    "section": "Molecular Nanophotonics Group",
    "text": "Molecular Nanophotonics Group\n\nMolecular Nanophotonics Group Website\nHypothesis Annotation Tool Invite",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#additional-advanced-courses",
    "href": "course-info/resources.html#additional-advanced-courses",
    "title": "Quellen",
    "section": "Additional Advanced Courses",
    "text": "Additional Advanced Courses\n\nRosenow Group (Theory), Master Course on Statistical Mechanics of Deep Learning",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#python-documentation",
    "href": "course-info/resources.html#python-documentation",
    "title": "Quellen",
    "section": "Python Documentation",
    "text": "Python Documentation\n\nPython\nMatplotlib\nPandas",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#python-tutorials",
    "href": "course-info/resources.html#python-tutorials",
    "title": "Quellen",
    "section": "Python Tutorials",
    "text": "Python Tutorials\n\nIntroduction to Python for Science\nNice MatPlotLib tutorial",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#julia-tutorial",
    "href": "course-info/resources.html#julia-tutorial",
    "title": "Quellen",
    "section": "Julia Tutorial",
    "text": "Julia Tutorial\n\nJulia Programming Language",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/resources.html#pluto-notebook",
    "href": "course-info/resources.html#pluto-notebook",
    "title": "Quellen",
    "section": "Pluto NoteBook",
    "text": "Pluto NoteBook\n\nPluto GitHub Webpage",
    "crumbs": [
      "Course Info",
      "Ressourcen"
    ]
  },
  {
    "objectID": "course-info/how_to_quiz.html",
    "href": "course-info/how_to_quiz.html",
    "title": "Interactive Python Quiz",
    "section": "",
    "text": "In this quiz, you can write and execute Python code directly in your browser.\n\n\nWrite a function square(n) that returns the square of a number.\n\n\n\n\n\n# Write your Python code here\ndef square(n):\n    return n * n\n\nprint(square(5))\n\n\nRun Code"
  },
  {
    "objectID": "course-info/how_to_quiz.html#question-1",
    "href": "course-info/how_to_quiz.html#question-1",
    "title": "Interactive Python Quiz",
    "section": "",
    "text": "Write a function square(n) that returns the square of a number.\n\n\n\n\n\n# Write your Python code here\ndef square(n):\n    return n * n\n\nprint(square(5))\n\n\nRun Code"
  },
  {
    "objectID": "course-info/intructors.html",
    "href": "course-info/intructors.html",
    "title": "Instructor",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Course Info",
      "Vorlesender"
    ]
  },
  {
    "objectID": "course-info/intructors.html#prof.-dr.-frank-cichos",
    "href": "course-info/intructors.html#prof.-dr.-frank-cichos",
    "title": "Instructor",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Course Info",
      "Vorlesender"
    ]
  },
  {
    "objectID": "course-info/assignments.html",
    "href": "course-info/assignments.html",
    "title": "Übungsaufgaben",
    "section": "",
    "text": "Es werden insgesamt 6 Übungsblätter zur Verfügung gestellt. Die Übungsblätter sind Teil der Prüfungsleistung! Die Übungsblätter werden nicht benotet, aber die Bearbeitung ist für den erfolgreichen Abschluss des Moduls erforderlich. Genauere Informationen zur Wertung der Übungsblätter finden sie auf der Seite zur Prüfung.\n\nBereitstellung und Abgabe der Übungsaufgaben\n\nVeröffentlichung: Jeden Dienstag um 13:00 Uhr\nAbgabefrist: Bis zum folgenden Dienstag um 12:00 Uhr\nBearbeitungszeitraum: Eine Woche (minus eine Stunde)\nPlattform: Moodle der Universität\n\nSowohl für die Bearbeitung als auch für die Abgabe\n\nWichtig:\n\nAchten Sie auf die pünktliche Abgabe innerhalb der angegebenen Frist.\nNach Ablauf der Frist ist die Aufgabe nicht mehr verfügbar und kann nicht mehr eingereicht werden.\nAchten sie darauf, dass mehrmaliges Einreichen derselben Aufgabe die Punktzahl mit jeder Einreichung um 10% verringert",
    "crumbs": [
      "Course Info",
      "Übungsaufgaben"
    ]
  },
  {
    "objectID": "course-info/website.html",
    "href": "course-info/website.html",
    "title": "Diese Webseiten",
    "section": "",
    "text": "Diese Webseiten\nDiese Website enthält alle Informationen, die für unseren Kurs Einführung in die Modellierung Physikalischer Prozesse erforderlich sind. Sie werden hier jede Woche eine neue Vorlesung und eine neue Aufgabe finden. Die Vorlesungshefte werden von Videos begleitet, die den Inhalt der Vorlesung auf Englisch erklären, aber Sie können auch mit dem Lesen auskommen. Die Vorlesungen in Person, werden auf Deutsch stattfinden. Von diesen Webseiten aus werden Sie zu verschiedenen Ressourcen geführt, die Sie nutzen können, um das Programmieren in Python zu lernen. Dabei werden wir einige großartige Tools aus dem Internet nutzen, wie\n\nGoogle Colab Dienst, um auch Jupyter Notebooks (https://colab.research.google.com) zu hosten. Das Google Colab-Projekt bietet eine nützliche Umgebung zur gemeinsamen Nutzung von Notebooks.\n\n\n\ngoogle colab screen\n\n\nWenn Sie die folgende Website besuchen, werden Sie an mehreren Stellen das folgende Symbol sehen.\n![Substitution Name1]\nDieses Symbol zeigt an, dass diese Webseite auf einem Jupyter Notebook basiert. Anstatt nur die Website zu betrachten, können Sie auf das Symbol klicken und der Google Colab-Dienst wird geöffnet, damit Sie das Notizbuch interaktiv nutzen können. Google Colab öffnet sich viel schneller als myBinder, aber die Notizbücher sind für die Arbeit mit myBinder gemacht und nicht alle Funktionen funktionieren mit Colab. Ich arbeite jedoch an der Kompatibilität.\nGitHub and GitHub Pages Dienst zum Hosting von Websites (https://github.com). GitHub ist ein großartiger Ort, um Ihre kollaborativen Coding-Projekte einschließlich Versionskontrolle zu hosten. In der oberen rechten Ecke finden Sie auch einen Link zum GitHub-Repository, in dem die Notebooks gehostet werden.\n\n\n\ngithub screen\n\n\nAnaconda Jupyter package für Notebooks auf dem eigenen Computer (https://www.anaconda.com/distribution/). Das Paket anaconda stellt Ihnen die Jupyter Notebook-Umgebung einschließlich Python zur Verfügung. Wenn Sie Jupyter zu Hause ohne Online-Zugang verwenden möchten, ist dies ein gutes Paket zur Installation.\n\n\n\nanaconda screen"
  },
  {
    "objectID": "course-info/exam.html",
    "href": "course-info/exam.html",
    "title": "Prüfung",
    "section": "",
    "text": "Die Prüfungsleistung in diesem Modul ist eine Portfolio-Prüfung und besteht aus zwei Portfolio-Teilen:\n\nÜbungsaufgaben:\n\n6 Serien von Aufgaben, die nicht benotet werden\nMindestens 50% der Gesamtpunktzahl aller Übungsaufgaben muss erreicht werden\n\nZwei Tests:\n\nJeder Test dauert 45 Minuten\nFinden in Person während zwei Übungsseminare statt\nDie Tests werden vorher angekündigt\nDie Punkte beider Tests werden addiert und ergeben eine Gesamtnote\n\n\nWichtige Hinweise: - Beide Portfolio-Teile (Übungsaufgaben und Tests) müssen bestanden werden, um das Modul erfolgreich abzuschließen. - Die Gesamtnote der Tests entspricht der Abschlussnote des Moduls.",
    "crumbs": [
      "Course Info",
      "Prüfungen"
    ]
  },
  {
    "objectID": "course-info/exam.html#erstteilnehmer",
    "href": "course-info/exam.html#erstteilnehmer",
    "title": "Prüfung",
    "section": "",
    "text": "Die Prüfungsleistung in diesem Modul ist eine Portfolio-Prüfung und besteht aus zwei Portfolio-Teilen:\n\nÜbungsaufgaben:\n\n6 Serien von Aufgaben, die nicht benotet werden\nMindestens 50% der Gesamtpunktzahl aller Übungsaufgaben muss erreicht werden\n\nZwei Tests:\n\nJeder Test dauert 45 Minuten\nFinden in Person während zwei Übungsseminare statt\nDie Tests werden vorher angekündigt\nDie Punkte beider Tests werden addiert und ergeben eine Gesamtnote\n\n\nWichtige Hinweise: - Beide Portfolio-Teile (Übungsaufgaben und Tests) müssen bestanden werden, um das Modul erfolgreich abzuschließen. - Die Gesamtnote der Tests entspricht der Abschlussnote des Moduls.",
    "crumbs": [
      "Course Info",
      "Prüfungen"
    ]
  },
  {
    "objectID": "course-info/exam.html#wiederholer",
    "href": "course-info/exam.html#wiederholer",
    "title": "Prüfung",
    "section": "Wiederholer",
    "text": "Wiederholer\nFür Studierende, die das Modul bereits im WS 2023/24 belegt haben und nun wiederholen:\n\nÜbungsaufgaben:\n\nWenn Sie im WS 2023/24 ≥50% erreicht haben: Nur Projektabgabe erforderlich\nWenn Sie im WS 2023/24 &lt;50% erreicht haben: Übungsaufgaben und Projektabgabe erforderlich\nEine Liste der erreichten Übungspunkte wird im internen Bereich der MONA Webseite veröffentlicht\n\nEinschreibung:\n\nErneute Moduleinschreibung nicht notwendig\nFür Moodle-Zugang: Kontaktieren Sie Andrea Kramer per Uni-E-Mail\n\nProjektabgabe für Wiederholer:\n\nFrist: 12.03.2025, 13:00 Uhr\nSpätere Abgaben werden nicht berücksichtigt",
    "crumbs": [
      "Course Info",
      "Prüfungen"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EMPP 2024",
    "section": "",
    "text": "Willkommen zum Kurs Einführung in die Modellierung Physikalischer Prozesse!\nDie Programmiersprache Python ist für alle Arten von wissenschaftlichen und technischen Aufgaben nützlich. Sie können mit ihr Daten analysieren und darstellen. Sie können mit ihr auch wissenschaftliche Probleme numerisch lösen, die analytisch nur schwer oder gar nicht zu lösen sind. Python ist frei verfügbar und wurde aufgrund seines modularen Aufbaus um eine nahezu unendliche Anzahl von Modulen für verschiedene Zwecke erweitert.\nDieser Kurs soll Sie in die Programmierung mit Python einführen. Er richtet sich eher an den Anfänger, wir hoffen aber, dass er auch für Fortgeschrittene interessant ist. Wir beginnen den Kurs mit einer Einführung in die Jupyter Notebook-Umgebung, die wir während des gesamten Kurses verwenden werden. Danach werden wir eine Einführung in Python geben und Ihnen einige grundlegende Funktionen zeigen, wie z.B. das Plotten und Analysieren von Daten durch Kurvenanpassung, das Lesen und Schreiben von Dateien, was einige der Aufgaben sind, die Ihnen während Ihres Physikstudiums begegnen werden. Wir zeigen Ihnen auch einige fortgeschrittene Themen wie die Animation in Jupyter und die Simulation von physikalischen Prozessen in\n\nMechanik\nElektrostatik\nWellen\nOptik\n\nFalls am Ende des Kurses Zeit bleibt, werden wir auch einen Blick auf Verfahren des maschinellen Lernens werfen, das mittlerweile auch in der Physik zu einem wichtigen Werkzeug geworden ist.\nWir werden keine umfassende Liste von numerischen Simulationsschemata präsentieren, sondern die Beispiele nutzen, um Ihre Neugierde zu wecken. Da es leichte Unterschiede in der Syntax der verschiedenen Python-Versionen gibt, werden wir uns im Folgenden immer auf den Python 3-Standard beziehen.\nDer Kurs wird auf Deutsch gehalten werden. Die Webseiten, die Sie für den Überblick zu Python zur Verfügung gestellt bekommen, werden allerdings auf Englisch sein. Übungsaufgaben werden werden auf Deutsch gestellt.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "seminars/seminar05/mdsim.html",
    "href": "seminars/seminar05/mdsim.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "# %% Load  modules and initialize\nfrom typing_extensions import ParamSpec\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nimport matplotlib.patches as patches\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',\n                     'figure.facecolor' : 'white',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))\n\n\n# %% Load the atom class we did already in the previous seminar\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n\nclass ForceField:\n    def __init__(self):\n        self.parameters = {\n            'C': {'epsilon': 1.615, 'sigma': 1.36},\n            'H': {'epsilon': 1.0, 'sigma': 1.0 },\n            'O': {'epsilon': 1.846, 'sigma': 3.0},\n        }\n        self.box_size = None  # Will be set when initializing the simulation\n\n    def get_pair_parameters(self, type1, type2):\n        # Apply mixing rules when needed\n        eps1 = self.parameters[type1]['epsilon']\n        eps2 = self.parameters[type2]['epsilon']\n        sig1 = self.parameters[type1]['sigma']\n        sig2 = self.parameters[type2]['sigma']\n\n        # Lorentz-Berthelot mixing rules\n        epsilon = np.sqrt(eps1 * eps2)\n        sigma = (sig1 + sig2) / 2\n\n        return epsilon, sigma\n\n    def minimum_image_distance(self, pos1, pos2):\n        \"\"\"Calculate minimum image distance between two positions\"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention\n        delta = delta - self.box_size * np.round(delta / self.box_size)\n        return delta\n\n    def calculate_lj_force(self, atom1, atom2):\n        epsilon, sigma = self.get_pair_parameters(atom1.type, atom2.type)\n        r = self.minimum_image_distance(atom1.position, atom2.position)\n        r_mag = np.linalg.norm(r)\n\n        # Add cutoff distance for stability\n        if r_mag &gt; 3.5*sigma:\n            return np.zeros(2)\n\n        force_mag = 24 * epsilon * (\n            2 * (sigma/r_mag)**13\n            - (sigma/r_mag)**7\n        )\n        force = force_mag * r/r_mag\n        return force\n\n\n\n\n# %% Define the MD Simulation master controller class\n\nclass MDSimulation:\n    def __init__(self, atoms, forcefield, timestep, box_size):\n        self.atoms = atoms\n        self.forcefield = forcefield\n        self.forcefield.box_size = box_size  # Set box size in forcefield\n        self.timestep = timestep\n        self.box_size = np.array(box_size)\n        self.initial_energy = None\n        self.energy_history = []\n\n\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\n    def update_positions_and_velocities(self):\n        # First step: Update positions using current forces\n        for atom in self.atoms:\n            atom.update_position(self.timestep)\n            # Apply periodic boundary conditions\n            atom.apply_periodic_boundaries(self.box_size)\n\n        # Recalculate forces with new positions\n        self.calculate_forces()\n\n        # Second step: Update velocities using average of old and new forces\n        for atom in self.atoms:\n            atom.update_velocity(self.timestep, atom.force)\n\n\n# %% Cell 6\ndef create_grid_atoms(num_atoms, box_size, type=\"H\",mass=1.0, random_offset=0.1):\n    box_size = np.array(box_size)\n\n    # Calculate grid dimensions\n    n = int(np.ceil(np.sqrt(num_atoms)))\n    spacing = np.min(box_size) / n\n\n    atoms = []\n    for i in range(num_atoms):\n        # Calculate grid position\n        row = i // n\n        col = i % n\n\n        # Base position\n        pos = np.array([col * spacing + spacing/2,\n                       row * spacing + spacing/2])\n\n        # Add random offset\n        pos += (np.random.rand(2) - 0.5) * spacing * random_offset\n\n        # Create atom\n        atoms.append(Atom(i, type, pos, mass=mass))\n\n    return atoms\n\n\n# %% Cell 7\ndef set_temperature(atoms, target_temperature):\n    N = len(atoms)      # number of atoms\n    Nf = 2 * N         # degrees of freedom in 2D\n\n    # Calculate current kinetic energy\n    current_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\n    current_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n    print(current_temperature)\n    # Calculate scaling factor\n    scale_factor = np.sqrt(target_temperature / current_temperature)\n\n    # Scale velocities\n    for atom in atoms:\n        atom.velocity *= scale_factor\n\n\ndef initialize_velocities(atoms, temperature, seed=None):\n    if seed is not None:\n        np.random.seed(seed)\n\n    N = len(atoms)  # number of atoms\n    dim = 2         # 2D simulation\n\n    # Generate random velocities from normal distribution\n    velocities = np.random.normal(0, np.sqrt(temperature), size=(N, dim))\n\n    # Remove center of mass motion\n    total_momentum = np.sum([atom.mass * velocities[i] for i, atom in enumerate(atoms)], axis=0)\n    total_mass = np.sum([atom.mass for atom in atoms])\n    cm_velocity = total_momentum / total_mass\n\n    # Assign velocities to atoms\n    for i, atom in enumerate(atoms):\n        atom.velocity = velocities[i] - cm_velocity\n\n    # Scale velocities to exact temperature\n    set_temperature(atoms, temperature)\n\n    return atoms\n\n# %% run the simulation w\n\nbox_size = np.array([50.0, 50.0])  # Box dimensions\nnum_atoms = 200\n\nT=5\ndt = 0.01\n\n# Create atoms and set initial velocities\natoms = create_grid_atoms(num_atoms, box_size, type=\"H\",mass=1.0, random_offset=0.1)\natoms = initialize_velocities(atoms, temperature=T)\n\n\n# Create force field\nff = ForceField()\n\n\n# Create simulation with periodic boundaries\nsim = MDSimulation(atoms, ff, dt, box_size)\n\nfig, ax = plt.subplots(1,1,figsize=(6,6))\n\nfor step in range(1000):\n    clear_output(wait=True)\n    set_temperature(atoms, target_temperature=T)\n    sim.update_positions_and_velocities()\n\n\n    positions = [atom.position for atom in sim.atoms]\n    x_coords = [pos[0] for pos in positions]\n    y_coords = [pos[1] for pos in positions]\n\n    circle=patches.Circle((x_coords[0],y_coords[0]),ff.parameters[atoms[0].type][\"sigma\"],edgecolor=\"white\",fill=False)\n    ax.add_patch(circle)\n    ax.scatter(x_coords, y_coords,color=\"red\")\n    ax.set_xlim(0, box_size[0])\n    ax.set_ylim(0, box_size[1])\n    ax.axis(\"off\")\n\n    display(fig)\n\n    ax.clear()\n# %% Cell 8\n#\n\nvx=np.array([atom.velocity for atom in atoms])\n\nvx.reshape(200,2)\nplt.hist(vx[:,0],bins=20)",
    "crumbs": [
      "Seminars",
      "Seminar05",
      "MD Simulation Code"
    ]
  },
  {
    "objectID": "seminars/seminar05/mdsim.html#here-is-the-complete-code-for-the-molecular-dynamics-simulation",
    "href": "seminars/seminar05/mdsim.html#here-is-the-complete-code-for-the-molecular-dynamics-simulation",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "# %% Load  modules and initialize\nfrom typing_extensions import ParamSpec\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nimport matplotlib.patches as patches\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',\n                     'figure.facecolor' : 'white',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))\n\n\n# %% Load the atom class we did already in the previous seminar\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n\nclass ForceField:\n    def __init__(self):\n        self.parameters = {\n            'C': {'epsilon': 1.615, 'sigma': 1.36},\n            'H': {'epsilon': 1.0, 'sigma': 1.0 },\n            'O': {'epsilon': 1.846, 'sigma': 3.0},\n        }\n        self.box_size = None  # Will be set when initializing the simulation\n\n    def get_pair_parameters(self, type1, type2):\n        # Apply mixing rules when needed\n        eps1 = self.parameters[type1]['epsilon']\n        eps2 = self.parameters[type2]['epsilon']\n        sig1 = self.parameters[type1]['sigma']\n        sig2 = self.parameters[type2]['sigma']\n\n        # Lorentz-Berthelot mixing rules\n        epsilon = np.sqrt(eps1 * eps2)\n        sigma = (sig1 + sig2) / 2\n\n        return epsilon, sigma\n\n    def minimum_image_distance(self, pos1, pos2):\n        \"\"\"Calculate minimum image distance between two positions\"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention\n        delta = delta - self.box_size * np.round(delta / self.box_size)\n        return delta\n\n    def calculate_lj_force(self, atom1, atom2):\n        epsilon, sigma = self.get_pair_parameters(atom1.type, atom2.type)\n        r = self.minimum_image_distance(atom1.position, atom2.position)\n        r_mag = np.linalg.norm(r)\n\n        # Add cutoff distance for stability\n        if r_mag &gt; 3.5*sigma:\n            return np.zeros(2)\n\n        force_mag = 24 * epsilon * (\n            2 * (sigma/r_mag)**13\n            - (sigma/r_mag)**7\n        )\n        force = force_mag * r/r_mag\n        return force\n\n\n\n\n# %% Define the MD Simulation master controller class\n\nclass MDSimulation:\n    def __init__(self, atoms, forcefield, timestep, box_size):\n        self.atoms = atoms\n        self.forcefield = forcefield\n        self.forcefield.box_size = box_size  # Set box size in forcefield\n        self.timestep = timestep\n        self.box_size = np.array(box_size)\n        self.initial_energy = None\n        self.energy_history = []\n\n\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\n    def update_positions_and_velocities(self):\n        # First step: Update positions using current forces\n        for atom in self.atoms:\n            atom.update_position(self.timestep)\n            # Apply periodic boundary conditions\n            atom.apply_periodic_boundaries(self.box_size)\n\n        # Recalculate forces with new positions\n        self.calculate_forces()\n\n        # Second step: Update velocities using average of old and new forces\n        for atom in self.atoms:\n            atom.update_velocity(self.timestep, atom.force)\n\n\n# %% Cell 6\ndef create_grid_atoms(num_atoms, box_size, type=\"H\",mass=1.0, random_offset=0.1):\n    box_size = np.array(box_size)\n\n    # Calculate grid dimensions\n    n = int(np.ceil(np.sqrt(num_atoms)))\n    spacing = np.min(box_size) / n\n\n    atoms = []\n    for i in range(num_atoms):\n        # Calculate grid position\n        row = i // n\n        col = i % n\n\n        # Base position\n        pos = np.array([col * spacing + spacing/2,\n                       row * spacing + spacing/2])\n\n        # Add random offset\n        pos += (np.random.rand(2) - 0.5) * spacing * random_offset\n\n        # Create atom\n        atoms.append(Atom(i, type, pos, mass=mass))\n\n    return atoms\n\n\n# %% Cell 7\ndef set_temperature(atoms, target_temperature):\n    N = len(atoms)      # number of atoms\n    Nf = 2 * N         # degrees of freedom in 2D\n\n    # Calculate current kinetic energy\n    current_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\n    current_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n    print(current_temperature)\n    # Calculate scaling factor\n    scale_factor = np.sqrt(target_temperature / current_temperature)\n\n    # Scale velocities\n    for atom in atoms:\n        atom.velocity *= scale_factor\n\n\ndef initialize_velocities(atoms, temperature, seed=None):\n    if seed is not None:\n        np.random.seed(seed)\n\n    N = len(atoms)  # number of atoms\n    dim = 2         # 2D simulation\n\n    # Generate random velocities from normal distribution\n    velocities = np.random.normal(0, np.sqrt(temperature), size=(N, dim))\n\n    # Remove center of mass motion\n    total_momentum = np.sum([atom.mass * velocities[i] for i, atom in enumerate(atoms)], axis=0)\n    total_mass = np.sum([atom.mass for atom in atoms])\n    cm_velocity = total_momentum / total_mass\n\n    # Assign velocities to atoms\n    for i, atom in enumerate(atoms):\n        atom.velocity = velocities[i] - cm_velocity\n\n    # Scale velocities to exact temperature\n    set_temperature(atoms, temperature)\n\n    return atoms\n\n# %% run the simulation w\n\nbox_size = np.array([50.0, 50.0])  # Box dimensions\nnum_atoms = 200\n\nT=5\ndt = 0.01\n\n# Create atoms and set initial velocities\natoms = create_grid_atoms(num_atoms, box_size, type=\"H\",mass=1.0, random_offset=0.1)\natoms = initialize_velocities(atoms, temperature=T)\n\n\n# Create force field\nff = ForceField()\n\n\n# Create simulation with periodic boundaries\nsim = MDSimulation(atoms, ff, dt, box_size)\n\nfig, ax = plt.subplots(1,1,figsize=(6,6))\n\nfor step in range(1000):\n    clear_output(wait=True)\n    set_temperature(atoms, target_temperature=T)\n    sim.update_positions_and_velocities()\n\n\n    positions = [atom.position for atom in sim.atoms]\n    x_coords = [pos[0] for pos in positions]\n    y_coords = [pos[1] for pos in positions]\n\n    circle=patches.Circle((x_coords[0],y_coords[0]),ff.parameters[atoms[0].type][\"sigma\"],edgecolor=\"white\",fill=False)\n    ax.add_patch(circle)\n    ax.scatter(x_coords, y_coords,color=\"red\")\n    ax.set_xlim(0, box_size[0])\n    ax.set_ylim(0, box_size[1])\n    ax.axis(\"off\")\n\n    display(fig)\n\n    ax.clear()\n# %% Cell 8\n#\n\nvx=np.array([atom.velocity for atom in atoms])\n\nvx.reshape(200,2)\nplt.hist(vx[:,0],bins=20)",
    "crumbs": [
      "Seminars",
      "Seminar05",
      "MD Simulation Code"
    ]
  },
  {
    "objectID": "seminars/seminar02/MD Simulation.html",
    "href": "seminars/seminar02/MD Simulation.html",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "",
    "text": "Before we implement all classes, we will first visualize the particles moving in a 2D box. We will use the matplotlib library to create an animation of the particles moving in the box. We will also implement periodic boundary conditions, so that particles that leave the box on one side re-enter on the opposite side.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\n\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))"
  },
  {
    "objectID": "seminars/seminar02/MD Simulation.html#part-2",
    "href": "seminars/seminar02/MD Simulation.html#part-2",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "",
    "text": "Before we implement all classes, we will first visualize the particles moving in a 2D box. We will use the matplotlib library to create an animation of the particles moving in the box. We will also implement periodic boundary conditions, so that particles that leave the box on one side re-enter on the opposite side.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\n\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))"
  },
  {
    "objectID": "seminars/seminar02/MD Simulation.html#create-a-particle-array",
    "href": "seminars/seminar02/MD Simulation.html#create-a-particle-array",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Create a particle array",
    "text": "Create a particle array\nWe will start creating an array of particles in 2D using numpy. Out box will be of size (1,1).\n\n# number of particle per edge\nn_side =20\n\n# particle x and y coordinates\nx = np.linspace(0.05, 0.95, n_side)\ny = np.linspace(0.05, 0.95, n_side)\n\n# meshgrid of them to have points per particle\nxx, yy = np.meshgrid(x, y)\n\n# flatten the 2D array\nparticles = np.vstack([xx.ravel(), yy.ravel()]).T\n\nJust have a look at the array xx."
  },
  {
    "objectID": "seminars/seminar02/MD Simulation.html#create-particle-velocities",
    "href": "seminars/seminar02/MD Simulation.html#create-particle-velocities",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Create particle velocities",
    "text": "Create particle velocities\n\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\n\n\nvelocities.shape\n\n(400, 2)\n\n\n\nplt.figure(figsize=(5,5))\nplt.hist(velocities[:,1],density=True,bins=50)\nplt.xlabel(r\"$v_x$\")\nplt.xlabel(r\"$p(v_x)$\")\nplt.show()"
  },
  {
    "objectID": "seminars/seminar02/MD Simulation.html#do-one-step-by-hand-and-apply-the-boundary-conditions",
    "href": "seminars/seminar02/MD Simulation.html#do-one-step-by-hand-and-apply-the-boundary-conditions",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Do one step by hand and apply the boundary conditions",
    "text": "Do one step by hand and apply the boundary conditions\nWe choose perdiodic boundary conditions. To apply them, the modulo operator % is a good choice.\n\n\n# Update particle positions based on their velocities\nparticles += velocities\n\n# Apply periodic boundary conditions in x direction (wrap around at 0 and 1)\nparticles[:, 0] = particles[:, 0] % 1\nparticles[:, 1] = particles[:, 1] % 1\n\n\n6 % 2\n\n0\n\n\nWe also need to handle collisions. This requires to calculate all pairwaise distances between all atoms. This could be quite time-consuming.\n\n\n# Calculate distances between all pairs of particles\ndistances = cdist(particles, particles)\n\n# Calculate collisions using the upper triangle of the distance matrix\n# distances &lt; 2*radius gives a boolean matrix where True means collision\n# np.triu takes only the upper triangle to avoid counting collisions twice\ncollisions = np.triu(distances &lt; 2*radius , 1)\n\n\ncollisions\n\narray([[False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       ...,\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False]])\n\n\nThen we need to carry out the collision. We simplify everything assuming a central collision of masses of the same size. This allows us to swap the velocities and to remove the overlap.\n\n# Handle collisions between particles\nfor i, j in zip(*np.nonzero(collisions)):\n    # Exchange velocities between colliding particles (elastic collision)\n    velocities[i], velocities[j] = velocities[j], velocities[i].copy()\n\n    # Calculate how much particles overlap\n    overlap = 2*radius - distances[i, j]\n\n    # Calculate unit vector pointing from j to i\n    direction = particles[i] - particles[j]\n    direction /= np.linalg.norm(direction)\n\n    # Move particles apart to prevent overlap\n    particles[i] += 0.5 * overlap * direction\n    particles[j] -= 0.5 * overlap * direction\n\nThis is now carrying out the simulation loop all together handles the drawing. This is the key in this loop.\nClear the canvas for drawing\nclear_output(wait=True)\nDraw the particles\nax.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\nDisplay the figure\ndisplay(fig)\nplt.pause(0.01)\nax.clear()\n\nradius = 0.0177\nfig, ax = plt.subplots(figsize=(6,6))\n\nn_steps = 200\n\nfor _ in range(n_steps):\n    clear_output(wait=True)\n\n    # Update particle positions based on their velocities\n    particles += velocities\n    # Apply periodic boundary conditions in x direction (wrap around at 0 and 1)\n    particles[:, 0] = particles[:, 0] % 1\n    # Apply periodic boundary conditions in y direction (wrap around at 0 and 1)\n    particles[:, 1] = particles[:, 1] % 1\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    # distances &lt; 2*radius gives a boolean matrix where True means collision\n    # np.triu takes only the upper triangle to avoid counting collisions twice\n    collisions = np.triu(distances &lt; 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Exchange velocities between colliding particles (elastic collision)\n        velocities[i], velocities[j] = velocities[j], velocities[i].copy()\n\n        # Calculate how much particles overlap\n        overlap = 2*radius - distances[i, j]\n\n        # Calculate unit vector pointing from j to i\n        direction = particles[i] - particles[j]\n        direction /= np.linalg.norm(direction)\n\n        # Move particles apart to prevent overlap\n        particles[i] += 0.5 * overlap * direction\n        particles[j] -= 0.5 * overlap * direction\n\n    ax.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.axis(\"off\")\n\n    display(fig)\n    plt.pause(0.01)\n    ax.clear()"
  },
  {
    "objectID": "seminars/Assignment 1/Assignment 1.html",
    "href": "seminars/Assignment 1/Assignment 1.html",
    "title": "Assignment 1",
    "section": "",
    "text": "n=range(1,11)\nmean=sum(n)/len(n)\n\n\nx = 5\ny = 10\n\nx, y = y, x\n\n\nlength = 10\nwidth = 5\n\narea = length * width\nperimeter = 2 * (length + width)\n\n\ntemp1_in_C = 25\ntemp1_in_F = (temp1_in_C * 9/5) + 32\n\ntemp2_in_F = 86\ntemp2_in_C = (temp2_in_F - 32) * 5/9\n\n\nmy_string = \"Hello, World!\"\n\nconcatenated_string = my_string + \" How are you?\"\nsliced_string = my_string[7:12]\nupper_case_string = my_string.upper()\nlower_case_string = my_string.lower()"
  },
  {
    "objectID": "seminars/seminar03/md3.html",
    "href": "seminars/seminar03/md3.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "We define a class Atom that contains the properties of an atom. The class Atom has the following attributes:\nclass Atom:\n    dimension = 2\n\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.zeros(dimension)\n        self.mass = mass\n        self.force = np.zeros(dimension)\nThe class Atom has the following attributes:\n\nid: The unique identifier of the atom\ntype: The type of the atom (hydrogen or oxygen or …)\nposition: The position of the atom in 3D space (x, y, z)\nvelocity: The velocity of the atom in 3D space (vx, vy, vz)\nmass: The mass of the atom\nforce: The force acting on the atom in 3D space (fx, fy, fz)\n\nIn addition, we will need some information on the other atoms that are bound to the atom. We will store this information later in a list of atoms called boundto. Since we start with a monoatomic gas, we will not need this information for now. Note that position, velocity, and force are 3D vectors and we store them in numpy arrays. This is a very convenient way to handle vectors and matrices in Python.\nThe class Atom should further implement a number of functions, called methods in object-oriented programming, that allow us to interact with the atom. The following methods are implemented in the Atom class:\n\n\ndef add_force(self, force):\n    \"\"\"Add force contribution to total force on atom\"\"\"\n    self.force += force\n\n\n\ndef reset_force(self):\n    \"\"\"Reset force to zero at start of each step\"\"\"\n    self.force = np.zeros(dimension)\n\n\n\ndef update_position(self, dt):\n    \"\"\"First step of velocity Verlet: update position\"\"\"\n    self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n\n\ndef update_velocity(self, dt, new_force):\n    \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n    self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n    self.force = new_force\n\n\n\ndef apply_periodic_boundaries(self, box_size):\n        \"\"\"Apply periodic boundary conditions\"\"\"\n        self.position = self.position % box_size\n\n\n\n\n\n\nComplete Atom class\n\n\n\n\n\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n\n\n\nThis would be a good time to do something simple with the atom class. Let’s create a bunch of atoms and plot them in a 2D space.",
    "crumbs": [
      "Seminars",
      "Seminar03",
      "MD Simulation Part 3"
    ]
  },
  {
    "objectID": "seminars/seminar03/md3.html#implementations",
    "href": "seminars/seminar03/md3.html#implementations",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "We define a class Atom that contains the properties of an atom. The class Atom has the following attributes:\nclass Atom:\n    dimension = 2\n\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.zeros(dimension)\n        self.mass = mass\n        self.force = np.zeros(dimension)\nThe class Atom has the following attributes:\n\nid: The unique identifier of the atom\ntype: The type of the atom (hydrogen or oxygen or …)\nposition: The position of the atom in 3D space (x, y, z)\nvelocity: The velocity of the atom in 3D space (vx, vy, vz)\nmass: The mass of the atom\nforce: The force acting on the atom in 3D space (fx, fy, fz)\n\nIn addition, we will need some information on the other atoms that are bound to the atom. We will store this information later in a list of atoms called boundto. Since we start with a monoatomic gas, we will not need this information for now. Note that position, velocity, and force are 3D vectors and we store them in numpy arrays. This is a very convenient way to handle vectors and matrices in Python.\nThe class Atom should further implement a number of functions, called methods in object-oriented programming, that allow us to interact with the atom. The following methods are implemented in the Atom class:\n\n\ndef add_force(self, force):\n    \"\"\"Add force contribution to total force on atom\"\"\"\n    self.force += force\n\n\n\ndef reset_force(self):\n    \"\"\"Reset force to zero at start of each step\"\"\"\n    self.force = np.zeros(dimension)\n\n\n\ndef update_position(self, dt):\n    \"\"\"First step of velocity Verlet: update position\"\"\"\n    self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n\n\ndef update_velocity(self, dt, new_force):\n    \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n    self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n    self.force = new_force\n\n\n\ndef apply_periodic_boundaries(self, box_size):\n        \"\"\"Apply periodic boundary conditions\"\"\"\n        self.position = self.position % box_size\n\n\n\n\n\n\nComplete Atom class\n\n\n\n\n\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n\n\n\nThis would be a good time to do something simple with the atom class. Let’s create a bunch of atoms and plot them in a 2D space.",
    "crumbs": [
      "Seminars",
      "Seminar03",
      "MD Simulation Part 3"
    ]
  },
  {
    "objectID": "seminars/seminar04/md4.html",
    "href": "seminars/seminar04/md4.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "In the last seminar we have defined the class Atom that represents an atom in the simulation. This time, we would like to a force field to the simulation. We will use for out simulations the Lennard-Jones potential that we have had a look at initiall. We will implement this force field in a class ForceField that will contain the parameters of the force field and the methods to calculate the forces between the atoms.",
    "crumbs": [
      "Seminars",
      "Seminar04",
      "MD Simulation Part 4"
    ]
  },
  {
    "objectID": "seminars/seminar04/md4.html#the-forcefield-class",
    "href": "seminars/seminar04/md4.html#the-forcefield-class",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "The ForceField Class",
    "text": "The ForceField Class\nThe force field is a class that contains the parameters of the force field and the methods to calculate the forces between the atoms. The class ForceField has the following attributes:\n\nsigma: The parameter sigma of the Lennard-Jones potential\nepsilon: The parameter epsilon of the Lennard-Jones potential\n\nThese parameters are specific for each atom type. We will store these parameters in a dictionary where the keys are the atom types and the values are dictionaries containing the parameters sigma and epsilon. The class ForceField also contains the box size of the simulation. This is needed to apply periodic boundary conditions.\nclass ForceField:\n    def __init__(self):\n        self.parameters = {\n            'C': {'epsilon': 1.615, 'sigma': 1.36},\n            'H': {'epsilon': 1.0, 'sigma': 1.0 },\n            'O': {'epsilon': 1.846, 'sigma': 3.0},\n        }\n        self.box_size = None  # Will be set when initializing the simulation\nYou will have certainly noticed that the parameters I defined do not correspond to the real values of the Lennard-Jones potential. Remember that the values for the hydrogen atom are typically\n\n\\(\\sigma \\approx 2.38\\) Å = \\(2.38 \\times 10^{-10}\\) meters\n\\(\\epsilon \\approx 0.0167\\) kcal/mol = \\(1.16 \\times 10^{-21}\\) joules\n\nThese are all small numbers and we will use larger values to make the simulation more stable. Actually, the Lenard-Jones potential provides a natural length and energy scale for the simulation. The length scale is the parameter \\(\\sigma\\) and the energy scale is the parameter \\(\\epsilon\\). We can therefore set \\(\\sigma_{LJ}=1\\) and \\(\\epsilon_{LJ}=1\\) and scale all other parameters accordingly. This is a common practice in molecular dynamics simulations.\nDue to this rescaling energy, temperature and time units are also not the same as in the real world. We will use the following units:\n\nEnergy: \\(\\epsilon_{LJ} = \\epsilon_{H}/\\epsilon_{H} = 1\\)\nLength: \\(\\sigma_{LJ} = 1\\)\nMass: \\(m_{LJ} = 1\\)\n\nThis means now that all energies, for example, have to be scales by _{H} also the thermal energy. As thermal energy is related to temperature, then the temperature of the Lennard-Jones system\n\\[\nT_{LJ}=\\frac{k_B T}{\\epsilon_{LJ}}\n\\]\nwhich is, in the case of using the hydrogen energy scale, \\(T_{LJ}=3.571\\). for \\(T=300\\, K\\). For the time scale, we have to consider the mass of the hydrogen atom. The time scale is given by\n\\[\nt_{LJ}=\\frac{t}{\\sigma}\\sqrt{\\frac{\\epsilon}{m_{H}}}\n\\]\nThus a time unit of \\(1\\, fs\\) corresponds to \\(t_{LJ}=0.099\\). Thus using a timestep of 0.01 in reduced units would correspond to a real world timestep of just 1 fs. The table below shows the conversion factors for the different units. Simulating a Lennard-Jones system in reduced units therefore allows you to rescale to a real systems with the help of these conversion factors.\n\\[\n\\begin{array}{c|c}\n\\hline \\mathrm{r}^* & \\mathrm{r} \\sigma^{-1} \\\\\n\\hline \\mathrm{~m}^* & \\mathrm{mM}^{-1} \\\\\n\\hline \\mathrm{t}^* & \\mathrm{t} \\sigma^{-1} \\sqrt{\\epsilon / M} \\\\\n\\hline \\mathrm{~T}^* & \\mathrm{k}_B T \\epsilon^{-1} \\\\\n\\hline \\mathrm{E}^* & \\mathrm{E} \\epsilon^{-1} \\\\\n\\hline \\mathrm{~F}^* & \\mathrm{~F} \\sigma \\epsilon^{-1} \\\\\n\\hline \\mathrm{P}^* & \\mathrm{P} \\sigma^3 \\epsilon^{-1} \\\\\n\\hline \\mathrm{v}^* & \\mathrm{v} \\sqrt{M / \\epsilon} \\\\\n\\hline \\rho^* & \\mathrm{~N} \\sigma^3 V^{-1} \\\\\n\\hline\n\\end{array}\n\\]\n\nApply mixing rules when needed\n\nget_pair_parameters\nWhen we looked at the Lennard-Jones potential we realized that it reflects the pair interaction between the same atoms. However, in a molecular dynamics simulation, we have different atoms interacting with each other. We need to define the parameters of the interaction between different atoms. This is done using mixing rules. The most common mixing rule is the Lorentz-Berthelot mixing rule. The parameters of the interaction between two different atoms are calculated as follows:\ndef get_pair_parameters(self, type1, type2):\n    # Apply mixing rules when needed\n    eps1 = self.parameters[type1]['epsilon']\n    eps2 = self.parameters[type2]['epsilon']\n    sig1 = self.parameters[type1]['sigma']\n    sig2 = self.parameters[type2]['sigma']\n\n    # Lorentz-Berthelot mixing rules\n    epsilon = np.sqrt(eps1 * eps2)\n    sigma = (sig1 + sig2) / 2\n\n    return epsilon, sigma\nWe therefore introduce the method get_pair_parameters that calculates the parameters of the Lennard-Jones potential between two different atoms. The method takes the atom types as arguments and returns the parameters epsilon and sigma of the Lennard-Jones potential between these two atoms. The method applies the Lorentz-Berthelot mixing rules to calculate the parameters. The method returns the parameters epsilon and sigma of the Lennard-Jones potential between the two atoms.\n\n\n\nApply minimum image convention\n\nminimum_image_distance\nSimilarly, we already realized that using a finite box size requires to introduce boundary conditions. We decided that periodic boundary conditions are actually most convinient. However, this is introducing a new problem. When we calculate the distance between two atoms, we have to consider the minimum image distance. This means that we have to consider the distance between two atoms in the nearest image. This is done by applying the minimum image convention. The method minimum_image_distance calculates the minimum image distance between two positions. The method takes the positions of the two atoms as arguments and returns the minimum image distance between the two positions. The method applies the minimum image convention to calculate the minimum image distance.\ndef minimum_image_distance(self, pos1, pos2):\n    \"\"\"Calculate minimum image distance between two positions\"\"\"\n    delta = pos1 - pos2\n    # Apply minimum image convention\n    delta = delta - self.box_size * np.round(delta / self.box_size)\n    return delta\n\n\n\nCalculate the Lennard-Jones force between two atoms\n\ncalculate_lj_force\nFinally we can calculate the Lennard-Jones force between two atoms. The method calculate_lj_force calculates the Lennard-Jones force between two atoms. The method takes the two atoms as arguments and returns the force between the two atoms. The method calculates the Lennard-Jones force between the two atoms using the Lennard-Jones potential. The method returns the force between the two atoms.\ndef calculate_lj_force(self, atom1, atom2):\n    epsilon, sigma = self.get_pair_parameters(atom1.type, atom2.type)\n    r = self.minimum_image_distance(atom1.position, atom2.position)\n    r_mag = np.linalg.norm(r)\n\n    # Add cutoff distance for stability\n    if r_mag &gt; 2.5*sigma:\n        return np.zeros(2)\n\n    force_mag = 24 * epsilon * (\n        2 * (sigma/r_mag)**13\n        - (sigma/r_mag)**7\n    )\n    force = force_mag * r/r_mag\n    return force\nWith these parts we have now a complete force field class which we can add to our simulation code.\n\n\n\n\n\n\nComplete ForceField class\n\n\n\n\n\nclass ForceField:\n    def __init__(self):\n        self.parameters = {\n            'C': {'epsilon': 1.615, 'sigma': 1.36},\n            'H': {'epsilon': 1.0, 'sigma': 1.0 },\n            'O': {'epsilon': 1.846, 'sigma': 3.0},\n        }\n        self.box_size = None  # Will be set when initializing the simulation\n\n    def get_pair_parameters(self, type1, type2):\n        # Apply mixing rules when needed\n        eps1 = self.parameters[type1]['epsilon']\n        eps2 = self.parameters[type2]['epsilon']\n        sig1 = self.parameters[type1]['sigma']\n        sig2 = self.parameters[type2]['sigma']\n\n        # Lorentz-Berthelot mixing rules\n        epsilon = np.sqrt(eps1 * eps2)\n        sigma = (sig1 + sig2) / 2\n\n        return epsilon, sigma\n\n    def minimum_image_distance(self, pos1, pos2):\n        \"\"\"Calculate minimum image distance between two positions\"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention\n        delta = delta - self.box_size * np.round(delta / self.box_size)\n        return delta\n\n    def calculate_lj_force(self, atom1, atom2):\n        epsilon, sigma = self.get_pair_parameters(atom1.type, atom2.type)\n        r = self.minimum_image_distance(atom1.position, atom2.position)\n        r_mag = np.linalg.norm(r)\n\n        # Add cutoff distance for stability\n        if r_mag &gt; 2.5*sigma:\n            return np.zeros(2)\n\n        force_mag = 24 * epsilon * (\n            2 * (sigma/r_mag)**13\n            - (sigma/r_mag)**7\n        )\n        force = force_mag * r/r_mag\n        return force",
    "crumbs": [
      "Seminars",
      "Seminar04",
      "MD Simulation Part 4"
    ]
  },
  {
    "objectID": "seminars/seminar04/md4.html#md-simulation-class",
    "href": "seminars/seminar04/md4.html#md-simulation-class",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "MD Simulation Class",
    "text": "MD Simulation Class\nThe last thing we need to do is to implement the MD simulation class. This class will be responsible for running the simulation. It is the controller of the simulation, who coordinates everything. By keeping this in a class you may even run several simulations simultaneously. This is not the case here, but it is a good practice to keep the simulation in a class.\n\nMDSimulation class constructor\nThis is just the constructor of the MD Simulation class. It takes the atoms, the force field, the timestep, and the box size as input. It initializes the simulation with the given parameters and sets the initial energy of the system to None. It also initializes an empty list to store the energy history of the system. The latter ones are not used for the moment but could be important later.\nclass MDSimulation:\n    def __init__(self, atoms, forcefield, timestep, box_size):\n        self.atoms = atoms\n        self.forcefield = forcefield\n        self.forcefield.box_size = box_size  # Set box size in forcefield\n        self.timestep = timestep\n        self.box_size = np.array(box_size)\n        self.initial_energy = None\n        self.energy_history = []\n\n\ncalculate_forces method\nThe calculate_forces method calculates the forces between all pairs of atoms in the system. It first resets all forces on the atoms to zero. Then, it calculates the forces between all pairs of atoms using the Lennard-Jones force calculation from the force field class. The method updates the forces on the atoms accordingly. The method does not return anything.\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\n\nupdate_positions_and_velocities method\nThe update_positions_and_velocities method does exactly what its name says. It first of all updates the positions by calling the specific method of the atom. Then it is applying periodic boundary conditions. After that, it stores the current forces for the velocity update. Then it recalculates the forces with the new positions. Finally, it updates the velocities using the average of the old and new forces. The method does not return anything.\n    def update_positions_and_velocities(self):\n        # First step: Update positions using current forces\n        for atom in self.atoms:\n            atom.update_position(self.timestep)\n            # Apply periodic boundary conditions\n            atom.apply_periodic_boundaries(self.box_size)\n\n        # Store current forces for velocity update\n        old_forces = {atom.id: atom.force.copy() for atom in self.atoms}\n\n        # Recalculate forces with new positions\n        self.calculate_forces()\n\n        # Second step: Update velocities using average of old and new forces\n        for atom in self.atoms:\n            atom.update_velocity(self.timestep, atom.force)\nWith these methods, we have a complete simulation class that can run a molecular dynamics simulation for a given number of steps. The simulation class will keep track of the energy of the system at each step, which can be used to analyze the behavior of the system over time.\n\n\n\n\n\n\nComplete MDSimulation class\n\n\n\n\n\n\nclass MDSimulation:\n    def __init__(self, atoms, forcefield, timestep, box_size):\n        self.atoms = atoms\n        self.forcefield = forcefield\n        self.forcefield.box_size = box_size  # Set box size in forcefield\n        self.timestep = timestep\n        self.box_size = np.array(box_size)\n        self.initial_energy = None\n        self.energy_history = []\n\n\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\n    def update_positions_and_velocities(self):\n        # First step: Update positions using current forces\n        for atom in self.atoms:\n            atom.update_position(self.timestep)\n            # Apply periodic boundary conditions\n            atom.apply_periodic_boundaries(self.box_size)\n\n        # Store current forces for velocity update\n        old_forces = {atom.id: atom.force.copy() for atom in self.atoms}\n\n        # Recalculate forces with new positions\n        self.calculate_forces()\n\n        # Second step: Update velocities using average of old and new forces\n        for atom in self.atoms:\n            atom.update_velocity(self.timestep, atom.force)\n\n\n\n\nNow we have the atom class, the force field class, and the simulation class. We can use these classes to run a molecular dynamics simulation of a simple Lennard-Jones system. In the next seminar, we still have to find a way to\n\ninitialize the positions of the atoms in an appropriate way\nto provide them with a velocity distribution that matches the temperature of the system\nto run the simulation and keep the temperature constant\nto trace the energy in the system over time",
    "crumbs": [
      "Seminars",
      "Seminar04",
      "MD Simulation Part 4"
    ]
  },
  {
    "objectID": "seminars/seminar04/Report/Figures/Figure1/Figure1.html",
    "href": "seminars/seminar04/Report/Figures/Figure1/Figure1.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "import matplotlib as mpl\nimport matplotlib.font_manager as font_manager\nfrom IPython.core.display import HTML\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom directory_tree import display_tree\n\n\nplt.rcParams.update({'font.size': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 11,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',}) \n\n%config InlineBackend.figure_format = 'retina'\n\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))\n\n\nplt.figure(figsize=get_size(7,5),dpi=150)\nx=np.linspace(0,np.pi*4,200)\nplt.plot(x,np.sin(x)*np.cos(2*x),color='r')\nplt.xlabel(r\"angle $\\theta$ in [rad]\")\nplt.ylabel(r\"$\\sin(\\theta)$\")\nplt.savefig(\"../figure1.pdf\",bbox_inches = 'tight')\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/01-seminar01.html",
    "href": "seminars/seminar01/01-seminar01.html",
    "title": "Seminar 1",
    "section": "",
    "text": "Calculate the average of all of the integers from 1 to 10.\n\n\n\n\n\n\n\nuse the sum() and len() functions\nn = range(1, 11)\n\n\n1n = range(1, 11)\n2sum(n)/len(n)\n\n1\n\ncreate the range of numbers from 1 to 10.\n\n2\n\ncalculate the sum of the numbers and divide by the number of elements in the list."
  },
  {
    "objectID": "seminars/seminar01/mdX.html",
    "href": "seminars/seminar01/mdX.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "The Lennard-Jones potential describes the interaction between two atoms:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nThe corresponding force:\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere: - \\(\\epsilon\\) is the depth of the potential well - \\(\\sigma\\) is the distance at which the potential is zero - \\(r\\) is the distance between particles\n\n\n\nimport numpy as np\n\ndef lennard_jones_force(pos1, pos2, epsilon=1.0, sigma=1.0):\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n\n    # Force magnitude\n    force_mag = 24 * epsilon * (2 * (sigma/r)**12 - (sigma/r)**6) / r\n\n    # Force vector\n    force_vec = force_mag * r_vec / r\n\n    return force_vec"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#simple-atomic-system-with-lennard-jones-potential",
    "href": "seminars/seminar01/mdX.html#simple-atomic-system-with-lennard-jones-potential",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "The Lennard-Jones potential describes the interaction between two atoms:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nThe corresponding force:\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere: - \\(\\epsilon\\) is the depth of the potential well - \\(\\sigma\\) is the distance at which the potential is zero - \\(r\\) is the distance between particles\n\n\n\nimport numpy as np\n\ndef lennard_jones_force(pos1, pos2, epsilon=1.0, sigma=1.0):\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n\n    # Force magnitude\n    force_mag = 24 * epsilon * (2 * (sigma/r)**12 - (sigma/r)**6) / r\n\n    # Force vector\n    force_vec = force_mag * r_vec / r\n\n    return force_vec"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#boundary-conditions",
    "href": "seminars/seminar01/mdX.html#boundary-conditions",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "2. Boundary Conditions",
    "text": "2. Boundary Conditions\n\n2.1 Periodic Boundary Conditions (PBC)\nParticles that exit one side of the box re-enter from the opposite side.\ndef apply_periodic_bc(positions, box_length):\n    return positions - box_length * np.floor(positions/box_length)\n\ndef minimum_image_distance(pos1, pos2, box_length):\n    dr = pos2 - pos1\n    dr = dr - box_length * np.round(dr/box_length)\n    return dr\n\n\n2.2 Reflective Boundaries\nParticles bounce off the walls:\ndef apply_reflective_bc(positions, velocities, box_length):\n    for i in range(len(positions)):\n        for dim in range(3):\n            if positions[i,dim] &lt; 0:\n                positions[i,dim] = -positions[i,dim]\n                velocities[i,dim] = -velocities[i,dim]\n            elif positions[i,dim] &gt; box_length:\n                positions[i,dim] = 2*box_length - positions[i,dim]\n                velocities[i,dim] = -velocities[i,dim]\n    return positions, velocities"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#basic-simulation-loop",
    "href": "seminars/seminar01/mdX.html#basic-simulation-loop",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "3. Basic Simulation Loop",
    "text": "3. Basic Simulation Loop\n\n3.1 Initial Implementation with Just LJ Forces\nclass MDSimulation:\n    def __init__(self, positions, velocities, mass, box_length, dt):\n        self.positions = positions\n        self.velocities = velocities\n        self.mass = mass\n        self.box_length = box_length\n        self.dt = dt\n\n    def calculate_forces(self):\n        n_particles = len(self.positions)\n        forces = np.zeros_like(self.positions)\n\n        for i in range(n_particles):\n            for j in range(i+1, n_particles):\n                r_ij = minimum_image_distance(\n                    self.positions[i],\n                    self.positions[j],\n                    self.box_length\n                )\n                f_ij = lennard_jones_force(np.zeros(3), r_ij)\n                forces[i] += f_ij\n                forces[j] -= f_ij  # Newton's third law\n\n        return forces\n\n    def velocity_verlet_step(self):\n        # Calculate initial forces\n        forces = self.calculate_forces()\n\n        # Update positions\n        self.positions += self.velocities * self.dt + \\\n                         0.5 * forces / self.mass * self.dt**2\n\n        # Apply boundary conditions\n        self.positions = apply_periodic_bc(self.positions, self.box_length)\n\n        # Calculate new forces\n        new_forces = self.calculate_forces()\n\n        # Update velocities\n        self.velocities += 0.5 * (forces + new_forces) / self.mass * self.dt"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#adding-molecular-forces",
    "href": "seminars/seminar01/mdX.html#adding-molecular-forces",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "4. Adding Molecular Forces",
    "text": "4. Adding Molecular Forces\n\n4.1 Bond Forces\nAdding harmonic bond potential:\n\\[V_{bond}(r) = \\frac{k}{2}(r - r_0)^2\\]\ndef bond_force(pos1, pos2, k_bond, r0):\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n    force_mag = -k_bond * (r - r0)\n    return force_mag * r_vec / r\n\n\n4.2 Angle Forces\nThree-body angle potential:\n\\[V_{angle}(\\theta) = \\frac{k_\\theta}{2}(\\theta - \\theta_0)^2\\]\ndef angle_force(pos1, pos2, pos3, k_angle, theta0):\n    # Calculate vectors\n    v1 = pos1 - pos2\n    v2 = pos3 - pos2\n\n    # Calculate angle\n    cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    theta = np.arccos(np.clip(cos_theta, -1.0, 1.0))\n\n    # Calculate forces (simplified version)\n    force_magnitude = -k_angle * (theta - theta0)\n\n    return force_magnitude * v1, -force_magnitude * v2\n\n\n4.3 Enhanced Simulation Class\nclass MolecularMDSimulation(MDSimulation):\n    def __init__(self, *args, bonds=None, angles=None):\n        super().__init__(*args)\n        self.bonds = bonds or []  # [(i, j, k, r0), ...]\n        self.angles = angles or []  # [(i, j, k, k_angle, theta0), ...]\n\n    def calculate_forces(self):\n        # Start with non-bonded forces\n        forces = super().calculate_forces()\n\n        # Add bond forces\n        for bond in self.bonds:\n            i, j, k_bond, r0 = bond\n            f_ij = bond_force(\n                self.positions[i],\n                self.positions[j],\n                k_bond, r0\n            )\n            forces[i] += f_ij\n            forces[j] -= f_ij\n\n        # Add angle forces\n        for angle in self.angles:\n            i, j, k, k_angle, theta0 = angle\n            f_i, f_k = angle_force(\n                self.positions[i],\n                self.positions[j],\n                self.positions[k],\n                k_angle, theta0\n            )\n            forces[i] += f_i\n            forces[k] += f_k\n            forces[j] -= (f_i + f_k)\n\n        return forces"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#example-usage",
    "href": "seminars/seminar01/mdX.html#example-usage",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "5. Example Usage",
    "text": "5. Example Usage\n# Initialize system\nn_particles = 100\nbox_length = 10.0\npositions = np.random.rand(n_particles, 3) * box_length\nvelocities = np.zeros((n_particles, 3))\nmass = 1.0\ndt = 0.001\n\n# Create simulation\nsim = MolecularMDSimulation(\n    positions, velocities, mass, box_length, dt,\n    bonds=[(0, 1, 1000.0, 1.0)],  # Example bond\n    angles=[(0, 1, 2, 100.0, np.pi)]  # Example angle\n)\n\n# Run simulation\nn_steps = 1000\nfor step in range(n_steps):\n    sim.velocity_verlet_step()\nHere’s a suggested basic structure:\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id          # unique identifier\n        self.type = atom_type      # e.g., 'H', 'C', 'O'\n        self.position = position   # numpy array [x, y, z]\n        self.velocity = velocity if velocity is not None else np.zeros(3)\n        self.mass = mass\n        self.force = np.zeros(3)   # current force on atom\n\n        # Optional attributes that might be useful later:\n        self.bonded_atoms = []     # list of atoms this atom is bonded to\n        self.charges = 0.0         # for electrostatic interactions\nThen you can later create classes for: 1. Bond (connects two Atom objects)\nclass Bond:\n    def __init__(self, atom1, atom2, k, r0):\n        self.atom1 = atom1\n        self.atom2 = atom2\n        self.k = k      # force constant\n        self.r0 = r0    # equilibrium distance\n\nAngle (three Atom objects)\n\nclass Angle:\n    def __init__(self, atom1, atom2, atom3, k, theta0):\n        self.atoms = [atom1, atom2, atom3]\n        self.k = k          # force constant\n        self.theta0 = theta0  # equilibrium angle\n\nDihedral (four Atom objects)\n\nThis modular approach makes it easier to: - Add features incrementally - Debug each interaction type separately - Keep track of connectivity - Calculate forces systematically\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.zeros(3)\n        self.mass = mass\n        self.force = np.zeros(3)\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(3)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\nclass ForceField:\n    def __init__(self, sigma, epsilon):\n        self.sigma = sigma\n        self.epsilon = epsilon\n\n    def calculate_lj_force(self, atom1, atom2):\n        \"\"\"Calculate LJ force between two atoms\"\"\"\n        r = atom1.position - atom2.position\n        r_mag = np.linalg.norm(r)\n        # LJ force calculation\n        force = 24 * self.epsilon * (2 * (self.sigma/r_mag)**12\n                                   - (self.sigma/r_mag)**6) * r/r_mag**2\n        return force\n\nclass MDSimulation:\n    def __init__(self, atoms, forcefield):\n        self.atoms = atoms\n        self.forcefield = forcefield\n\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\nNew lecture\nclass Atom: def init(self, atom_id, atom_type, position, velocity=None, mass=None): self.id = atom_id self.type = atom_type # e.g., ‘A’, ‘B’, etc. self.position = position self.velocity = velocity if velocity is not None else np.zeros(2) self.mass = mass self.force = np.zeros(2)\nclass ForceField: def init(self): # Dictionary to store interaction parameters between atom types self.pair_parameters = {}\ndef add_pair_parameters(self, type1, type2, epsilon, sigma):\n    \"\"\"Add interaction parameters for a pair of atom types\"\"\"\n    # Store parameters symmetrically\n    key = tuple(sorted([type1, type2]))\n    self.pair_parameters[key] = {'epsilon': epsilon, 'sigma': sigma}\n\ndef get_pair_parameters(self, type1, type2):\n    \"\"\"Get interaction parameters for a pair of atom types\"\"\"\n    key = tuple(sorted([type1, type2]))\n    if key not in self.pair_parameters:\n        raise ValueError(f\"No parameters defined for atom types {type1} and {type2}\")\n    return self.pair_parameters[key]\n\ndef calculate_lj_force(self, atom1, atom2, r_vec, r_mag):\n    \"\"\"Calculate LJ force with type-specific parameters\"\"\"\n    params = self.get_pair_parameters(atom1.type, atom2.type)\n    epsilon = params['epsilon']\n    sigma = params['sigma']\n\n    force_mag = 24.0 * epsilon * (2.0 * (sigma/r_mag)**13\n                                - (sigma/r_mag)**7)\n    return force_mag * r_vec / r_mag\n\n\n\n\n    def setup_simulation():\n        # Create force field and add parameters\n        ff = ForceField()\n\n        # Add parameters for different combinations\n        ff.add_pair_parameters('A', 'A', epsilon=1.0, sigma=1.0)  # A-A interaction\n        ff.add_pair_parameters('B', 'B', epsilon=0.5, sigma=1.2)  # B-B interaction\n        ff.add_pair_parameters('A', 'B', epsilon=0.7, sigma=1.1)  # A-B interaction\n\n        # Create atoms of different types\n        atoms = [\n            Atom(0, 'A', np.array([1.0, 1.0]), mass=1.0),\n            Atom(1, 'A', np.array([2.0, 2.0]), mass=1.0),\n            Atom(2, 'B', np.array([3.0, 3.0]), mass=1.5),\n            Atom(3, 'B', np.array([4.0, 4.0]), mass=1.5)\n        ]\n\n        return ff, atoms"
  },
  {
    "objectID": "seminars/seminar01/md1.html",
    "href": "seminars/seminar01/md1.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Real molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation.",
    "crumbs": [
      "Seminars",
      "Seminar01",
      "MD Simulations Part 1"
    ]
  },
  {
    "objectID": "seminars/seminar01/md1.html#molecular-dynamics-simulations",
    "href": "seminars/seminar01/md1.html#molecular-dynamics-simulations",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Real molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation.",
    "crumbs": [
      "Seminars",
      "Seminar01",
      "MD Simulations Part 1"
    ]
  },
  {
    "objectID": "seminars/seminar01/md1.html#basic-physical-concepts",
    "href": "seminars/seminar01/md1.html#basic-physical-concepts",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "Basic Physical Concepts",
    "text": "Basic Physical Concepts\n\nNewton’s Equations of Motion\nThe motion of particles in a molecular dynamics simulation is governed by Newton’s equations of motion:\n\\[m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i\\]\nwhere:\n\n\\(m_i\\) is the mass of particle \\(i\\)\n\\(\\vec{r}_i\\) is the position of particle \\(i\\)\n\\(\\vec{F}_i\\) is the force acting on particle \\(i\\)\n\nThe force acting on a particle is the sum of all forces acting on it:\n\\[\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}\\]\nwhere \\(\\vec{F}_{ij}\\) is the force acting on particle \\(i\\) due to particle \\(j\\).\n\n\nPotential Energy Functions and Forces\nThe force \\(\\vec{F}_{ij}\\) is usually derived from a potential energy function and may result from a variety of interactions, such as:\n\nBonded interactions\n\nbond stretching \nbond angle bending \ntorsional interactions \n\nNon-bonded interactions\n\nelectrostatic interactions\nvan der Waals interactions\n\nExternal forces\n\nWe will implement some of them but not all of them.\n\nLennard-Jones Potential\nThe most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nand\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere:\n\n\\(\\epsilon\\) is the depth of the potential well\n\\(\\sigma\\) is the distance at which the potential is zero\n\\(r\\) is the distance between particles\n\nThe Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid.\n\n\nCode\ndef lennard_jones(r, epsilon=1, sigma=1):\n    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n\nr = np.linspace(0.8, 3, 1000)\nV = lennard_jones(r)\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(r, V, 'b-', linewidth=2)\nplt.grid(True)\nplt.xlabel('r/σ')\nplt.ylabel('V/ε')\nplt.title('Lennard-Jones Potential')\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.ylim(-1.5, 3)\nplt.show()\n\n\n\n\n\n\n\n\n\nThe figure above shows the Lenard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance \\(r = \\sigma\\) and has a minimum at \\(r = 2^{1/6}\\sigma\\). The potential energy is positive for \\(r &lt; \\sigma\\) and negative for \\(r &gt; \\sigma\\).\n\n\n\n\n\n\nValues for atomic hydrogen\n\n\n\nFor atomic hydrogen (H), typical Lennard-Jones parameters are:\n\n\\(\\sigma \\approx 2.38\\) Å = \\(2.38 \\times 10^{-10}\\) meters\n\\(\\epsilon \\approx 0.0167\\) kcal/mol = \\(1.16 \\times 10^{-21}\\) joules\n\n\n\nLater, if we manage to advance to some more complicated systems, we may want to introduce:\n\nforce in bonds between two atoms\nforce in bond angles between three atoms\nforce in dihedral angles between four atoms\n\nBut for now, we will stick to the Lennard-Jones potential.",
    "crumbs": [
      "Seminars",
      "Seminar01",
      "MD Simulations Part 1"
    ]
  },
  {
    "objectID": "seminars/seminar01/md1.html#integrating-newtons-euqation-of-motion",
    "href": "seminars/seminar01/md1.html#integrating-newtons-euqation-of-motion",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "Integrating Newtons Euqation of Motion",
    "text": "Integrating Newtons Euqation of Motion\nWhen we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n\nEuler Method\nTo obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function \\(f(x)\\) around a point \\(x_0\\) is providing an approximation of the function in the vicinity of \\(x_0\\). It is given by:\n\\[f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots\\]\nwhere \\(f'(x_0)\\) is the first derivative of \\(f(x)\\) at \\(x_0\\), \\(f''(x_0)\\) is the second derivative of \\(f(x)\\) at \\(x_0\\), and so on. We can demonstrate that by expanding a sine function around \\(x_0 = 0\\):\n\\[\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots\\]\nPlotting this yields:\n\n\nCode\nx = np.linspace(-2*np.pi, 2*np.pi, 1000)\ny = np.sin(x)\ny_taylor = x - 1/6*x**3\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\nplt.plot(x, y_taylor, 'r--', label='Taylor expansion', linewidth=2)\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.xlim(-2,2)\nplt.ylim(-2,2)\nplt.title('Taylor Expansion of sin(x)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nThe expansion is therefore a good approximation in a region close to \\(x_0\\).\n\n\nVelocity Verlet Algorithm\nThe velocity Verlet algorithm is a second-order algorithm that is more accurate than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors\n\\[\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)\\]\nThe higher order terms in the Taylor expansion are neglected, which results in an error of order \\(\\Delta t^3\\). As compared to that the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n\\[\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)\\]\nand is therefore only first order accurate with an error of order \\(\\Delta t^2\\).\nThe velocity Verlet algorithm consists of three steps:\n\nUpdate positions: \\(\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2\\)\nCalculate new forces: \\(\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))\\)\nUpdate velocities: \\(\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t\\)\n\nwhere: - \\(\\mathbf{r}\\) is the position vector - \\(\\mathbf{v}\\) is the velocity vector - \\(\\mathbf{F}\\) is the force vector - \\(m\\) is the mass - \\(\\Delta t\\) is the timestep\n\n\nSimple Integration Example: Free Fall\nLet’s start and try to integrate the equation of motion for a particle in free fall with the help of the Velocity Verlet algorithm. The only force acting on the particle is gravity. The equation of motion is:\nNewton’s equation of motion: \\(\\mathbf{F} = m\\mathbf{a}\\)\nFor gravity: \\(\\mathbf{F} = -mg\\hat{\\mathbf{y}}\\)\nTherefore: \\(\\ddot{y} = -g\\)\nThe analytical solution is:\n\nPosition: \\(y(t) = y_0 + v_0t - \\frac{1}{2}gt^2\\)\nVelocity: \\(v(t) = v_0 - gt\\)\n\n\n\nCode\n# Parameters\n\ng = 9.81  # m/s^2\ndt = 0.01  # time step\nt_max = 2.0  # total simulation time\nsteps = int(t_max/dt)\n\n# Initial conditions\ny0 = 20.0  # initial height\nv0 = 0.0   # initial velocity\n\n\n# Arrays to store results\nt = np.zeros(steps)\ny = np.zeros(steps)\nv = np.zeros(steps)\na = np.zeros(steps)\n\n# Initial values\ny[0] = y0\nv[0] = v0\na[0] = -g\n\n# Velocity Verlet integration\nfor i in range(1, steps):\n    t[i] = i * dt\n    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n    a_new = -g                                          # new acceleration (assuming constant gravity)\n    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt         # update velocity\n    a[i] = a_new                                        # store new acceleration\n\ny_analytical = y0 + v0*t - 0.5*g*t**2\nplt.figure(figsize=get_size(8, 6), dpi=150)\nplt.plot(t, y)\nplt.plot(t, y_analytical, 'r--')\n\nplt.xlabel('Time (s)')\nplt.ylabel('Height (m)')\nplt.title('Free Fall Motion')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Seminars",
      "Seminar01",
      "MD Simulations Part 1"
    ]
  },
  {
    "objectID": "lectures/lecture04/04-plotting.html",
    "href": "lectures/lecture04/04-plotting.html",
    "title": "Plotting",
    "section": "",
    "text": "Data visualization through plotting is a crucial tool for analyzing and interpreting scientific data and theoretical predictions. While plotting capabilities are not built into Python’s core, they are available through various external library modules. Matplotlib is widely recognized as the de facto standard for plotting in Python. However, several other powerful plotting libraries exist, including PlotLy, Seaborn, and Bokeh, each offering unique features and capabilities for data visualization.\nAs Matplotlib is an external library (actually a collection of libraries), it must be imported into any script that uses it. While Matplotlib relies heavily on NumPy, importing NumPy separately is not always necessary for basic plotting. However, for most scientific applications, you’ll likely use both. To create 2D plots, you typically start by importing Matplotlib’s pyplot module:\nThis import introduces the implicit interface of pyplot for creating figures and plots. Matplotlib offers two main interfaces:\nWe will use most of the the the pyplot interface as in the examples below. The section Additional Plotting will refer to the explicit programming of figures.\nWe can set some of the parameters for the appearance of graphs globally. In case you still want to modify a part of it, you can set individual parameters later during plotting. The command used here is the\nfunction, which takes a dictionary with the specific parameters as key.",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture04/04-plotting.html#simple-plotting",
    "href": "lectures/lecture04/04-plotting.html#simple-plotting",
    "title": "Plotting",
    "section": "Simple Plotting",
    "text": "Simple Plotting\nMatplotlib offers multiple levels of functionality for creating plots. Throughout this section, we’ll primarily focus on using commands that leverage default settings. This approach simplifies the process, as Matplotlib automatically handles much of the graph layout. These high-level commands are ideal for quickly creating effective visualizations without delving into intricate details. At the end of this section, we’ll briefly touch upon more advanced techniques that provide greater control over plot elements and layout.\n\nAnatomy of a Line Plot\nTo create a basic line plot, use the following command:\nplt.plot(x, y)\nBy default, this generates a line plot. However, you can customize the appearance by adjusting various parameters within the plot() function. For instance, you can modify it to resemble a scatter plot by changing certain arguments. The versatility of this command allows for a range of visual representations beyond simple line plots.\nLet’s create a simple line plot of the sine function over the interval [0, 4π]. We’ll use NumPy to generate the x-values and calculate the corresponding y-values. The following code snippet demonstrates this process:\n1x = np.linspace(0, 4.*np.pi, 100)\n2y = np.sin(x)\n\n3plt.figure(figsize=(4,3))\n4plt.plot(x, y)\n5plt.tight_layout()\n6plt.show()\n\n1\n\nCreate an array of 100 values between 0 and 4π.\n\n2\n\nCalculate the sine of each value in the array.\n\n3\n\ncreate a new figure\n\n4\n\nplot the data\n\n5\n\nautomatically adjust the layout\n\n6\n\nshow the figure\n\n\nHere is the code in a Python cell:\n\n\n\n\n\n\nTry to change the values of the x and y arrays and see how the plot changes.\n\n\n\n\n\n\nWhy use plt.tight_layout()\n\n\n\n\n\nplt.tight_layout() is a very useful function in Matplotlib that automatically adjusts the spacing between plot elements to prevent overlapping and ensure that all elements fit within the figure area. Here’s what it does:\n\nPadding Adjustment: It adjusts the padding between and around subplots to prevent overlapping of axis labels, titles, and other elements.\nSubplot Spacing: It optimizes the space between multiple subplots in a figure.\nText Accommodation: It ensures that all text elements (like titles, labels, and legends) fit within the figure without being cut off.\nMargin Adjustment: It adjusts the margins around the entire figure to make sure everything fits neatly.\nAutomatic Resizing: If necessary, it can slightly resize subplot areas to accommodate all elements.\nLegend Positioning: It takes into account the presence and position of legends when adjusting layouts.\n\nKey benefits of using plt.tight_layout():\n\nIt saves time in manual adjustment of plot elements.\nIt helps create more professional-looking and readable plots.\nIt’s particularly useful when creating figures with multiple subplots or when saving figures to files.\n\nYou typically call plt.tight_layout() just before plt.show() or plt.savefig(). For example:\nplt.figure()\n# ... (your plotting code here)\nplt.tight_layout()\nplt.show()\n\n\n\n\nAxis Labels\nTo enhance the clarity and interpretability of our plots, it’s crucial to provide context through proper labeling. Let’s add descriptive axis labels to our diagram, a practice that significantly improves the readability and comprehension of the data being presented.\nplt.xlabel('x-label')\nplt.ylabel('y-label')\n\n\n\n\n\n\n\n\nLegends\nplt.plot(..., label=r'$\\sin(x)$')\nplt.legend(loc='lower left')\n\n\n\n\n\n\n\n\nPlots with error bars\nWhen plotting experimental data it is customary to include error bars that indicate graphically the degree of uncertainty that exists in the measurement of each data point. The MatPlotLib function errorbar plots data with error bars attached. It can be used in a way that either replaces or augments the plot function. Both vertical and horizontal error bars can be displayed. The figure below illustrates the use of error bars.\n\n\n\n\n\n\n\n\nSaving figures\nTo save a figure to a file we can use the savefig method in the Figure class. Matplotlib can generate high-quality output in a number formats, including PNG, JPG, EPS, SVG, PGF and PDF. For scientific papers, I recommend using PDF whenever possible. (LaTeX documents compiled with pdflatex can include PDFs using the includegraphics command). In some cases, PGF can also be good alternative.",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture04/04-plotting.html#other-plot-types",
    "href": "lectures/lecture04/04-plotting.html#other-plot-types",
    "title": "Plotting",
    "section": "Other Plot Types",
    "text": "Other Plot Types\n\nScatter plot\nIf you prefer to use symbols for plotting just use the\nplt.scatter(x,y)\ncommand of pylab. Note that the scatter command requires a x and y values and you can set the marker symbol (see an overview of the marker symbols).\n\n\n\n\n\n\n\n\nHistograms\nA very useful plotting command is also the hist command. It generates a histogram of the data provided. A histogram is a graphical representation of the distribution of numerical data. It is an estimate of the probability distribution of a continuous variable. To construct a histogram, the first step is to “bin” the range of values—that is, divide the entire range of values into a series of intervals—and then count how many values fall into each interval. The bins are usually specified as consecutive, non-overlapping intervals of a variable. The bins must be adjacent, and are often (but not required to be) of equal size.\nWhen using the histogram function, you have flexibility in how the data is grouped. If you only provide the dataset, the function will automatically determine appropriate bins. However, you can also specify custom bins by passing an array of intervals using the syntax hist(data, bins=b), where b is your custom array of bin edges. To normalize the histogram so that the total area under it equals 1, you can set the density parameter to True. It’s worth noting that the histogram function doesn’t just create a visual representation; it also returns useful information such as the count of data points in each bin and the bin edges themselves.\n\n\n\n\n\n\nPhysics Interlude- Probability density for finding an oscillating particle\n\n\n\nLet’s integrate histogram plotting with a fundamental physics concept: the simple harmonic oscillator in one dimension. This system is described by a specific equation of motion:\n\\[\\begin{equation}\n\\ddot{x}(t) = -\\omega^2 x(t)\n\\end{equation}\\]\nFor an initial elongation \\(\\Delta x\\) at \\(t=0\\), the solution is:\n\\[\\begin{equation}\nx(t) = \\Delta x \\cos(\\omega t)\n\\end{equation}\\]\nTo calculate the probability of finding the spring at a certain elongation, we need to consider the time spent at different positions. The time \\(dt\\) spent in the interval [\\(x(t)\\), \\(x(t)+dx\\)] depends on the speed:\n\\[\\begin{equation}\nv(t) = \\frac{dx}{dt} = -\\omega \\Delta x \\sin(\\omega t)\n\\end{equation}\\]\nThe probability of finding the oscillator in a certain interval is the fraction of time spent in this interval, normalized by half the oscillation period \\(T/2\\):\n\\[\\begin{equation}\n\\frac{dt}{T/2} = \\frac{1}{T/2}\\frac{dx}{v(t)} = \\frac{1}{T/2}\\frac{-dx}{\\omega \\Delta x \\sin(\\omega t)}\n\\end{equation}\\]\nGiven that \\(\\omega = 2\\pi/T\\), we can derive the probability density:\n\\[\\begin{equation}\np(x)dx = \\frac{1}{\\pi \\Delta x}\\frac{dx}{\\sqrt{1-\\left(\\frac{x(t)}{\\Delta x}\\right)^2}}\n\\end{equation}\\]\nThis probability density reveals that the spring is more likely to be found at elongations where its speed is low. This principle extends to non-equilibrium physics, where entities moving with variable speed are more likely to be found in locations where they move slowly.\nWe can visualize this using the histogram function. By evaluating the position at equidistant times using the equation of motion and creating a histogram of these positions, we can represent the probability of finding the oscillator at certain positions. When properly normalized, this histogram will reflect the theoretical probability density we derived.\n\n\n\n\n\n\n\n\n\n\nSetting plotting limits and excluding data\nIf you want to zoom in to s specific region of a plot you can set the limits of the individual axes.\n\n\n\n\n\n\n\n\nMasked arrays\nSometimes you encounter situations, when you wish to mask some of the data of your plot, because they are not showing real data as the vertical lines in the plot above. For this purpose, you can mask the data arrays in various ways to not show up. The example below uses the\nnp.ma.masked_where()\nfunction of NumPy, which takes a condition as the first argument and what should be returned if that condition is fulfilled.\n\n\n\n\n\n\nIf you look at the resulting array, you will find, that the entries have not been removed but replaced by --, so the values are not existent and thefore not plotted.\n\n\n\n\n\n\n\nLogarithmic plots\n\n\n\n\n\nData sets can span many orders of magnitude from fractional quantities much smaller than unity to values much larger than unity. In such cases it is often useful to plot the data on logarithmic axes.\n\nSemi-log plots\nFor data sets that vary exponentially in the independent variable, it is often useful to use one or more logarithmic axes. Radioactive decay of unstable nuclei, for example, exhibits an exponential decrease in the number of particles emitted from the nuclei as a function of time.\nMatPlotLib provides two functions for making semi-logarithmic plots, semilogx and semilogy, for creating plots with logarithmic x and y axes, with linear y and x axes, respectively. We illustrate their use in the program below, which made the above plots.\n\n\n\n\n\n\n\n\nLog-log plots\nMatPlotLib can also make log-log or double-logarithmic plots using the function loglog. It is useful when both the \\(x\\) and \\(y\\) data span many orders of magnitude. Data that are described by a power law \\(y=Ax^b\\), where \\(A\\) and \\(b\\) are constants, appear as straight lines when plotted on a log-log plot. Again, the loglog function works just like the plot function but with logarithmic axes.\n\n\n\n\n\n\n\n\n\n\n\n\nCombined plots\nYou can combine multiple data with the same axes by stacking multiple plots.\n\n\n\n\n\n\n\n\nArranging multiple plots\nOften you want to create two or more graphs and place them next to one another, generally because they are related to each other in some way.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnimations\n\n\n\n\n\nMatplotlib can also be used to create animations. The FuncAnimation class makes it easy to create animations by repeatedly calling a function to update the plot. The following example shows a simple pendulum animation.\n\n\n\n\n\n\n\n\n\n\n\nSimple contour plot\n\n\n\n\n\n\nPhysics Interlude\n\n\n\n\n\n\nContour and Density Plots\nA contour plots are useful tools to study two dimensional data, meaning \\(Z(X,Y)\\). A contour plots the lines of constant value of the function \\(Z\\).\n\n\nUnderstanding Wave Interference\nImagine throwing two stones into a pond. Each stone creates circular waves that spread out. When these waves meet, they create interesting patterns - this is called interference. Let’s explore this using physics and Python!\n\nWhat is a Wave?\nA wave can be described mathematically. For our example, we’ll look at spherical waves (like those in the pond). Each wave has: - An amplitude (how tall the wave is) - A wavelength (distance between wave peaks) - A frequency (how fast it oscillates)\n\n\nMathematical Description\nFor a single wave source, we can write: \\[\\begin{equation}\nU(r)=e^{-i\\,k r}\n\\end{equation}\\]\nWhere: - \\(k\\) is related to the wavelength (\\(k = 2\\pi/\\lambda\\)) - \\(r\\) is the distance from the source - We’ve simplified by ignoring how the wave gets smaller as it travels (\\(1/r\\) term)\n\n\nTwo Wave Sources\nWhen we have two wave sources (like two stones dropped in the pond): 1. Each source creates its own wave 2. The waves combine where they meet 3. The total wave is the sum of both waves\n\n\n\ninterference\n\n\nMathematically: \\[\\begin{equation}\nU_{total} = e^{-i\\,k r_1} + e^{-i\\,k r_2}\n\\end{equation}\\]\nWhere \\(r_1\\) and \\(r_2\\) are the distances from each source.\n\n\nWhat We See (Intensity)\nWhat we actually see is the intensity of the combined waves:\n\\[\\begin{equation}\n\\text{Intensity} \\propto |U_{total}|^2\n\\end{equation}\\]\nThis will show us where the waves:\n\nAdd up (bright regions - constructive interference)\nCancel out (dark regions - destructive interference)\n\nLet’s create a Python program to visualize this!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor contour plot\n\n\n\n\n\n\n\n\nImage plot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvanced Plotting - Explicit Version\n\n\n\n\n\nAdvanced Plotting - Explicit Version\nWhile we have so far largely relied on the default setting and the automatic arrangement of plots, there is also a way to precisely design your plot. Python provides the tools of object oriented programming and thus modules provide classes which can be instanced into objects. This explicit interfaces allows you to control all details without the automatisms of pyplot.\nThe figure below, which is taken from the matplotlib documentation website shows the sets of commands and the objects in the figure, the commands refer to. It is a nice reference, when creating a figure.\n\n\n\nanatomy of a figure\n\n\n\nPlots with Multiple Spines\nSometimes it is very useful to plot different quantities in the same plot with the same x-axis but with different y-axes. Here is some example, where each line plot has its own y-axis.\n\n\n\n\n\n\n\n\nInsets\nInsets are plots within plots using their own axes. We therefore need to create two axes systems, if we want to have a main plot and and inset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpine axis\n\n\n\n\n\n\n\n\nPolar plot\n\n\n\n\n\n\n\n\nText annotation\nAnnotating text in matplotlib figures can be done using the text function. It supports LaTeX formatting just like axis label texts and titles:\n\n\n\n\n\n\n\n\n3D Plotting\nMatplotlib was initially designed with only two-dimensional plotting in mind. Around the time of the 1.0 release, some three-dimensional plotting utilities were built on top of Matplotlib’s two-dimensional display, and the result is a convenient (if somewhat limited) set of tools for three-dimensional data visualization. Three-dimensional plots are enabled by importing the mplot3d toolkit, included with the main Matplotlib installation:\n\n\n\n\n\n\nOnce this submodule is imported, a three-dimensional axes can be created by passing the keyword projection=‘3d’ to any of the normal axes creation routines:\n\nProjection Scence\n\n\n\n\n\n\nWith this three-dimensional axes enabled, we can now plot a variety of three-dimensional plot types. Three-dimensional plotting is one of the functionalities that benefits immensely from viewing figures interactively rather than statically in the notebook; recall that to use interactive figures, you can use %matplotlib notebook rather than %matplotlib inline when running this code.\n\n\nLine Plotting in 3D\nfrom sets of (x, y, z) triples. In analogy with the more common two-dimensional plots discussed earlier, these can be created using the ax.plot3D and ax.scatter3D functions. The call signature for these is nearly identical to that of their two-dimensional counterparts, so you can refer to Simple Line Plots and Simple Scatter Plots for more information on controlling the output. Here we’ll plot a trigonometric spiral, along with some points drawn randomly near the line:\n\n\n\n\n\n\nNotice that by default, the scatter points have their transparency adjusted to give a sense of depth on the page. While the three-dimensional effect is sometimes difficult to see within a static image, an interactive view can lead to some nice intuition about the layout of the points. Use the scatter3D or the plot3D method to plot a random walk in 3-dimensions in your exercise.\n\n\nSurface Plotting\nA surface plot is like a wireframe plot, but each face of the wireframe is a filled polygon. Adding a colormap to the filled polygons can aid perception of the topology of the surface being visualized:",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture04/04-plotting.html#contour-and-density-plots",
    "href": "lectures/lecture04/04-plotting.html#contour-and-density-plots",
    "title": "Plotting",
    "section": "Contour and Density Plots",
    "text": "Contour and Density Plots\nA contour plots are useful tools to study two dimensional data, meaning \\(Z(X,Y)\\). A contour plots the lines of constant value of the function \\(Z\\).",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture04/04-plotting.html#understanding-wave-interference",
    "href": "lectures/lecture04/04-plotting.html#understanding-wave-interference",
    "title": "Plotting",
    "section": "Understanding Wave Interference",
    "text": "Understanding Wave Interference\nImagine throwing two stones into a pond. Each stone creates circular waves that spread out. When these waves meet, they create interesting patterns - this is called interference. Let’s explore this using physics and Python!\n\nWhat is a Wave?\nA wave can be described mathematically. For our example, we’ll look at spherical waves (like those in the pond). Each wave has: - An amplitude (how tall the wave is) - A wavelength (distance between wave peaks) - A frequency (how fast it oscillates)\n\n\nMathematical Description\nFor a single wave source, we can write: \\[\\begin{equation}\nU(r)=e^{-i\\,k r}\n\\end{equation}\\]\nWhere: - \\(k\\) is related to the wavelength (\\(k = 2\\pi/\\lambda\\)) - \\(r\\) is the distance from the source - We’ve simplified by ignoring how the wave gets smaller as it travels (\\(1/r\\) term)\n\n\nTwo Wave Sources\nWhen we have two wave sources (like two stones dropped in the pond): 1. Each source creates its own wave 2. The waves combine where they meet 3. The total wave is the sum of both waves\n\n\n\ninterference\n\n\nMathematically: \\[\\begin{equation}\nU_{total} = e^{-i\\,k r_1} + e^{-i\\,k r_2}\n\\end{equation}\\]\nWhere \\(r_1\\) and \\(r_2\\) are the distances from each source.\n\n\nWhat We See (Intensity)\nWhat we actually see is the intensity of the combined waves:\n\\[\\begin{equation}\n\\text{Intensity} \\propto |U_{total}|^2\n\\end{equation}\\]\nThis will show us where the waves:\n\nAdd up (bright regions - constructive interference)\nCancel out (dark regions - destructive interference)\n\nLet’s create a Python program to visualize this!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor contour plot\n\n\n\n\n\n\n\n\nImage plot",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture04/04-plotting.html#advanced-plotting---explicit-version",
    "href": "lectures/lecture04/04-plotting.html#advanced-plotting---explicit-version",
    "title": "Plotting",
    "section": "Advanced Plotting - Explicit Version",
    "text": "Advanced Plotting - Explicit Version\nWhile we have so far largely relied on the default setting and the automatic arrangement of plots, there is also a way to precisely design your plot. Python provides the tools of object oriented programming and thus modules provide classes which can be instanced into objects. This explicit interfaces allows you to control all details without the automatisms of pyplot.\nThe figure below, which is taken from the matplotlib documentation website shows the sets of commands and the objects in the figure, the commands refer to. It is a nice reference, when creating a figure.\n\n\n\nanatomy of a figure\n\n\n\nPlots with Multiple Spines\nSometimes it is very useful to plot different quantities in the same plot with the same x-axis but with different y-axes. Here is some example, where each line plot has its own y-axis.\n\n\n\n\n\n\n\n\nInsets\nInsets are plots within plots using their own axes. We therefore need to create two axes systems, if we want to have a main plot and and inset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpine axis\n\n\n\n\n\n\n\n\nPolar plot\n\n\n\n\n\n\n\n\nText annotation\nAnnotating text in matplotlib figures can be done using the text function. It supports LaTeX formatting just like axis label texts and titles:\n\n\n\n\n\n\n\n\n3D Plotting\nMatplotlib was initially designed with only two-dimensional plotting in mind. Around the time of the 1.0 release, some three-dimensional plotting utilities were built on top of Matplotlib’s two-dimensional display, and the result is a convenient (if somewhat limited) set of tools for three-dimensional data visualization. Three-dimensional plots are enabled by importing the mplot3d toolkit, included with the main Matplotlib installation:\n\n\n\n\n\n\nOnce this submodule is imported, a three-dimensional axes can be created by passing the keyword projection=‘3d’ to any of the normal axes creation routines:\n\nProjection Scence\n\n\n\n\n\n\nWith this three-dimensional axes enabled, we can now plot a variety of three-dimensional plot types. Three-dimensional plotting is one of the functionalities that benefits immensely from viewing figures interactively rather than statically in the notebook; recall that to use interactive figures, you can use %matplotlib notebook rather than %matplotlib inline when running this code.\n\n\nLine Plotting in 3D\nfrom sets of (x, y, z) triples. In analogy with the more common two-dimensional plots discussed earlier, these can be created using the ax.plot3D and ax.scatter3D functions. The call signature for these is nearly identical to that of their two-dimensional counterparts, so you can refer to Simple Line Plots and Simple Scatter Plots for more information on controlling the output. Here we’ll plot a trigonometric spiral, along with some points drawn randomly near the line:\n\n\n\n\n\n\nNotice that by default, the scatter points have their transparency adjusted to give a sense of depth on the page. While the three-dimensional effect is sometimes difficult to see within a static image, an interactive view can lead to some nice intuition about the layout of the points. Use the scatter3D or the plot3D method to plot a random walk in 3-dimensions in your exercise.\n\n\nSurface Plotting\nA surface plot is like a wireframe plot, but each face of the wireframe is a filled polygon. Adding a colormap to the filled polygons can aid perception of the topology of the surface being visualized:",
    "crumbs": [
      "Python Basics",
      "Lecture 4",
      "Plotting"
    ]
  },
  {
    "objectID": "lectures/lecture04/1_quantum_mechanics.html",
    "href": "lectures/lecture04/1_quantum_mechanics.html",
    "title": "Quantum Mechanics",
    "section": "",
    "text": "In the last lecture, we have modeled electromagnetic waves not by solving the wave equation, but by taking the solutions of wave equations like a plane wave or a spherical wave. Today we will solve a wave equation, but not for electromagnetic waves, but for matter waves. We will solve the stationary Schrödinger equation with the implicit solution scheme, which we have already applied for the diffusion equation. With the help of that we will tackle the particle in a box, the harmonic oscillator and the periodic potential. All of these problems have also analytical solutions, thus we do not need the numerical solution in principle. But it will give us some practice on how to tackle such problems. As not all of you might be familiar with the physical description of quantum mechanics, we will give a short introduction into this field first.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import eigsh\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n# default values for plotting\nplt.rcParams.update({'font.size': 12,\n                     'axes.titlesize': 18,\n                     'axes.labelsize': 16,\n                     'axes.labelpad': 14,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'xtick.labelsize' : 16,\n                     'ytick.labelsize' : 16,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})"
  },
  {
    "objectID": "lectures/lecture04/1_quantum_mechanics.html#quantum-mechanics-in-a-nutshell",
    "href": "lectures/lecture04/1_quantum_mechanics.html#quantum-mechanics-in-a-nutshell",
    "title": "Quantum Mechanics",
    "section": "Quantum Mechanics in a Nutshell",
    "text": "Quantum Mechanics in a Nutshell\nQuantum Mechanics assumes that all particles propagate as waves. They are described by a wavefunction \\(\\Psi(x,t)\\). A quantum mechanical object thus posseses an amplitude and a phase which propagate in space and time. One could see the wavefunction in analogy to the electric field \\(\\vec{E}(x)\\) of an electromagnetic wave. As the square of the electric field describes the propagation of energy of a wave, the square magnitude of the wavefunction, i.e. \\(|\\Psi(x,t)|^2\\), describes the propagation of probability density of the quantum mechanical wave. The wavefunction itself is thus just the probability amplitude.\n\nTime dependent Schrödinger equation\nThe dynamics of a quantum mechanical wave is described,for example, by the time dependent Schrödinger equation\n\\[\\begin{equation}\n-i\\hbar\\frac{\\partial \\Psi(x,t)}{\\partial t} = \\left ( \\frac{-\\hbar^2 }{2m}\\frac{\\partial^2}{\\partial x^2}+V(x,t) \\right ) \\Psi(x,t)\n\\end{equation}\\]\nwhis is written here for one dimension only.\nThe bracket on the right side of the above equation contains the so-called Hamilton operator \\(\\hat{H}\\). The Hamilton operator \\(\\hat{H}\\) contains the energy operators for the kinetic and potential energies and represents the total energy of the system.\n\\[\\begin{equation}\n\\hat{H}=\\left ( \\frac{-\\hbar^2 }{2m}\\frac{\\partial^2}{\\partial x^2}+V(x,t) \\right )\n\\end{equation}\\]\n\n\nStationary Schrödinger equation\nOur first problems will be stationary problems. We will not ask for the temporal development of the quantum object. We will rather ask, what solutions without time dependence are possible. In general this is much like the question asking what kind of standing waves are possible on a string or in an optical resonator. In quantum mechanics the boundaries, which define the standing waves are formed by the potential energy \\(V(x)\\).\nWe therefore also need the stationary Schrödinger equation, where the left side of the time dependent Schrödinger equation does not depend on time, hence is constant in time. This stationary (time-independent) Schrödinger equation is\n\\[\\begin{equation}\n\\hat{H}\\Psi(x)=E\\Psi(x)\n\\end{equation}\\]\nThe Hamilton operator \\(\\hat{H}\\) gives a recipe how to calculate the energies for a given wavefunction \\(\\Psi(x)\\) in terms of derivates or multiplications by functions. If this recipe reduces to a multiplication of the wave function with a number \\(E\\), then these wavefunctions are eigenfunction of the Hamilton operator and the values of \\(E\\) are the eigenvalues of the problem, i.e. the time-independent solutions of this differential equation."
  },
  {
    "objectID": "lectures/lecture04/1_quantum_mechanics.html#recap-implicit-solution",
    "href": "lectures/lecture04/1_quantum_mechanics.html#recap-implicit-solution",
    "title": "Quantum Mechanics",
    "section": "Recap: Implicit Solution",
    "text": "Recap: Implicit Solution\nAccording to our above description, the Hamilton operator \\(\\hat{H}\\) contains two parts, a second derivative in the position, which represents the kinetic energy and the potential energy operator \\(V(x)\\), which is in the simplest case just a function of \\(x\\).\n\\[\\begin{equation}\n\\left ( \\frac{-\\hbar^2 }{2m}\\frac{\\partial^2}{\\partial x^2}+V(x) \\right ) \\Psi(x)=E\\Psi(x)\n\\end{equation}\\]\nSince we want to apply our implicit solution scheme (Cranck Nicolson), we want to represent both parts as matrices.\n\nKinetic energy\nWe remember that we can write the second derivative of our wavefunction \\(\\Psi(x)\\) in the finite difference approximation as\n\\[\\begin{equation}\n\\Psi^{''}(x)=\\frac{\\Psi(x+\\delta x)-2\\Psi(x)+\\Psi(x-\\delta x)}{\\delta x^{2}}\n\\end{equation}\\]\nIf we want to evaluate the wavefunction at certain positions \\(x_{i}\\), then this second derivative translates into\n\\(T\\Psi=\\frac{d^2}{dx^2}\\Psi=\\frac{1}{\\delta x^2}\n\\begin{bmatrix}\n-2 & 1  & 0 & 0 & 0 & 0\\\\\n1 & -2 & 1 & 0 & 0 & 0\\\\\n0 & 1  & -2 & 1 & 0 & 0\\\\\n0 & 0  & 1  & -2 & 1 & 0\\\\\n0 & 0  & 0  &  1 & -2 & 1\\\\\n0 & 0  & 0  &  0 &  1 & -2\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}\\)\nif we just use 6 positions. Please remember, that in the version above, we have imposed already boundary conditions in the first and the last row, which are \\(\\Psi(x_{0})=0\\) and \\(\\Psi(x_{7})=0\\). If we multiply this matrix by \\(-\\hbar^{2}/2m\\), we obtain the kinetic energy for an object of mass \\(m\\).\n\n\nPotential energy\nThe potential energy values are just values at the diagonal of the matrix\n\\(V\\Psi=\n\\begin{bmatrix}\nV(x_{1}) & 0  & 0 & 0 & 0 & 0\\\\\n0 & V(x_{2}) & 0 & 0 & 0 & 0\\\\\n0 & 0  & V(x_{3}) & 0 & 0 & 0\\\\\n0 & 0  & 0  & V(x_{4}) & 0 & 0\\\\\n0 & 0  & 0  &  0 & V(x_{5}) & 0\\\\\n0 & 0  & 0  &  0 &  0 & V(x_{6})\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}\\)\nan you may insert the specific potential energy values for your particular problem here.\nOur final problem \\(\\hat{H}\\Psi=E\\Psi\\) will thus have the following shape\n\\[\\begin{equation}\n\\begin{bmatrix}\n-2+V(x_{1}) & 1  & 0 & 0 & 0 & 0\\\\\n1 & -2+V(x_{2}) & 1 & 0 & 0 & 0\\\\\n0 & 1 & -2+V(x_{3})  & 1 & 0 & 0 \\\\\n0 &0 & 1  & -2+V(x_{4})  & 1 & 0 \\\\\n0 & 0 & 0  & 1  &  -2+V(x_{5}) & 1 \\\\\n0 & 0 & 0  & 0  &  1 &  -2+V(x_{6}) \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}=E\n\\begin{bmatrix}\n\\Psi(x_{1})\\\\\n\\Psi(x_{2})\\\\\n\\Psi(x_{3})\\\\\n\\Psi(x_{4})\\\\\n\\Psi(x_{5})\\\\\n\\Psi(x_{6})\n\\end{bmatrix}\n\\end{equation}\\]\nwhere I skipped the prefactor \\(-\\hbar^2/2m\\), to fit the matrices on one line. Yet I did not succeed. This is the final system of coupled equations which we can supply to any matrix solver. We will use a solver from the scipy.linalg module. In case we have special boundary conditions, we need to take them into account and replace the first and the last line for example with the particular boundary conditions."
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html",
    "href": "lectures/lecture04/01-lecture04.html",
    "title": "Lecture 4",
    "section": "",
    "text": "Introduction to loops for numerical integration (e.g., trapezoidal rule).\nFunctions for calculating work, power, and energy.\n\n\n\n\n\nWriting Python code to calculate the work done by a variable force (e.g., spring force) using numerical integration.\nSimulating energy conservation in a closed system (e.g., pendulum).\nVisualization: Plotting energy vs. time for the system.\nHomework: Modify the code to simulate a different system, such as a mass-spring system.\n\n\n\n\n    \n    \n    D3.js Shaded Spheres"
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#work-power-energy",
    "href": "lectures/lecture04/01-lecture04.html#work-power-energy",
    "title": "Lecture 4",
    "section": "",
    "text": "Introduction to loops for numerical integration (e.g., trapezoidal rule).\nFunctions for calculating work, power, and energy.\n\n\n\n\n\nWriting Python code to calculate the work done by a variable force (e.g., spring force) using numerical integration.\nSimulating energy conservation in a closed system (e.g., pendulum).\nVisualization: Plotting energy vs. time for the system.\nHomework: Modify the code to simulate a different system, such as a mass-spring system.\n\n\n\n\n    \n    \n    D3.js Shaded Spheres"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html",
    "href": "lectures/lecture03/01-lecture03.html",
    "title": "Lecture 3",
    "section": "",
    "text": "Lists and arrays (introduction to numpy for numerical operations).\nBasic vector operations using numpy.\n\n\n\n\n\n\n\nNumpy Array\n\n\n\nThe NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a NumPy array are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type. For example, they might be all integers or all floating point numbers. NumPy arrays are more efficient than Python lists for storing and manipulating data.\n\n\n\n\n\n\n\n\n\n\nThere are a number of ways to initialize new numpy arrays, for example from\n\na Python list or tuples using np.array\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section of this course.\n\n\n\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function. This is demonstrated in the following cells:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms and shapes. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinspace\n\n\n\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50. The function linspace always includes the end points.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlogspace\n\n\n\nlogspace is doing equivelent things with logaritmic spacing. The function logspace generates an array of N points between decades 10^start and 10^stop. The form of the function is logspace(start, stop, N). If the third argument N is omitted, then N=50. The function logspace always includes the end points.\n\n\n\n\n\n\n\n\nOther types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\nmgrid\n\n\n\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows. The arguments are similar to arange and linspace.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiag\n\n\n\ndiag generates a diagonal matrix with the list supplied to it as the diagonal values. The values can be also offset from the main diagonal by using the optional argument k. If k is positive, the diagonal is above the main diagonal, if negative, below the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeros and ones\n\n\n\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1. The argument is a tuple with the dimensions of the matrix. For example, np.zeros((3,3)) creates a 3x3 matrix filled with zeros.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSlicing is the name for extracting part of an array by the syntax M[lower:upper:step]. When any of these are unspecified, they default to the values lower=0, upper=size of dimension, step=1. We can also use negative indices to count from the end of the array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining) and can be used in any of the three slicing parameters. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays. We can slice along each axis independently. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by the formula\n\\[\\begin{equation}\n  v_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n  \\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays can be reshaped into any form, which contains the same number of elements. For example, a 4-element array can be reshaped into a 2x2 array, or a 2x2 array can be reshaped into a 4-element array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones by repeating or stacking. Please try the individual functions yourself in your notebook. We wont discuss them in detail here.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConcatenate joins arrays along an existing axis. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhstack and vstack stack arrays horizontally and vertically. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAll kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below where a is an array of numbers from 0 to 9.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperation between multiple vectors allow in particular very quick operations. The operations address then elements of the same index. These operations are called vector operations since the concern the whole array at the same time. The product between two vectors results therefore not in a dot product, which gives one number but in an array of multiplied elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxxw\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulating and plotting the trajectory of a projectile under the influence of gravity (2D motion).\nIntroduction to vector addition and resolving vectors into components.\nVisualization: Plotting the path of the projectile and velocity vectors.\nHomework: Simulate projectile motion with air resistance (optional for advanced students)."
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#creating-numpy-arrays",
    "href": "lectures/lecture03/01-lecture03.html#creating-numpy-arrays",
    "title": "Lecture 3",
    "section": "",
    "text": "There are a number of ways to initialize new numpy arrays, for example from\n\na Python list or tuples using np.array\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section of this course.\n\n\n\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function. This is demonstrated in the following cells:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor larger arrays it is inpractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms and shapes. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinspace\n\n\n\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50. The function linspace always includes the end points.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlogspace\n\n\n\nlogspace is doing equivelent things with logaritmic spacing. The function logspace generates an array of N points between decades 10^start and 10^stop. The form of the function is logspace(start, stop, N). If the third argument N is omitted, then N=50. The function logspace always includes the end points.\n\n\n\n\n\n\n\n\nOther types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\nmgrid\n\n\n\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows. The arguments are similar to arange and linspace.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiag\n\n\n\ndiag generates a diagonal matrix with the list supplied to it as the diagonal values. The values can be also offset from the main diagonal by using the optional argument k. If k is positive, the diagonal is above the main diagonal, if negative, below the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeros and ones\n\n\n\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1. The argument is a tuple with the dimensions of the matrix. For example, np.zeros((3,3)) creates a 3x3 matrix filled with zeros."
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#manipulating-numpy-arrays",
    "href": "lectures/lecture03/01-lecture03.html#manipulating-numpy-arrays",
    "title": "Lecture 3",
    "section": "",
    "text": "Slicing is the name for extracting part of an array by the syntax M[lower:upper:step]. When any of these are unspecified, they default to the values lower=0, upper=size of dimension, step=1. We can also use negative indices to count from the end of the array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining) and can be used in any of the three slicing parameters. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays. We can slice along each axis independently. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by the formula\n\\[\\begin{equation}\n  v_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n  \\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays can be reshaped into any form, which contains the same number of elements. For example, a 4-element array can be reshaped into a 2x2 array, or a 2x2 array can be reshaped into a 4-element array. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones by repeating or stacking. Please try the individual functions yourself in your notebook. We wont discuss them in detail here.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConcatenate joins arrays along an existing axis. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhstack and vstack stack arrays horizontally and vertically. Here are some examples:"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#applying-mathematical-functions",
    "href": "lectures/lecture03/01-lecture03.html#applying-mathematical-functions",
    "title": "Lecture 3",
    "section": "",
    "text": "All kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below where a is an array of numbers from 0 to 9.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperation between multiple vectors allow in particular very quick operations. The operations address then elements of the same index. These operations are called vector operations since the concern the whole array at the same time. The product between two vectors results therefore not in a dot product, which gives one number but in an array of multiplied elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxxw"
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html#application",
    "href": "lectures/lecture03/01-lecture03.html#application",
    "title": "Lecture 3",
    "section": "",
    "text": "Simulating and plotting the trajectory of a projectile under the influence of gravity (2D motion).\nIntroduction to vector addition and resolving vectors into components.\nVisualization: Plotting the path of the projectile and velocity vectors.\nHomework: Simulate projectile motion with air resistance (optional for advanced students)."
  },
  {
    "objectID": "lectures/lecture02/datatypes_quiz.html",
    "href": "lectures/lecture02/datatypes_quiz.html",
    "title": "Datatypes Quiz",
    "section": "",
    "text": "Test your knowledge of Python data types with this interactive quiz!\n\n\nWhat is the output of len(\"Hello, World!\")?\n\n\n\n\n\n\n\n10\n11\n13\n14\n\nWhat is the result of [1, 2, 3] + [4, 5]?\n\n\n\n\n\n\n\n(1, 2, 3, 4, 5)\n[1, 2, 3, 4, 5]\n[5, 7, 8]\nError\n\nWhich of the following creates an empty dictionary?\n\n{}\n[]\n()\nBoth {} and dict()\n\nWhat is the output of set([1, 2, 2, 3, 3, 3])?\n\n\n\n\n\n\n\n[1, 2, 2, 3, 3, 3]\n{1, 2, 3}\n{1, 2, 2, 3, 3, 3}\nError\n\nWhat is the result of \"Hello\" * 3?\n\n\n\n\n\n\n\nHello Hello Hello\nHelloHelloHello\nHello3\nError\n\n\n\n\n\n\n\n\n\nClick to reveal answers\n\n\n\n\n\n\n13\n[1, 2, 3, 4, 5]\nBoth {} and dict()\n{1, 2, 3}\nHelloHelloHello"
  },
  {
    "objectID": "lectures/lecture02/datatypes_quiz.html#python-data-types-quiz",
    "href": "lectures/lecture02/datatypes_quiz.html#python-data-types-quiz",
    "title": "Datatypes Quiz",
    "section": "",
    "text": "Test your knowledge of Python data types with this interactive quiz!\n\n\nWhat is the output of len(\"Hello, World!\")?\n\n\n\n\n\n\n\n10\n11\n13\n14\n\nWhat is the result of [1, 2, 3] + [4, 5]?\n\n\n\n\n\n\n\n(1, 2, 3, 4, 5)\n[1, 2, 3, 4, 5]\n[5, 7, 8]\nError\n\nWhich of the following creates an empty dictionary?\n\n{}\n[]\n()\nBoth {} and dict()\n\nWhat is the output of set([1, 2, 2, 3, 3, 3])?\n\n\n\n\n\n\n\n[1, 2, 2, 3, 3, 3]\n{1, 2, 3}\n{1, 2, 2, 3, 3, 3}\nError\n\nWhat is the result of \"Hello\" * 3?\n\n\n\n\n\n\n\nHello Hello Hello\nHelloHelloHello\nHello3\nError\n\n\n\n\n\n\n\n\n\nClick to reveal answers\n\n\n\n\n\n\n13\n[1, 2, 3, 4, 5]\nBoth {} and dict()\n{1, 2, 3}\nHelloHelloHello"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html",
    "href": "lectures/lecture02/05-lecture02.html",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a new figure\nplt.figure(figsize=(width, height))\n\n# Create a plot\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\n\n# Set labels and title\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\n\n# Add a legend\nplt.legend(['Label'], loc='best')\n\n# Show the plot\nplt.show()\n\n\n\n\nLine plot: plt.plot(x, y)\nScatter plot: plt.scatter(x, y)\nBar plot: plt.bar(x, height)\nHistogram: plt.hist(data, bins=10)\nBox plot: plt.boxplot(data)\nErrorbar plot: plt.errorbar(x, y, yerr=error)\n\n\n\n\n\nSet axis limits: plt.xlim(xmin, xmax), plt.ylim(ymin, ymax)\nSet axis scales: plt.xscale('log'), plt.yscale('log')\nSet tick marks: plt.xticks(ticks, labels), plt.yticks(ticks, labels)\nAdd a grid: plt.grid(True)\nChange line style: plt.plot(x, y, linestyle='--', color='r', linewidth=2)\nChange marker style: plt.plot(x, y, marker='o', markersize=5)\n\n\n\n\n\nSubplots: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\nPlot on specific axes: ax1.plot(x, y)\n\n\n\n\nplt.savefig('filename.png', dpi=300, bbox_inches='tight')\n\n\n\n\nContour plot: plt.contour(X, Y, Z)\n3D plot:\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(X, Y, Z)\n\n\n\n\n\nAdjust layout: plt.tight_layout()\nSet style: plt.style.use('ggplot')\nColormap: plt.imshow(data, cmap='viridis')\n\n\n\n\n\nColors: ‘b’ (blue), ‘g’ (green), ‘r’ (red), ‘c’ (cyan), ‘m’ (magenta), ‘y’ (yellow), ‘k’ (black), ‘w’ (white)\nMarkers: ‘.’ (point), ‘o’ (circle), ‘s’ (square), ‘^’ (triangle up), ‘v’ (triangle down)\nLinestyles: ‘-’ (solid), ‘–’ (dashed), ‘:’ (dotted), ‘-.’ (dash-dot)\n\nRemember to always check the Matplotlib documentation for the most up-to-date and detailed information!"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#basic-plot-setup",
    "href": "lectures/lecture02/05-lecture02.html#basic-plot-setup",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a new figure\nplt.figure(figsize=(width, height))\n\n# Create a plot\nplt.plot(x, y, 'bo-')  # Blue line with circle markers\n\n# Set labels and title\nplt.xlabel('X-axis label')\nplt.ylabel('Y-axis label')\nplt.title('Plot Title')\n\n# Add a legend\nplt.legend(['Label'], loc='best')\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#common-plot-types",
    "href": "lectures/lecture02/05-lecture02.html#common-plot-types",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Line plot: plt.plot(x, y)\nScatter plot: plt.scatter(x, y)\nBar plot: plt.bar(x, height)\nHistogram: plt.hist(data, bins=10)\nBox plot: plt.boxplot(data)\nErrorbar plot: plt.errorbar(x, y, yerr=error)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#customization",
    "href": "lectures/lecture02/05-lecture02.html#customization",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Set axis limits: plt.xlim(xmin, xmax), plt.ylim(ymin, ymax)\nSet axis scales: plt.xscale('log'), plt.yscale('log')\nSet tick marks: plt.xticks(ticks, labels), plt.yticks(ticks, labels)\nAdd a grid: plt.grid(True)\nChange line style: plt.plot(x, y, linestyle='--', color='r', linewidth=2)\nChange marker style: plt.plot(x, y, marker='o', markersize=5)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#multiple-plots",
    "href": "lectures/lecture02/05-lecture02.html#multiple-plots",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Subplots: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\nPlot on specific axes: ax1.plot(x, y)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#saving-plots",
    "href": "lectures/lecture02/05-lecture02.html#saving-plots",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "plt.savefig('filename.png', dpi=300, bbox_inches='tight')"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#advanced-plots",
    "href": "lectures/lecture02/05-lecture02.html#advanced-plots",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Contour plot: plt.contour(X, Y, Z)\n3D plot:\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(X, Y, Z)"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#useful-settings",
    "href": "lectures/lecture02/05-lecture02.html#useful-settings",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Adjust layout: plt.tight_layout()\nSet style: plt.style.use('ggplot')\nColormap: plt.imshow(data, cmap='viridis')"
  },
  {
    "objectID": "lectures/lecture02/05-lecture02.html#common-parameters",
    "href": "lectures/lecture02/05-lecture02.html#common-parameters",
    "title": "Matplotlib Cheat Sheet",
    "section": "",
    "text": "Colors: ‘b’ (blue), ‘g’ (green), ‘r’ (red), ‘c’ (cyan), ‘m’ (magenta), ‘y’ (yellow), ‘k’ (black), ‘w’ (white)\nMarkers: ‘.’ (point), ‘o’ (circle), ‘s’ (square), ‘^’ (triangle up), ‘v’ (triangle down)\nLinestyles: ‘-’ (solid), ‘–’ (dashed), ‘:’ (dotted), ‘-.’ (dash-dot)\n\nRemember to always check the Matplotlib documentation for the most up-to-date and detailed information!"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html",
    "href": "lectures/lecture02/01-summary02.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\ndef function_name(parameter1: type, parameter2: type) -&gt; return_type:\n    # function body\n    return value\n\n\n\nresult = function_name(argument1, argument2)\n\n\n\n\n\n\nfor item in sequence:\n    # code to be executed for each item\nExample:\nfor i in range(1, 11):\n    print(i)\n\n\n\nwhile condition:\n    # code to be executed while condition is true\n    # remember to update the condition\nExample:\ni = 1\nwhile i &lt;= 10:\n    print(i)\n    i += 1\n\n\n\n\n\n\nif condition:\n    # code to be executed if condition is true\n\n\n\nif condition:\n    # code to be executed if condition is true\nelse:\n    # code to be executed if condition is false\n\n\n\nif condition1:\n    # code for condition1\nelif condition2:\n    # code for condition2\nelse:\n    # code if no conditions are true\n\n\n\n\n\nUse descriptive function names\nSpecify parameter and return types for clarity\nIndent properly in loops and conditional statements\nRemember to increment counters in while loops\nUse range() for numeric loops in for statements\nConsider multiple conditions with elif for complex logic"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#python-basics-cheat-sheet",
    "href": "lectures/lecture02/01-summary02.html#python-basics-cheat-sheet",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\ndef function_name(parameter1: type, parameter2: type) -&gt; return_type:\n    # function body\n    return value\n\n\n\nresult = function_name(argument1, argument2)\n\n\n\n\n\n\nfor item in sequence:\n    # code to be executed for each item\nExample:\nfor i in range(1, 11):\n    print(i)\n\n\n\nwhile condition:\n    # code to be executed while condition is true\n    # remember to update the condition\nExample:\ni = 1\nwhile i &lt;= 10:\n    print(i)\n    i += 1\n\n\n\n\n\n\nif condition:\n    # code to be executed if condition is true\n\n\n\nif condition:\n    # code to be executed if condition is true\nelse:\n    # code to be executed if condition is false\n\n\n\nif condition1:\n    # code for condition1\nelif condition2:\n    # code for condition2\nelse:\n    # code if no conditions are true\n\n\n\n\n\nUse descriptive function names\nSpecify parameter and return types for clarity\nIndent properly in loops and conditional statements\nRemember to increment counters in while loops\nUse range() for numeric loops in for statements\nConsider multiple conditions with elif for complex logic"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#functions",
    "href": "lectures/lecture02/01-summary02.html#functions",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "def function_name(parameter1: type, parameter2: type) -&gt; return_type:\n    # function body\n    return value\n\n\n\nresult = function_name(argument1, argument2)"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#loops",
    "href": "lectures/lecture02/01-summary02.html#loops",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "for item in sequence:\n    # code to be executed for each item\nExample:\nfor i in range(1, 11):\n    print(i)\n\n\n\nwhile condition:\n    # code to be executed while condition is true\n    # remember to update the condition\nExample:\ni = 1\nwhile i &lt;= 10:\n    print(i)\n    i += 1"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#conditional-statements",
    "href": "lectures/lecture02/01-summary02.html#conditional-statements",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "if condition:\n    # code to be executed if condition is true\n\n\n\nif condition:\n    # code to be executed if condition is true\nelse:\n    # code to be executed if condition is false\n\n\n\nif condition1:\n    # code for condition1\nelif condition2:\n    # code for condition2\nelse:\n    # code if no conditions are true"
  },
  {
    "objectID": "lectures/lecture02/01-summary02.html#tips",
    "href": "lectures/lecture02/01-summary02.html#tips",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Use descriptive function names\nSpecify parameter and return types for clarity\nIndent properly in loops and conditional statements\nRemember to increment counters in while loops\nUse range() for numeric loops in for statements\nConsider multiple conditions with elif for complex logic"
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html",
    "href": "lectures/lecture05/2_brownian_motion.html",
    "title": "Brownian Motion",
    "section": "",
    "text": "We will apply our newly acquired knowledge about classes to simulate Brownian motion. This task aligns perfectly with the principles of object-oriented programming, as each Brownian particle (or colloid) can be represented as an object instantiated from the same class, albeit with different properties. For instance, some particles might be larger while others are smaller. We have already touched on some aspects of this in previous lectures.",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html#brownian-motion",
    "href": "lectures/lecture05/2_brownian_motion.html#brownian-motion",
    "title": "Brownian Motion",
    "section": "Brownian Motion",
    "text": "Brownian Motion\n\nWhat is Brownian Motion?\nImagine a dust particle floating in water. If you look at it under a microscope, you’ll see it moving in a random, zigzag pattern. This is Brownian motion!\n\n\nWhy Does This Happen?\nWhen we observe Brownian motion, we’re seeing the effects of countless molecular collisions. Water isn’t just a smooth, continuous fluid - it’s made up of countless tiny molecules that are in constant motion. These water molecules are continuously colliding with our particle from all directions. Each individual collision causes the particle to move just a tiny bit, barely noticeable on its own. However, when millions of these tiny collisions happen every second from random directions, they create the distinctive zigzag motion we observe.\n\n\nThe Simplified Math Behind It\nWhen our particle moves:\n\nEach step is random in direction\nThe size of each step depends on:\n\nTemperature (warmer = more movement)\nTime between steps\nA property called the “diffusion coefficient” (D)\n\n\n\n\nHow We Can Simulate This?\nIn Python, we can simulate these random steps using random number. These random numbers can be generated with the numpy library. Numpy provides a number of different functions that provide random numbers from different distributions. For Brownian motion, we use a special distribution called the “normal distribution”.\nstep_size = np.sqrt(2 * D * time_step)\ndx = random_number * step_size  # Random step in x direction\ndy = random_number * step_size  # Random step in y direction\n\nnew_x = old_x + dx\nnew_y = old_y + dy\nWhere:\n\nD is how easily the particle moves (diffusion coefficient)\ntime_step is how often we update the position\nrandom_number is chosen from a special “normal distribution”\n\n\n\n\n\n\n\nTip\n\n\n\nWhen simulating Brownian motion, we use np.random.normal to generate random steps following this distribution. The normal distribution is characterized by two parameters: the mean and the standard deviation. The mean is the average value, and the standard deviation is a measure of how spread out the values are. For Brownian motion, we use a standard deviation that depends on the diffusion coefficient and the time step. The standard deviation \\(\\sigma=\\sqrt{2D \\Delta t}\\) determines the typical step size, which we can use as a parameter in the normal distribution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvanced Mathematical Details\n\n\n\n\n\nThe Brownian motion of a colloidal particle results from collisions with surrounding solvent molecules. These collisions lead to a probability distribution described by:\n\\[\np(x,\\Delta t)=\\frac{1}{\\sqrt{4\\pi D \\Delta t}}e^{-\\frac{x^2}{4D \\Delta t}}\n\\]\nwhere: - \\(D\\) is the diffusion coefficient - \\(\\Delta t\\) is the time step - The variance is \\(\\sigma^2=2D \\Delta t\\)\nThis distribution emerges from the central limit theorem, as shown by Lindenberg and Lévy, when considering many infinitesimally small random steps.\nThe evolution of the probability density function \\(p(x,t)\\) is governed by the diffusion equation:\n\\[\n\\frac{\\partial p}{\\partial t}=D\\frac{\\partial^2 p}{\\partial x^2}\n\\]\nThis partial differential equation, also known as Fick’s second law, describes how the concentration of particles evolves over time due to diffusive processes. The Gaussian distribution above is the fundamental solution (Green’s function) of this diffusion equation, representing how an initially localized distribution spreads out over time.\nThe connection between the microscopic random motion and the macroscopic diffusion equation was first established by Einstein in his 1905 paper on Brownian motion, providing one of the earliest quantitative links between statistical mechanics and thermodynamics.",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html#why-use-a-class",
    "href": "lectures/lecture05/2_brownian_motion.html#why-use-a-class",
    "title": "Brownian Motion",
    "section": "Why Use a Class?",
    "text": "Why Use a Class?\nA class is perfect for this physics simulation because each colloidal particle:\n\nHas specific properties\n\nSize (radius)\nCurrent position\nMovement history\nDiffusion coefficient\n\nFollows certain behaviors\n\nMoves randomly (Brownian motion)\nUpdates its position over time\nKeeps track of where it’s been\n\nCan exist alongside other particles\n\nMany particles can move independently\nEach particle keeps track of its own properties\nParticles can have different sizes\n\nNeeds to track its state over time\n\nRemember previous positions\nCalculate distances moved\nMaintain its own trajectory\n\n\nThis natural mapping between real particles and code objects makes classes an ideal choice for our simulation.",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html#class-design",
    "href": "lectures/lecture05/2_brownian_motion.html#class-design",
    "title": "Brownian Motion",
    "section": "Class Design",
    "text": "Class Design\nLet’s design a Python class to simulate colloidal particles undergoing Brownian motion. This object-oriented approach will help us manage multiple particles with different properties and behaviors.\n\nClass-Level Properties\nThe Colloid class will maintain information shared by all particles:\n\nA counter for the total number of particles\nThe physical constant \\(k_B T/(6\\pi\\eta) = 2.2×10^{-19}\\) (combining temperature and fluid properties)\n\n\n\nClass Methods\nThe class will provide these shared functions:\n\nhow_many(): Reports the total number of particles\n__str__: Creates a readable description of a particle’s properties\n\n\n\nInstance Properties\nEach individual particle object will have:\n\nRadius (R)\nPosition history (x and y coordinates)\nUnique identifier (index)\nDiffusion coefficient (\\(D = k_B T/(6\\pi\\eta R)\\))\n\n\n\nInstance Methods\nEach particle will be able to:\n\nsim_trajectory(): Generate a complete motion path\nupdate(dt): Calculate one step of Brownian motion\nget_trajectory(): Return its movement history\nget_D(): Provide its diffusion coefficient\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that the function sim_trajectory is actually calling the function update of the same object to generate the whole trajectory at once.",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html#simulating",
    "href": "lectures/lecture05/2_brownian_motion.html#simulating",
    "title": "Brownian Motion",
    "section": "Simulating",
    "text": "Simulating\nWith the help of this Colloid class, we would like to carry out simulations of Brownian motion of multiple particles. The simulations shall\n\ntake n=200 particles\nhave N=200 trajectory points each\nstart all at 0,0\nparticle objects should be stored in a list p_list",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html#plotting-the-trajectories",
    "href": "lectures/lecture05/2_brownian_motion.html#plotting-the-trajectories",
    "title": "Brownian Motion",
    "section": "Plotting the trajectories",
    "text": "Plotting the trajectories\nThe next step is to plot all the trajectories.",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/2_brownian_motion.html#characterizing-the-brownian-motion",
    "href": "lectures/lecture05/2_brownian_motion.html#characterizing-the-brownian-motion",
    "title": "Brownian Motion",
    "section": "Characterizing the Brownian motion",
    "text": "Characterizing the Brownian motion\nNow that we have a number of trajectories, we can analyze the motion of our Brownian particles.\n\nCalculate the particle speed\nOne way is to calculate its speed by measuring how far it traveled within a certain time \\(n\\, dt\\), where \\(dt\\) is the timestep of out simulation. We can do that as\n\\[\\begin{equation}\nv(n dt) = \\frac{&lt;\\sqrt{(x_{i+n}-x_{i})^2+(y_{i+n}-y_{i})^2}&gt;}{n\\,dt}\n\\end{equation}\\]\nThe angular brackets on the top take care of the fact that we can measure the distance traveled within a certain time \\(n\\, dt\\) several times along a trajectory.\nThese values can be used to calculate a mean speed. Note that there is not an equal amount of data pairs for all separations available. For \\(n=1\\) there are 5 distances available. For \\(n=5\\), however, only 1. This changes the statistical accuracy of the mean.\n\n\n\n\n\n\nThe result of this analysis shows, that each particle has an apparent speed which seems to increase with decreasing time of observation or which decreases with increasing time. This would mean that there is some friction at work, which slows down the particle in time, but this is apparently not true. Also an infinite speed at zero time appears to be unphysical. The correct answer is just that the speed is no good measure to characterize the motion of a Brownian particle.\n\n\nCalculate the particle mean squared displacement\nA better way to characterize the motion of a Brownian particle is the mean squared displacement, as we have already mentioned it in previous lectures. We may compare our simulation now to the theoretical prediction, which is\n\\[\\begin{equation}\n\\langle \\Delta r^{2}(t)\\rangle=2 d D t\n\\end{equation}\\]\nwhere \\(d\\) is the dimension of the random walk, which is \\(d=2\\) in our case.\n\n\n\n\n\n\nThe results show that the mean squared displacement of the individual particles follows on average the theoretical predictions of a linear growth in time. That means, we are able to read the diffusion coefficient from the slope of the MSD of the individual particles if recorded in a simulation or an experiment.\nYet, each individual MSD is deviating strongly from the theoretical prediction especially at large times. This is due to the fact mentioned earlier that our simulation (or experimental) data only has a limited number of data points, while the theoretical prediction is made for the limit of infinite data points.\n\n\n\n\n\n\nAnalysis of MSD data\n\n\n\nSingle particle tracking, either in the experiment or in numerical simulations can therefore only deliver an estimate of the diffusion coefficient and care should be taken when using the whole MSD to obtain the diffusion coefficient. One typically uses only a short fraction of the whole MSD data at short times.",
    "crumbs": [
      "Python Basics",
      "Lecture 5",
      "Brownian Motion"
    ]
  },
  {
    "objectID": "lectures/lecture05/01-lecture05.html",
    "href": "lectures/lecture05/01-lecture05.html",
    "title": "Lecture 5",
    "section": "",
    "text": "Introduction to classes in Python (optional, for organizing code).\nRotational kinematics and dynamics (moment of inertia, angular momentum).\n\n\n\n\n\nSimulating the motion of a rotating object (e.g., a spinning disk) and calculating its angular momentum.\nVisualizing the effect of torque on the object’s rotation.\nHomework: Extend the simulation to include the effect of external forces, such as friction."
  },
  {
    "objectID": "lectures/lecture05/01-lecture05.html#angular-momentum-and-rotational-motion",
    "href": "lectures/lecture05/01-lecture05.html#angular-momentum-and-rotational-motion",
    "title": "Lecture 5",
    "section": "",
    "text": "Introduction to classes in Python (optional, for organizing code).\nRotational kinematics and dynamics (moment of inertia, angular momentum).\n\n\n\n\n\nSimulating the motion of a rotating object (e.g., a spinning disk) and calculating its angular momentum.\nVisualizing the effect of torque on the object’s rotation.\nHomework: Extend the simulation to include the effect of external forces, such as friction."
  },
  {
    "objectID": "lectures/lecture10/01-lecture10.html",
    "href": "lectures/lecture10/01-lecture10.html",
    "title": "Lecture 10",
    "section": "",
    "text": "Introduction to flow simulation and basic fluid mechanics principles (continuity equation, Bernoulli’s equation).\nUsing matplotlib for more advanced visualizations (e.g., vector fields).\n\n\n\n\n\nSimulating fluid flow in simple scenarios (e.g., flow through a pipe, around an object).\nVisualizing pressure and velocity fields.\nHomework: Simulate and visualize a more complex fluid system, such as flow over a wing."
  },
  {
    "objectID": "lectures/lecture10/01-lecture10.html#fluid-dynamics-and-surface-tension",
    "href": "lectures/lecture10/01-lecture10.html#fluid-dynamics-and-surface-tension",
    "title": "Lecture 10",
    "section": "",
    "text": "Introduction to flow simulation and basic fluid mechanics principles (continuity equation, Bernoulli’s equation).\nUsing matplotlib for more advanced visualizations (e.g., vector fields).\n\n\n\n\n\nSimulating fluid flow in simple scenarios (e.g., flow through a pipe, around an object).\nVisualizing pressure and velocity fields.\nHomework: Simulate and visualize a more complex fluid system, such as flow over a wing."
  },
  {
    "objectID": "lectures/lecture07/1_differentiation.html",
    "href": "lectures/lecture07/1_differentiation.html",
    "title": "Numerical Differentiation",
    "section": "",
    "text": "While we did introduce derivatives shortly already when exploring the slicing of arrays, we will now look at the numerical differentiation in more detail. This will require again a little bit of math.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Numerical Differentiation"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_differentiation.html#first-order-derivative",
    "href": "lectures/lecture07/1_differentiation.html#first-order-derivative",
    "title": "Numerical Differentiation",
    "section": "First Order Derivative",
    "text": "First Order Derivative\nOur previous method of finding the derivative was based on the definition of the derivative itself. The derivative of a function \\(f(x)\\) at a point \\(x\\) is defined as the limit of the difference quotient as the interval \\(\\Delta x\\) goes to zero:\n\\[\nf^{\\prime}(x) = \\lim_{\\Delta x \\rightarrow 0} \\frac{f(x + \\Delta x) - f(x)}{\\Delta x}\n\\]\nIf we do not take the limit, we can approximate the derivative by:\n\\[\nf^{\\prime}_{i} \\approx \\frac{f_{i+1} - f_{i}}{\\Delta x}\n\\]\nHere, we look to the right of the current position \\(i\\) and divide by the interval \\(\\Delta x\\). It is not difficult to see that the resulting local error \\(\\delta\\) at each step is given by:\n\\[\n\\delta = f_{i+1} - f_{i} - \\Delta x f^{\\prime}(x_i) = \\frac{1}{2} \\Delta x^2 f^{\\prime \\prime}(x_i) + O(\\Delta x^3)\n\\]\nIt can be seen that the error is proportional to the square of the interval \\(\\Delta x\\). This is the reason why the method is called first order accurate. The error is of the order of \\(\\Delta x^{2}\\).\nA better expression can be found using the Taylor expansion around the position \\(x_0\\):\n\\[\nf(x) = f(x_{0}) + (x - x_0) f^{\\prime}(x) + \\frac{(x - x_0)^2}{2!} f^{\\prime\\prime}(x) + \\frac{(x - x_0)^3}{3!} f^{(3)}(x) + \\ldots\n\\]\nIn discrete notation, this gives:\n\\[\nf_{i+1} = f_{i} + \\Delta x f_{i}^{\\prime} + \\frac{\\Delta x^2}{2!} f_{i}^{\\prime\\prime} + \\frac{\\Delta x^3}{3!} f_{i}^{(3)} + \\ldots\n\\]\nThe same can be done to obtain the function value at \\(i-1\\):\n\\[\nf_{i-1} = f_{i} - \\Delta x f_{i}^{\\prime} + \\frac{\\Delta x^2}{2!} f_{i}^{\\prime\\prime} - \\frac{\\Delta x^3}{3!} f_{i}^{(3)} + \\ldots\n\\]\nSubtracting these two equations, we get:\n\\[\nf_{i+1} - f_{i-1} = 2 \\Delta x f_{i}^{\\prime} + O(\\Delta x^3)\n\\]\nsuch that the second order term in \\(\\Delta x\\) disappears. Neglecting the higher-order terms, we have\n\\[\nf^{\\prime}_{i} \\approx \\frac{f_{i+1} - f_{i-1}}{2 \\Delta x}\n\\]\nan thus have a first order derivative which is even more accurate than the one obtained from the definition of the derivative.\nWe can continue that type of derivation now to obtain higher order approximation of the first derivative with better accuracy. For that purpose you may calculate now \\(f_{i\\pm 2}\\) and combining that with \\(f_{i+1}-f_{i-1}\\) will lead to\n\\[\\begin{equation}\nf_{i}^{\\prime}=\\frac{1}{12 \\Delta x}(f_{i-2}-8f_{i-1}+8f_{i+1}-f_{i+2})\n\\end{equation}\\]\nThis can be used to give even better values for the first derivative.\nLet`s try out one of the formulas in the following code cell. We will write a function that calculates the derivative of a given function at a given position \\(x\\). The function will take the function \\(f\\) as and argument, which is new to us. We will also introduce a small interval \\(h=\\Delta x\\) which will be used to calculate the derivative. The function will return the derivative of the function at the given position \\(x\\).\n\n\n\n\n\n\nNote that the definition contains additional parameters *params which are passed to the function f. This is a general way to pass additional parameters to the function f which is used in the definition of the derivative.\nWe will try to calculate the derivative of the \\(\\sin(x)\\) function:\n\n\n\n\n\n\nWe can plot this and nicely obtain our cosine function\n\n\n\n\n\n\n\nMatrix Version of the First Derivative\nIf we supply the above function with an array of positions \\(x_{i}\\) at which we would like to calculate the derivative, we obtain an array of derivative values. We can also write this procedure in a different way, which will be helpful for solving differential equations later.\nIf we consider the above finite difference formulas for a set of positions \\(x_{i}\\), we can represent the first derivative at these positions by a matrix operation as well:\n\\[\nf^{\\prime} = \\frac{1}{\\Delta x}\n\\begin{bmatrix}\n-1 & 1  & 0 & 0 & 0 & 0\\\\\n0 & -1 & 1 & 0 & 0 & 0\\\\\n0 & 0  & -1 & 1 & 0 & 0\\\\\n0 & 0  & 0  & -1 & 1 & 0\\\\\n0 & 0  & 0  &  0 & -1 & 1\\\\\n0 & 0  & 0  &  0 &  0 & -1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nf_{1}\\\\\nf_{2}\\\\\nf_{3}\\\\\nf_{4}\\\\\nf_{5}\\\\\nf_{6}\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{f_{2} - f_{1}}{\\Delta x}\\\\\n\\frac{f_{3} - f_{2}}{\\Delta x}\\\\\n\\frac{f_{4} - f_{3}}{\\Delta x}\\\\\n\\frac{f_{5} - f_{4}}{\\Delta x}\\\\\n\\frac{f_{6} - f_{5}}{\\Delta x}\\\\\n\\frac{0 - f_{6}}{\\Delta x}\\\\\n\\end{bmatrix}\n\\]\nNote that here we took the derivative only to the right side! Each row of the matrix, when multiplied by the vector containing the function values, gives the derivative of the function \\(f\\) at the corresponding position \\(x_{i}\\). The resulting vector represents the derivative in a certain position region.\nWe will demonstrate how to generate such a matrix with the SciPy module below.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Numerical Differentiation"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_differentiation.html#second-order-derivative",
    "href": "lectures/lecture07/1_differentiation.html#second-order-derivative",
    "title": "Numerical Differentiation",
    "section": "Second order derivative",
    "text": "Second order derivative\nWhile we did before calculate the first derivative, we can also calculate the second derivative of a function. In the previous calculations we evaluated \\(f_{i+1} - f_{i-1}\\). We can now also use the sum of both to arrive at\n\\[\\begin{equation}\nf_{i}^{\\prime\\prime}\\approx \\frac{f_{i-1}-2f_{i}+f_{i+1}}{\\Delta x^2}\n\\end{equation}\\]\nwhich gives the basic equation for calculating the second order derivative and the next order may be obtained from\n\\[\\begin{equation}\nf_{i}^{\\prime\\prime}\\approx \\frac{1}{12 \\Delta x^{2}}(-f_{i-2}+16f_{i-1}-30 f_{i}+16f_{i+1}-f_{i+2})\n\\end{equation}\\]\nwhich is again better than our previous formula, yet needs more function values to be calculated.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Numerical Differentiation"
    ]
  },
  {
    "objectID": "lectures/lecture07/1_differentiation.html#scipy-module",
    "href": "lectures/lecture07/1_differentiation.html#scipy-module",
    "title": "Numerical Differentiation",
    "section": "SciPy Module",
    "text": "SciPy Module\nOf course, we are not the first to define some functions for calculating the derivative of functions numerically. This is already implemented in different modules. One module is the above mentioned SciPy module.\nThe SciPy module provides the method derivative, which we can call with\nderivative(f,x,dx=1.0,n=1):\nThis will calculate the n\\(th\\) derivative of the function \\(f\\) at the position \\(x\\) with a intervall \\(dx=1.0\\) (default value).\n\n\n\n\n\n\nWe also have the option to define the order parameter, which is not the order of the derivative but rather the number of points used to calculate the derivative according to our scheme earlier.\n\n\n\n\n\n\n\nMatrix Version\nThe SciPy module allows us to construct matrices as mentioned above. We will need the diags method from the SciPy module for that purpose.\n\n\n\n\n\n\nLet’s assume we want to calculate the derivative of the sin function at certain positions.\n\n\n\n\n\n\nThe diags function uses a set of numbers that should be distributed along the diagonals of the matrix. If you supply a list like in the example below, the numbers are distributed using the offsets as defined in the second list. The shape keyword defines the shape of the matrix. Try the example in the next cell with the .todense() suffix. This converts the otherwise unreadable sparse output to a readable matrix form.\n\n\n\n\n\n\nTo comply with our previous definition of \\(N=100\\) data points and the interval \\(\\Delta x\\), we define:\n\n\n\n\n\n\nThe derivative is then simply a matrix-vector multiplication, which is done either by np.dot(m,y) or just by the @ operator.\n\n\n\n\n\n\nLet’s plot the original function and its numerical derivative.\n\n\n\n\n\n\nCheck for yourself that the following line of code will calculate the second derivative.\n\n\n\n\n\n\nLet’s plot the original function and its second numerical derivative.\n\n\n\n\n\n\nThis demonstrates how to use the SciPy module to construct matrices for numerical differentiation and how to apply these matrices to compute first and second derivatives.\n\n\n\n\n\n\nApplications of the Matrix Method\n\n\n\n\n\nThe matrix method for computing derivatives is particularly useful in several contexts, especially in numerical analysis and computational mathematics. Here are some key applications:\n\nSolving Differential Equations:\n\nOrdinary Differential Equations (ODEs): The matrix method can be used to discretize ODEs, transforming them into a system of linear equations that can be solved using linear algebra techniques.\nPartial Differential Equations (PDEs): Similarly, PDEs can be discretized using finite difference methods, where derivatives are approximated by matrix operations. This is essential in fields like fluid dynamics, heat transfer, and electromagnetics.\n\nNumerical Differentiation:\n\nThe matrix method provides a systematic way to approximate derivatives of functions given discrete data points. This is useful in data analysis, signal processing, and any application where you need to estimate the rate of change from sampled data.\n\nStability and Accuracy Analysis:\n\nBy representing derivative operations as matrices, it becomes easier to analyze the stability and accuracy of numerical schemes. This is crucial for ensuring that numerical solutions to differential equations are reliable.\n\nOptimization Problems:\n\nIn optimization, especially in gradient-based methods, the matrix method can be used to compute gradients and Hessians efficiently. This is important in machine learning, operations research, and various engineering disciplines.\n\nFinite Element Analysis (FEA):\n\nIn FEA, the matrix method is used to approximate derivatives and integrals over complex geometries. This is widely used in structural engineering, biomechanics, and materials science.\n\nControl Theory:\n\nIn control theory, especially in the design and analysis of control systems, the matrix method can be used to model and simulate the behavior of dynamic systems.",
    "crumbs": [
      "Python Basics",
      "Lecture 7",
      "Numerical Differentiation"
    ]
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html",
    "href": "lectures/lecture08/4_solving_ODEs.html",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "",
    "text": "This lecture covers methods for solving ordinary differential equations (ODEs), which are fundamental to many physics problems. We’ll explore different numerical approaches, from basic to more sophisticated methods."
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html#introduction",
    "href": "lectures/lecture08/4_solving_ODEs.html#introduction",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "",
    "text": "This lecture covers methods for solving ordinary differential equations (ODEs), which are fundamental to many physics problems. We’ll explore different numerical approaches, from basic to more sophisticated methods."
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html#the-harmonic-oscillator",
    "href": "lectures/lecture08/4_solving_ODEs.html#the-harmonic-oscillator",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "The Harmonic Oscillator",
    "text": "The Harmonic Oscillator\n\n\n\n\n\n\nThe Classical Harmonic Oscillator\n\n\n\nThe harmonic oscillator represents one of the most important physical systems, appearing in: - Mechanical oscillations (springs, pendulums) - Electrical circuits (LC circuits) - Quantum mechanics (quantum harmonic oscillator) - Molecular vibrations\nThe equation of motion is:\n\\[\\begin{equation}\n\\frac{d^2x}{dt^2} + \\omega^2 x = 0\n\\end{equation}\\]\nwhere: - \\(x\\) is the displacement - \\(t\\) is time - \\(\\omega = \\sqrt{k/m}\\) is the angular frequency - \\(k\\) is the spring constant - \\(m\\) is the mass\nInitial conditions required: - Initial position: \\(x(t=0) = x_0\\) - Initial velocity: \\(\\dot{x}(t=0) = v_0\\)"
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html#numerical-solution-methods",
    "href": "lectures/lecture08/4_solving_ODEs.html#numerical-solution-methods",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "Numerical Solution Methods",
    "text": "Numerical Solution Methods\n\n1. Implicit Solution (Crank-Nicolson Method)\nThe matrix approach transforms our second-order ODE into a system of coupled equations. This method is particularly stable for oscillatory systems.\n\nMatrix Construction\nFor \\(N\\) time points, we construct two matrices:\n\nThe second derivative matrix (\\(T\\)):\n\n\\[\\begin{equation}\nT=\\frac{1}{\\delta t^2}\n\\begin{bmatrix}\n-2 & 1  & 0 & \\cdots & 0\\\\\n1 & -2 & 1 & \\cdots & 0\\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\vdots\\\\\n0 & \\cdots & 1 & -2 & 1\\\\\n0 & \\cdots & 0 & 1 & -2\n\\end{bmatrix}\n\\end{equation}\\]\n\nThe potential term matrix (\\(V\\)):\n\n\\[\\begin{equation}\nV = \\omega^2\n\\begin{bmatrix}\n1 & 0 & \\cdots & 0\\\\\n0 & 1 & \\cdots & 0\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n0 & 0 & \\cdots & 1\n\\end{bmatrix}\n\\end{equation}\\]"
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html#explicit-solution-methods",
    "href": "lectures/lecture08/4_solving_ODEs.html#explicit-solution-methods",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "Explicit Solution Methods",
    "text": "Explicit Solution Methods\n\nState-Space Representation\nTo implement explicit numerical methods effectively, we first convert our second-order ODE into a system of first-order equations. This state-space representation is crucial for numerical integration.\nFor the harmonic oscillator:\n\\[\\begin{equation}\n\\ddot{x} + \\omega^2x = 0\n\\end{equation}\\]\nWe define: - Position: \\(x\\) - Velocity: \\(v = \\dot{x}\\)\nThis gives us the system:\n\\[\\begin{equation}\n\\begin{bmatrix} \\dot{x} \\\\ \\dot{v} \\end{bmatrix} =\n\\begin{bmatrix} v \\\\ -\\omega^2x \\end{bmatrix}\n\\end{equation}\\]\nOur state vector is:\n\\[\\begin{equation}\ny = \\begin{bmatrix} x \\\\ v \\end{bmatrix}\n\\end{equation}\\]\n\n\n1. Euler Method\nThe Euler method is the simplest numerical integration technique. It comes directly from the Taylor expansion:\n\\[\\begin{equation}\ny(t + \\Delta t) = y(t) + \\dot{y}(t)\\Delta t + O(\\Delta t^2)\n\\end{equation}\\]\n\n\n\n\n\n\n\n\n2. Euler-Cromer Method\nThe Euler-Cromer method (also known as the semi-implicit Euler method) is particularly good for oscillatory systems because it conserves energy better than the standard Euler method.\nKey difference: - Uses the updated velocity to compute position - Better energy conservation for oscillatory systems\n\\[\\begin{align}\nv_{i+1} &= v_i - \\omega^2 x_i \\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1} \\Delta t\n\\end{align}\\]\n\n\n\n\n\n\n\n\n3. Velocity Verlet Method\nThe Velocity Verlet method is a symplectic integrator that provides excellent energy conservation for Hamiltonian systems. It’s particularly useful for molecular dynamics simulations.\nThe algorithm: 1. Update position using current velocity and acceleration 2. Calculate new acceleration at new position 3. Update velocity using average of old and new accelerations\n\\[\\begin{align}\nx_{i+1} &= x_i + v_i\\Delta t + \\frac{1}{2}a_i\\Delta t^2 \\\\\na_{i+1} &= -\\omega^2 x_{i+1} \\\\\nv_{i+1} &= v_i + \\frac{1}{2}(a_i + a_{i+1})\\Delta t\n\\end{align}\\]\n\n\n\n\n\n\n\n\nComparison of Methods\nLet’s compare these methods for the harmonic oscillator:\n\n\n\n\n\n\n\n\n\n\n\n\nMethod Characteristics\n\n\n\n\nEuler Method:\n\nSimplest method\nFirst-order accurate (\\(O(\\Delta t)\\))\nOften unstable for oscillatory systems\nEnergy tends to increase over time\n\nEuler-Cromer Method:\n\nBetter energy conservation\nStill first-order accurate\nMore stable for oscillatory systems\nEnergy tends to decrease slightly over time\n\nVelocity Verlet Method:\n\nSecond-order accurate (\\(O(\\Delta t^2)\\))\nExcellent energy conservation\nSymplectic (preserves phase space volume)\nRecommended for long-time integration"
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html#solving-odes-with-scipy",
    "href": "lectures/lecture08/4_solving_ODEs.html#solving-odes-with-scipy",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "Solving ODEs with SciPy",
    "text": "Solving ODEs with SciPy\nSciPy provides sophisticated ODE solvers through scipy.integrate.odeint and scipy.integrate.solve_ivp. These implementations use advanced algorithms with automatic step size adjustment and error control.\n\nUsing scipy.integrate.odeint\nThe odeint function uses the LSODA algorithm from the FORTRAN library ODEPACK, which automatically switches between methods for stiff and non-stiff problems.\n\n\n\n\n\n\nStiff vs Non-stiff Problems\n\n\n\n\nStiff problems: Have multiple timescales with widely different magnitudes\nNon-stiff problems: Have timescales of similar magnitude\n\nLSODA uses: - Adams method for non-stiff problems - BDF method (Backward Differentiation Formula) for stiff problems\n\n\n\n\n\n\n\n\n\n\nUsing scipy.integrate.solve_ivp\nThe newer solve_ivp function provides more control over the integration process and supports multiple modern solving methods.\n\n\n\n\n\n\n\n\n\n\n\n\nAvailable Methods in solve_ivp\n\n\n\n\nRK45 (default):\n\nExplicit Runge-Kutta method of order 5(4)\nGood general-purpose method\nAdaptive step size\n\nRK23:\n\nExplicit Runge-Kutta method of order 3(2)\nUsually faster but less accurate than RK45\nGood for rough solutions\n\nDOP853:\n\nExplicit Runge-Kutta method of order 8\nHigh accuracy\nMore expensive computationally\n\nBDF:\n\nImplicit method\nGood for stiff problems\nVariable order (1 to 5)\n\nLSODA:\n\nAutomatic method switching\nAdapts between Adams and BDF\nGood all-purpose solver\n\n\n\n\n\n\nAdvantages of SciPy Methods\n\nAdaptive Step Size:\n\nAutomatically adjusts step size for efficiency\nMaintains desired accuracy\nHandles rapid changes better\n\nError Control:\n\nSpecified through relative and absolute tolerances\nEnsures solution reliability\nProvides error estimates\n\nMethod Selection:\n\nChoose method based on problem characteristics\nAutomatic stiffness detection (LSODA)\nHigher-order methods available\n\nDense Output:\n\nContinuous solution representation\nInterpolation between steps\nEfficient for plotting or further analysis"
  },
  {
    "objectID": "lectures/lecture08/4_solving_ODEs.html#damped-driven-pendulum",
    "href": "lectures/lecture08/4_solving_ODEs.html#damped-driven-pendulum",
    "title": "Solving Ordinary Differential Equations (ODEs)",
    "section": "Damped Driven Pendulum",
    "text": "Damped Driven Pendulum\nThe damped driven pendulum is an excellent example of a nonlinear system that can exhibit both regular and chaotic behavior.\n\n\n\n\n\n\nThe Damped Driven Pendulum Equation\n\n\n\nThe equation of motion is:\n\\[\\begin{equation}\n\\ddot{\\theta} + \\frac{g}{L}\\sin(\\theta) + b\\dot{\\theta} = \\beta\\cos(\\omega t)\n\\end{equation}\\]\nwhere: - \\(\\theta\\) is the angle from vertical - \\(g\\) is gravitational acceleration - \\(L\\) is pendulum length - \\(b\\) is damping coefficient - \\(\\beta\\) is driving amplitude - \\(\\omega\\) is driving frequency\n\n\n\n\n\n\n\n\n\nParameter Study: Transition to Chaos\nLet’s examine how the system behavior changes with driving amplitude:\n\n\n\n\n\n\n\n\n\n\n\n\nKey Features of the Damped Driven Pendulum\n\n\n\n\nRegular Motion:\n\nSmall driving forces lead to periodic motion\nSystem settles into a stable orbit\nPredictable long-term behavior\n\nChaotic Motion:\n\nLarger driving forces can lead to chaos\nSensitive dependence on initial conditions\nUnpredictable long-term behavior\n\nBifurcations:\n\nSystem can transition between different types of motion\nCritical points where behavior changes qualitatively\nPeriod doubling route to chaos\n\nEnergy Balance:\n\nDriving force adds energy\nDamping removes energy\nCompetition leads to rich dynamics\n\n\n\n\n\n\nEnergy Analysis\nLet’s analyze the system’s energy over time:\n\n\n\n\n\n\nThis completes our analysis of the damped driven pendulum, demonstrating its rich dynamical behavior and various analysis techniques. The system serves as an excellent example of how nonlinearity can lead to complex behavior in even seemingly simple mechanical systems."
  },
  {
    "objectID": "lectures/lecture08/3_solving_ODEs.html",
    "href": "lectures/lecture08/3_solving_ODEs.html",
    "title": "Solving ODEs",
    "section": "",
    "text": "All the stuff we have defined in the previous sections is useful for solving ordinary differential equations. This will bring us closer to solving out physics problems now.",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Solving ODEs"
    ]
  },
  {
    "objectID": "lectures/lecture08/3_solving_ODEs.html#harmonic-oscillator",
    "href": "lectures/lecture08/3_solving_ODEs.html#harmonic-oscillator",
    "title": "Solving ODEs",
    "section": "Harmonic Oscillator",
    "text": "Harmonic Oscillator\n\n\n\n\n\n\nPhysics Interlude: The harmonic oscillator\n\n\n\nWe are going to tackle as a first very simple problem, the harmonic oscillator and we will demonstrate that with the matrix (Crank-Nicholson method or implicit scheme), the Euler type integration method and using some ‘unknown’ integrator in the module SciPy.\nThe equation of motion for a classical harmonic oscillator is given\n\\[\\begin{equation}\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2}+\\omega^2 x=0\n\\end{equation}\\]\nThis is a second order differential equation which requires for its solution two initial conditions. The first initial condition is the initial elongation \\(x(t=0)=x_{0}\\) and the second the initial velocity \\(\\dot{x}(t=0)=v_{0}\\).",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Solving ODEs"
    ]
  },
  {
    "objectID": "lectures/lecture08/3_solving_ODEs.html#implicit-solution---crank-nicholson",
    "href": "lectures/lecture08/3_solving_ODEs.html#implicit-solution---crank-nicholson",
    "title": "Solving ODEs",
    "section": "Implicit Solution - Crank Nicholson",
    "text": "Implicit Solution - Crank Nicholson\nLets start with the matrix appraoch we have just learned about. Using the matrix version, we can transform the above equation into a system of coupled equations, which we can solve with some standard methods available from e.g. the SciPy module.\n\nDefine Matrices\nOur matrix will consist of two parts. The first containing the second derivative and the second just the elongation. Suppose we want to calculate the position \\(x(t)\\) at 6 instances in time \\(t_{i}\\) then the matrix version of the second derivative reads as\n(\\(x_{1}=x(t_{1}), \\ldots\\)).\n\\(T=\\frac{d^2x}{dt^2}=\\frac{1}{\\delta t^2}\n\\begin{bmatrix}\n-2 & 1  & 0 & 0 & 0 & 0\\\\\n1 & -2 & 1 & 0 & 0 & 0\\\\\n0 & 1  & -2 & 1 & 0 & 0\\\\\n0 & 0  & 1  & -2 & 1 & 0\\\\\n0 & 0  & 0  &  1 & -2 & 1\\\\\n0 & 0  & 0  &  0 &  1 & -2\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\nx_{3}\\\\\nx_{4}\\\\\nx_{5}\\\\\nx_{6}\n\\end{bmatrix}\\)\nThe second term in the equation of motion is a multiplication of the elongation \\(x(t_{i})\\) by \\(\\omega^{2}\\) and can be written as\n\\(V=\\omega^2 x=\\begin{bmatrix}\n\\omega^2  & 0  & 0 & 0 & 0 & 0\\\\\n0 & \\omega^2  & 0 & 0 & 0 & 0\\\\\n0 & 0  & \\omega^2  & 0 & 0 & 0\\\\\n0 & 0  & 0  & \\omega^2  & 0 & 0\\\\\n0 & 0  & 0  &  0 & \\omega^2  & 0\\\\\n0 & 0  & 0  &  0 &  0 & \\omega^2 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\nx_{3}\\\\\nx_{4}\\\\\nx_{5}\\\\\nx_{6}\n\\end{bmatrix}\\)\nThe left hand side of the would threfore contain a sum of the two matrices \\(M=T+V\\) multiplied by the vector \\(x\\). We have therfore almost all things together to solve this differential equation with the help of an implicit scheme. What we have ignored so far are the initial conditions.\n\n\nUse Initial Conditions\nThe matrix given for the second detivative actually implies already some initial (bounary) conditions. You probably noticed that the matrix contains incomplete coefficients for the second derivative in the first and last line. The first line contains \\((-2,1)\\), but the second derivative should contain \\((1,-2,1)\\). This \\((-2,1)\\) thus always includes the boundary condition that \\(x_{0}=0\\). To include our own initial/boundary conditions, we have to construct the matrix for the second derivative slightly differently and modify the differential equation to\n\\[\\begin{equation}\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2}+\\omega^2 x=b\n\\end{equation}\\]\nwhere the vector b takes care of the initial conditions.\nIf we have \\(N\\) positions in time at which we calculate the elongation \\(x\\), we have a \\(N\\times N\\) matrix of for the second derivatives. The lower \\(N-2\\) lines will contain the the coefficients for the second derivative \\((1,-2,1)\\). The first two lines supply the initial/boundary conditions.\nThe initial condition for the elongation \\(x(t=0)=x_{0}\\) is obtained when the first element of the first line is a 1. The matrix multiplication \\(M\\, x=b\\) for yields thus in the first line \\(x_{1}=b_{1}\\) and we set \\(b_{1}=x_{0}\\). The second line shall give the initial velocity. So the matrix entries of the second line contain a first derivative \\((-1,1)\\). The matrix multiplication thus yields \\(x_{2}-x_{1}=b_{2}\\). We can therefore need to set \\(b_{2}=v_{0}\\delta t\\). All of the other entries of \\(b\\) shall be set to zero according to the differential equation of the harmonic oscillator.\nOur final problem \\(M\\, x=b\\) will thus have the following shape\n\\[\\begin{equation}\n\\begin{bmatrix}\n1 & 0  & 0 & 0 & 0 & 0\\\\\n-1 & 1 & 0 & 0 & 0 & 0\\\\\n1 & -2+\\omega^2*\\delta t^2  & 1 & 0 & 0 & 0\\\\\n0 & 1  & -2+\\omega^2*\\delta t^2  & 1 & 0 & 0\\\\\n0 & 0  & 1  &  -2+\\omega^2*\\delta t^2 & 1 & 0\\\\\n0 & 0  & 0  &  1 &  -2+\\omega^2*\\delta t^2 & 1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\nx_{3}\\\\\nx_{4}\\\\\nx_{5}\\\\\nx_{6}\n\\end{bmatrix}=\n\\begin{bmatrix}\nx_{0}\\\\\nv_{0}\\delta t\\\\\n0\\\\\n0\\\\\n0\\\\\n0\n\\end{bmatrix}\n\\end{equation}\\]\n\n\nSolution\nThis is the final system of coupled equations which we can supply to any matrix solver. We will use a solver from the scipy.linalg module. Lets have a look at the details below.\nN=10\n\n(diags([-2., 1., 1.], [-1,-2, 0],\n    shape=(N, N))+diags([1], [-1], shape=(N, N))* omega**2*dt**2)",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Solving ODEs"
    ]
  },
  {
    "objectID": "lectures/lecture08/3_solving_ODEs.html#explicit-solution---numerical-integration",
    "href": "lectures/lecture08/3_solving_ODEs.html#explicit-solution---numerical-integration",
    "title": "Solving ODEs",
    "section": "Explicit Solution - Numerical Integration",
    "text": "Explicit Solution - Numerical Integration\nBefore implementing explicit numerical schemes, let’s develop a standardized approach for solving ODEs. This framework will allow us to solve different problems using various methods with minimal code modification.\nLet’s examine the free fall problem as an example:\n\\[\\begin{equation}\n\\ddot{x}= -g\n\\end{equation}\\]\nThis second-order equation can be transformed into a system of two first-order equations:\n\\[\\begin{eqnarray}\n\\dot{x} &= v \\\\\n\\dot{v} &= -g\n\\end{eqnarray}\\]\nUsing the Euler method, these equations become:\n\\[\\begin{eqnarray}\nx_{i+1} &= x_i + v_i \\Delta t \\\\\nv_{i+1} &= v_i - g\\Delta t\n\\end{eqnarray}\\]\nNote: The original equations had \\(\\dot{x}\\) and \\(\\dot{v}\\) in the right-hand side, which should be replaced with their actual values (\\(v\\) and \\(-g\\) respectively).\nThese equations can be written more compactly in vector form:\n\\[\\begin{equation}\n\\vec{y}_{i+1} = \\vec{y}_i + \\dot{\\vec{y}}_i \\Delta t\n\\end{equation}\\]\nwhere\n\\[\\begin{equation}\n\\vec{y}=\n\\begin{bmatrix}\nx \\\\\nv\n\\end{bmatrix}\n\\end{equation}\\]\nand\n\\[\\begin{equation}\n\\dot{\\vec{y}}=\n\\begin{bmatrix}\nv \\\\\n-g\n\\end{bmatrix}\n\\end{equation}\\]\nThis vector formulation allows us to separate: 1. Problem definition (specifying \\(\\dot{\\vec{y}}\\) as a function of \\(\\vec{y}\\) and \\(t\\)) 2. Solution method (implementing the numerical integration scheme)\nWe’ll explore three numerical methods:\n\nEuler Method: First-order accurate\nEuler-Cromer Method: Modified Euler method, better for oscillatory systems\nMidpoint Method: Second-order accurate\n\nMore sophisticated methods like the Runge-Kutta family offer higher accuracy but are not covered here.\n\nEuler Method\nThe Euler method is derived from the Taylor expansion of the solution \\(\\vec{y}(t)\\) around the current time \\(t\\):\n\\[\\begin{equation}\n\\vec{y}(t+\\Delta t)=\\vec{y}(t)+\\dot{\\vec{y}}(t)\\Delta t+\\frac{1}{2}\\ddot{\\vec{y}}(t)\\Delta t^{2}+ \\mathcal{O}(\\Delta t^3)\n\\end{equation}\\]\nThe Euler method approximates this by truncating after the first-order term:\n\\[\\begin{equation}\n\\vec{y}(t+\\Delta t) \\approx \\vec{y}(t) + \\dot{\\vec{y}}(t) \\Delta t\n\\end{equation}\\]\nFor our free fall example, this becomes:\n\\[\\begin{equation}\n\\begin{bmatrix} x_{i+1} \\\\ v_{i+1} \\end{bmatrix} =\n\\begin{bmatrix} x_i \\\\ v_i \\end{bmatrix} +\n\\begin{bmatrix} v_i \\\\ -g \\end{bmatrix} \\Delta t\n\\end{equation}\\]\nError Analysis: The method has two distinct types of errors. The local truncation error, which represents the error made in a single step, is of order \\(\\mathcal{O}(\\Delta t^2)\\). This corresponds to the first term omitted in the Taylor expansion. The global truncation error, which accumulates over the entire integration interval \\([0,\\tau]\\), is of order \\(\\mathcal{O}(\\Delta t)\\). This can be understood by considering that we take \\(N = \\tau/\\Delta t\\) steps, each contributing an error proportional to \\(\\Delta t^2\\). The total error thus scales as \\(N \\cdot \\Delta t^2 = \\tau \\Delta t\\).\nLimitations and Extensions: The method is directly applicable only to first-order systems of the form \\(\\dot{\\vec{y}} = \\vec{f}(\\vec{y},t)\\). However, this is not a fundamental limitation as higher-order equations can be converted to systems of first-order equations. For example, a second-order equation \\(\\ddot{x} = f(x,\\dot{x},t)\\) can be transformed into a system of two first-order equations by introducing the velocity as an additional variable. The resulting system becomes:\n\\[\\begin{equation}\n\\begin{bmatrix} \\dot{x} \\\\ \\dot{v} \\end{bmatrix} =\n\\begin{bmatrix} v \\\\ f(x,v,t) \\end{bmatrix}\n\\end{equation}\\]\nThis transformation allows us to apply the method to a wider class of problems while maintaining its fundamental characteristics.\n\n\nEuler-Cromer Method\nThe Euler-Cromer method (also known as the semi-implicit Euler method) modifies the basic Euler method by using the updated velocity when calculating the position. For a system described by position and velocity:\n\\[\\begin{equation}\n\\begin{aligned}\n\\dot{x} &= v \\\\\n\\dot{v} &= f(x,v,t)\n\\end{aligned}\n\\end{equation}\\]\nThe integration steps are:\n\\[\\begin{equation}\n\\begin{aligned}\nv_{i+1} &= v_i + f(x_i,v_i,t_i)\\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1}\\Delta t\n\\end{aligned}\n\\end{equation}\\]\nFor our free fall example: \\[\\begin{equation}\n\\begin{aligned}\nv_{i+1} &= v_i - g\\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1}\\Delta t\n\\end{aligned}\n\\end{equation}\\]\nEnergy Behavior: The method shows improved energy conservation for oscillatory systems compared to the standard Euler method. While the Euler method typically increases energy over time, the Euler-Cromer method exhibits small energy oscillations around the correct value.\nError Analysis: The method maintains a local truncation error of \\(\\mathcal{O}(\\Delta t^2)\\) and a global truncation error of \\(\\mathcal{O}(\\Delta t)\\). Despite having the same order of accuracy as the Euler method, it provides more stable solutions for oscillatory systems.\nAdvantages: The Euler-Cromer method represents a simple modification of the Euler method that achieves better stability for oscillatory systems without requiring additional function evaluations.\nLimitations: The method remains first-order accurate globally and is not symmetric in time. While it performs well for certain types of problems, particularly oscillatory systems, it may not be suitable for all differential equations.\nComparison with Euler Method:\n# Euler Method\nv[i+1] = v[i] + f(x[i],v[i],t[i])*dt\nx[i+1] = x[i] + v[i]*dt       # Uses old velocity\n\n# Euler-Cromer Method\nv[i+1] = v[i] + f(x[i],v[i],t[i])*dt\nx[i+1] = x[i] + v[i+1]*dt     # Uses new velocity\n\n\nMidpoint Method\nThe Midpoint Method (also known as the second-order Runge-Kutta method) improves upon both the Euler and Euler-Cromer methods by using the average of the derivatives at the current point and an estimated midpoint.\nFor a system of first-order differential equations:\n\\[\\begin{equation}\n\\dot{\\vec{y}} = \\vec{f}(\\vec{y},t)\n\\end{equation}\\]\nThe algorithm proceeds in two steps:\n\nCalculate an intermediate point using an Euler step to the midpoint: \\[\\begin{equation}\n\\vec{k}_1 = \\vec{f}(\\vec{y}_i,t_i)\n\\end{equation}\\] \\[\\begin{equation}\n\\vec{y}_{i+1/2} = \\vec{y}_i + \\frac{\\Delta t}{2}\\vec{k}_1\n\\end{equation}\\]\nUse the derivative at this midpoint for the full step: \\[\\begin{equation}\n\\vec{k}_2 = \\vec{f}(\\vec{y}_{i+1/2},t_i+\\Delta t/2)\n\\end{equation}\\] \\[\\begin{equation}\n\\vec{y}_{i+1} = \\vec{y}_i + \\Delta t\\vec{k}_2\n\\end{equation}\\]\n\nFor our free fall example, this becomes:\n\\[\\begin{equation}\n\\begin{aligned}\nv_{i+1/2} &= v_i - \\frac{g\\Delta t}{2} \\\\\nx_{i+1/2} &= x_i + v_i\\frac{\\Delta t}{2} \\\\\nv_{i+1} &= v_i - g\\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1/2}\\Delta t\n\\end{aligned}\n\\end{equation}\\]\nError Analysis: The method achieves higher accuracy than both Euler and Euler-Cromer methods with:\n\nLocal truncation error: \\(\\mathcal{O}(\\Delta t^3)\\)\nGlobal truncation error: \\(\\mathcal{O}(\\Delta t^2)\\)\n\nImplementation:\ndef midpoint_step(y, t, dt, f):\n    # Calculate k1\n    k1 = f(y, t)\n\n    # Calculate midpoint\n    y_mid = y + 0.5 * dt * k1\n\n    # Calculate k2 at midpoint\n    k2 = f(y_mid, t + 0.5*dt)\n\n    # Full step using midpoint derivative\n    return y + dt * k2\n\n\n\n\n\n\n\n\n\n\n\nPutting it all together\nNow we can implement our numerical solution by combining our understanding of both the physical system and numerical methods. This implementation consists of two main parts: defining the differential equation and solving it numerically.\n\nThe Definition of the Problem\nFor the simple harmonic oscillator, we start with the second-order differential equation:\n\\[\\begin{equation}\n\\frac{d^2x}{dt^2} + \\omega^2x = 0\n\\end{equation}\\]\nTo solve this numerically, we convert it to a system of first-order equations using our state vector \\(\\vec{y} = [x, v]^T\\):\n\\[\\begin{equation}\n\\frac{d}{dt}\\begin{bmatrix} x \\\\ v \\end{bmatrix} =\n\\begin{bmatrix} v \\\\ -\\omega^2x \\end{bmatrix}\n\\end{equation}\\]\nThis is implemented as: ~~~ def SHO(state, time): ““” Define the harmonic oscillator system. state[0] : position x state[1] : velocity v returns : [dx/dt, dv/dt] ““” g0 = state[1] # dx/dt = v g1 = -k/m*state[0] # dv/dt = -ω²x return np.array([g0, g1]) ~~~\nThis function defines our physical system by returning the derivatives of our state variables at any given point.\n\n\nSolving the Problem\nWith our system defined, we can implement the numerical solution using Euler’s method. The basic algorithm takes the current state and advances it by one time step:\ndef euler(y, t, dt, derivs):\n    \"\"\"\n    Perform one step of the Euler method.\n    y      : current state [x, v]\n    t      : current time\n    dt     : time step\n    derivs : function returning derivatives\n    \"\"\"\n    y_next = y + derivs(y, t) * dt\n    return y_next\nThis simple structure allows us to solve different physical problems by just changing the derivative function. For example, we can solve the free fall problem with initial conditions \\(x_0=0\\) and \\(v_0=10\\), or the harmonic oscillator with specified spring constant \\(k\\) and mass \\(m\\).\nThe key advantage of this structure lies in its flexibility. We can change the physical system by providing a different derivative function, implement various numerical methods by modifying the integration step, and explore the system behavior by adjusting parameters and initial conditions. This modular approach allows us to study a wide range of physical systems using the same basic numerical framework.",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Solving ODEs"
    ]
  },
  {
    "objectID": "lectures/lecture08/3_solving_ODEs.html#solving-the-harmonic-oscillator-with-scipy",
    "href": "lectures/lecture08/3_solving_ODEs.html#solving-the-harmonic-oscillator-with-scipy",
    "title": "Solving ODEs",
    "section": "Solving the Harmonic Oscillator with SciPy",
    "text": "Solving the Harmonic Oscillator with SciPy\nHaving explored basic numerical integration methods, we can now utilize more sophisticated tools available in SciPy. The scipy.integrate.odeint() function provides a robust and accurate integration method with several advantages over our simple implementations.\nTo use SciPy’s integrator:\nfrom scipy.integrate import odeint\nThe basic syntax is:\nsolution = odeint(derivative_function, initial_conditions, time_points)\nwhere:\n\nderivative_function defines the system (like our SHO function)\ninitial_conditions is a vector containing \\([x_0, v_0]\\)\ntime_points is an array of times at which to compute the solution\n\nThe odeint function offers several significant advantages over our simple implementations. It features adaptive step size control, which automatically adjusts the integration step size based on the local error. The function performs continuous error estimation and correction to maintain accuracy throughout the integration. It also provides various integration methods that can be selected based on the problem’s requirements. The function is capable of handling stiff equations, which are particularly challenging for simpler methods, and generally provides better numerical stability across a wide range of problems.\nFor example, to solve the harmonic oscillator:\ndef SHO(state, t, k=1.0, m=1.0):\n    x, v = state\n    return [v, -k/m * x]\n\n# Initial conditions\ny0 = [1.0, 0.0]  # x₀ = 1, v₀ = 0\nt = np.linspace(0, 10, 1000)\n\n# Solve the system\nsolution = odeint(SHO, y0, t)\nThe solution array contains:\n\nsolution[:, 0]: position values\nsolution[:, 1]: velocity values\n\nHaving understood the fundamentals of numerical integration through our implementations of Euler and other methods, we can now confidently use this more sophisticated tool for solving differential equations more accurately and efficiently.\n\nSetup\n\n\n\n\n\n\n\n\nDefinition\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nPlotting",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Solving ODEs"
    ]
  },
  {
    "objectID": "lectures/lecture08/3_solving_ODEs.html#damped-driven-pendulum-in-scipy",
    "href": "lectures/lecture08/3_solving_ODEs.html#damped-driven-pendulum-in-scipy",
    "title": "Solving ODEs",
    "section": "Damped Driven Pendulum in SciPy",
    "text": "Damped Driven Pendulum in SciPy\nWrite a derivs function for a damped driven pendulum:\n\\[\\begin{equation}\n\\ddot{\\theta}=-\\frac{g}{L}\\sin(\\theta)-b \\dot{\\theta}+\\beta\\cos(\\omega t)\n\\end{equation}\\]\nUse this derivs function with the SciPy solver and plot the result for different parameters. Vary the damping parameter \\(b\\). Observe the contributions of the homogeneous and the particular solution. Plot the amplitude of the stationary solution as a function of frequency!\n\nSetup\n\n\n\n\n\n\n\n\nDefinition\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nPlotting",
    "crumbs": [
      "Python Basics",
      "Lecture 8",
      "Solving ODEs"
    ]
  },
  {
    "objectID": "lectures/lecture06/test.html",
    "href": "lectures/lecture06/test.html",
    "title": "Title",
    "section": "",
    "text": "viewof aSlider = Inputs.range([-4, 0], { label: \"a\", step: 0.01, value: -1.7 });\nviewof bSlider = Inputs.range([-2, 2], { label: \"b\", step: 0.01, value: 1.3 });\nviewof cSlider = Inputs.range([-2, 2], { label: \"c\", step: 0.01, value: 1.0 });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered = transpose(data);\n// Create the plot\n\nxValues = Array.from({ length: 100 }, (_, i) =&gt; i / 100);\nparabolaData = xValues.map(x =&gt; ({ x, y: parabola(x, aSlider, bSlider, cSlider) }));\n\n\nparabola = (x, a, b, c) =&gt; a * x**2 + b * x + c\n\ncalculateChiSquared = (data, a, b, c) =&gt; {\n  let chisq = 0\n  let x= data.map(d =&gt; d.x)\n  let y= data.map(d =&gt; d.y)\n  let err= data.map(d =&gt; d.error)\n  for (let i = 0; i &lt; x.length; i++) {\n    let y_model = parabola(x[i], a, b, c)\n    chisq += ((y[i] - y_model) / err[i])**2\n  }\n  return chisq\n}\n\nchisq = calculateChiSquared(filtered, aSlider, bSlider, cSlider)\n\nPlot.plot({\n  marks: [\n    Plot.dot(filtered, { x: \"x\", y: \"y\" }),\n    Plot.ruleY(filtered, { x: \"x\", y1: d =&gt; d.y - d.error, y2: d =&gt; d.y + d.error }),\n    Plot.line(parabolaData, { x: \"x\", y: \"y\" }),\n    Plot.text([{ x: 0.8, y: 1.5, label: `χ²: ${chisq.toFixed(2)}` }], {\n          x: \"x\",\n          y: \"y\",\n          text: \"label\",\n          dy: -10, // Adjust vertical position if needed\n          fill: \"black\", // Set text color\n          fontSize: 16\n        }),\n    Plot.frame()\n  ],\n  x: {\n    label: \"X Axis\",\n    labelAnchor: \"center\",\n    labelOffset: 35,\n    grid: true,\n    tickFormat: \".2f\", // Format ticks to 2 decimal places\n    domain: [0, 1]\n  },\n  y: {\n    label: \"Y Axis\",\n    grid: true,\n    tickFormat: \".2f\", // Format ticks to 2 decimal places\n    labelAnchor: \"center\",  // Center the label on its axis\n    labelAngle: -90,\n    labelOffset: 60,\n    domain: [0, 2],\n  },\n  width: 400,\n  height: 400,\n  marginLeft: 100,\n  marginBottom: 40,\n  style: {\n    fontSize: \"14px\",          // This sets the base font size\n    \"axis.label\": {\n      fontSize: \"18px\",        // This sets the font size for axis labels\n      fontWeight: \"bold\"       // Optionally make it bold\n    },\n    \"axis.tick\": {\n      fontSize: \"14px\"         // This sets the font size for tick labels\n    }\n  },\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello Here’s how you can do it:\n\nStep 1: Create the DataFrame in Python\n\n\n\n\n\n\n\nimport numpy as np\nimport io\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\nplt.rcParams.update({'font.size': 18})\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\n\n# default values for plotting\nplt.rcParams.update({'font.size': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 11,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndata_str= \"\"\"\n0.000000000000000000e+00 9.916839204057067425e-01 5.332818799198481979e-02\n1.111111111111111049e-01 1.183667840440161712e+00 5.339559646742838422e-02\n2.222222222222222099e-01 1.310862148961057017e+00 5.366783326382672248e-02\n3.333333333333333148e-01 1.193174867265999639e+00 5.435097493883071090e-02\n4.444444444444444198e-01 1.265354130824580148e+00 5.576995501488732354e-02\n5.555555555555555802e-01 1.234277634100806154e+00 5.832636573698059268e-02\n6.666666666666666297e-01 1.067204799568996387e+00 6.242706729257353759e-02\n7.777777777777776791e-01 7.113706894723520469e-01 6.840334070620925078e-02\n8.888888888888888395e-01 5.111625429539546905e-01 7.645872257082597656e-02\n1.000000000000000000e+00 1.360838209996238390e+00 4.666811165343753287e-01\n\"\"\"\nx_data, y_data, err = np.loadtxt(io.StringIO(data_str), unpack=True)\n\ndef parabola(x,a,b,c):\n    return(a*x**2+b*x+c)\n\ndef plot(a,b,c):\n    y=parabola(x,a,b,c)\n    plt.figure(figsize=(8,6))\n    chisq=(((y_data-parabola(x_data,a,b,c))/err)**2).sum()\n    plt.plot(x,y,label=r'$\\chi^2$={0:6.3f}'.format(chisq))\n    plt.errorbar(x_data,y_data,yerr=err,marker='o',fmt=\"none\",color='k')\n\n    plt.scatter(x_data,y_data,marker='o',color='k')\n    plt.legend()\n    plt.xlabel('x- position')\n    plt.ylabel('y- position')\n    plt.show()\n\nx=np.linspace(0,1,100)\ninteract(plot,a=-1.7,b=1.3,c=1.0);"
  },
  {
    "objectID": "lectures/lecture06/01-lecture06.html",
    "href": "lectures/lecture06/01-lecture06.html",
    "title": "Lecture 6",
    "section": "",
    "text": "Advanced conditionals and loops for simulating complex scenarios.\nIntroduction to basic data structures (dictionaries) for handling multiple objects.\n\n\n\n\n\nSimulating elastic and inelastic collisions in one and two dimensions.\nApplying conservation laws (momentum and energy) to check the validity of the simulation.\nVisualization: Plotting the trajectories and velocities of colliding objects.\nHomework: Simulate a multi-object collision scenario."
  },
  {
    "objectID": "lectures/lecture06/01-lecture06.html#collisions-and-conservation-laws",
    "href": "lectures/lecture06/01-lecture06.html#collisions-and-conservation-laws",
    "title": "Lecture 6",
    "section": "",
    "text": "Advanced conditionals and loops for simulating complex scenarios.\nIntroduction to basic data structures (dictionaries) for handling multiple objects.\n\n\n\n\n\nSimulating elastic and inelastic collisions in one and two dimensions.\nApplying conservation laws (momentum and energy) to check the validity of the simulation.\nVisualization: Plotting the trajectories and velocities of colliding objects.\nHomework: Simulate a multi-object collision scenario."
  },
  {
    "objectID": "lectures/lecture01/02-summary01.html",
    "href": "lectures/lecture01/02-summary01.html",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\nx = 1.0  # Assigns 1.0 to variable x\nmy_variable = \"Hello\"  # Assigns string \"Hello\"\n\n\n\nUse a-z, A-Z, 0-9, and _\nStart with letter or underscore\nCase-sensitive\nAvoid reserved keywords\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n5\nWhole numbers\n\n\nfloat\n3.14\nDecimal numbers\n\n\ncomplex\n2 + 3j\nReal + imaginary\n\n\nbool\nTrue\nLogical values\n\n\n\n\n\n\nint_num = int(3.14)    # 3\nfloat_num = float(5)   # 5.0\nstr_num = str(42)      # \"42\"\n\n\n\n\na, b = 10, 3\nsum_result = a + b   # Addition\ndiff_result = a - b  # Subtraction\nprod_result = a * b  # Multiplication\ndiv_result = a / b   # Division (float)\nint_div_result = a // b  # Integer division\nmod_result = a % b   # Modulus\npower_result = a ** b  # Exponentiation\n\n\n\nc = 2 + 4j\nreal_part = c.real     # 2.0\nimag_part = c.imag     # 4.0\nconjugate = c.conjugate()  # 2 - 4j\n\n\n\ntype(variable)  # Returns type\nisinstance(variable, type)  # Checks type\n\n\n\nimport math\n\nsqrt_result = math.sqrt(16)\nlog_result = math.log(100, 10)\nsin_result = math.sin(math.pi/2)"
  },
  {
    "objectID": "lectures/lecture01/02-summary01.html#python-basics-cheat-sheet",
    "href": "lectures/lecture01/02-summary01.html#python-basics-cheat-sheet",
    "title": "Einführung in die Modellierung Physikalischer Prozesse",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\nx = 1.0  # Assigns 1.0 to variable x\nmy_variable = \"Hello\"  # Assigns string \"Hello\"\n\n\n\nUse a-z, A-Z, 0-9, and _\nStart with letter or underscore\nCase-sensitive\nAvoid reserved keywords\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n5\nWhole numbers\n\n\nfloat\n3.14\nDecimal numbers\n\n\ncomplex\n2 + 3j\nReal + imaginary\n\n\nbool\nTrue\nLogical values\n\n\n\n\n\n\nint_num = int(3.14)    # 3\nfloat_num = float(5)   # 5.0\nstr_num = str(42)      # \"42\"\n\n\n\n\na, b = 10, 3\nsum_result = a + b   # Addition\ndiff_result = a - b  # Subtraction\nprod_result = a * b  # Multiplication\ndiv_result = a / b   # Division (float)\nint_div_result = a // b  # Integer division\nmod_result = a % b   # Modulus\npower_result = a ** b  # Exponentiation\n\n\n\nc = 2 + 4j\nreal_part = c.real     # 2.0\nimag_part = c.imag     # 4.0\nconjugate = c.conjugate()  # 2 - 4j\n\n\n\ntype(variable)  # Returns type\nisinstance(variable, type)  # Checks type\n\n\n\nimport math\n\nsqrt_result = math.sqrt(16)\nlog_result = math.log(100, 10)\nsin_result = math.sin(math.pi/2)"
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "Variables & Numbers",
    "section": "",
    "text": "Variable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nThere are a number of Python keywords that cannot be used as variable names because Python uses them for other things. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\n\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "title": "Variables & Numbers",
    "section": "",
    "text": "Variable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nThere are a number of Python keywords that cannot be used as variable names because Python uses them for other things. These keywords are:\nand, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield\nBe aware of the keyword lambda, which could easily be a natural variable name in a scientific program. However, as a reserved keyword, it cannot be used as a variable name.\n\n\n\n\n\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#number-types",
    "href": "lectures/lecture01/02-lecture01.html#number-types",
    "title": "Variables & Numbers",
    "section": "Number Types",
    "text": "Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\nComparison of Number Types\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n\n\n\nExamples for Number Types\n\n\n\n\n\n\nIntegers\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\nFloating Point Numbers\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\nComplex Numbers\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  }
]